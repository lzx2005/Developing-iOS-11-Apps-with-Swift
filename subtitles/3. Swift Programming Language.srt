1
00:00:00,401 --> 00:00:03,568
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:03,637 --> 00:00:07,239
Stanford University. >> Okay,
斯坦福大学

3
00:00:07,307 --> 00:00:12,311
well welcome to lecture number three of Stanford CS193P,
欢迎参加斯坦福 CS193P 课程

4
00:00:12,379 --> 00:00:16,447
fall of 2017 and 18 academic year.
2017 至 18 学年的第三节课

5
00:00:16,516 --> 00:00:19,885
Today mostly, we're gonna talk about some Swift stuff.
今天，大部分时间我们将要讨论 Swift

6
00:00:19,953 --> 00:00:23,321
Now, you've hopefully done your homework for the reading,
现在，希望你已经完成了你的阅读家庭作业

7
00:00:23,390 --> 00:00:25,891
so some of the stuff will be kinda summary, but
所以这节课的一部分将会是总结那些内容

8
00:00:25,959 --> 00:00:28,560
some of this is really not covered in the reading.
而这节课其他的并没有在阅读材料中涵盖

9
00:00:28,629 --> 00:00:32,197
So I'm trying to give you the full picture of stuff,
所以我将试图给你展示这些内容的全貌

10
00:00:32,266 --> 00:00:36,201
that reading is really great but it is great concise.
阅读材料是很棒的，但是它是非常简洁的

11
00:00:36,270 --> 00:00:37,201
I know you probably feel like well,
我知道你可能会觉得

12
00:00:37,270 --> 00:00:39,171
that was a lot of reading for something that's concise, but
要说它简明的话，内容是不是太多了

13
00:00:39,240 --> 00:00:41,473
it is quite concise. So I'm gonna try and
但是它是非常简明的，所以我要尝试

14
00:00:41,541 --> 00:00:43,909
cover some of the other stuff. But before I do all that,
涵盖一些其他的东西。在我开始之前

15
00:00:43,977 --> 00:00:46,912
I'm gonna do a little, what I call a teaser demo of
我要做个简单的，我管它叫做 Auto Layout 的预告示例

16
00:00:46,981 --> 00:00:50,115
Auto Layout where I'm gonna show you how we can make
在这里我将展示，在翻牌游戏中

17
00:00:50,184 --> 00:00:53,919
our UI in concentration look good when we rotate the phone,
当我们旋转手机或者在不同尺寸的手机上运行程序的时候

18
00:00:53,987 --> 00:00:57,355
or when we a run on little bit different sized iPhone, or
如何令我们的 UI 看起来很不错

19
00:00:57,424 --> 00:01:01,226
whatever. I call it a teaser because I don't intend to
我把它叫做一个预告示例是因为我不想现在

20
00:01:01,295 --> 00:01:04,295
teach you Auto Layout which is the feature that allows
教你 Auto Layout 的内容，虽然正是它才让我们

21
00:01:04,364 --> 00:01:06,765
us to do that. It's just to show you what's possible.
能够这么做。这个示例仅仅是向你展示一些可能性

22
00:01:06,833 --> 00:01:09,034
We'll actually have a whole lecture on auto
事实上我们会在三周后有完整的关于 Auto Layout

23
00:01:09,103 --> 00:01:13,204
layout in about three weeks I think. But then,
的一堂课。除此之外

24
00:01:13,273 --> 00:01:15,907
after I do that little demo, I'll be back. I'm first gonna
在做完那个小示例程序之后，我就会回归主题。我会

25
00:01:15,976 --> 00:01:18,577
take just one minute to review what you should have
先用一小会儿时间复习你应该

26
00:01:18,645 --> 00:01:21,513
learned by what we did last week and I'm literally just
在上周已经学会的内容，我会仅仅

27
00:01:21,582 --> 00:01:24,482
gonna read it off a list with quick examples. And you can
照着列表过一遍，每条都有个简单的例子

28
00:01:24,551 --> 00:01:26,818
kind of say in your head, oh yeah, yeah I got that,
你可以在心里默念，是的，是的我掌握了那条内容

29
00:01:26,887 --> 00:01:29,454
I got that or oh wait, I did not really understand that and
我掌握了那条，噢等等，我并没有真的理解那条内容

30
00:01:29,523 --> 00:01:31,390
that's a prompt to go back and look at it.
那会促使你返回去查看

31
00:01:31,458 --> 00:01:34,626
Then we'll dive into this long list that you see up here,
之后我们会深入这个长长的列表，就是在这里你看到的这个

32
00:01:34,694 --> 00:01:38,163
of various Swift things. So let's start with this demo I
上面有各种各样的 Swift 内容。让我们以这个我当时谈论的

33
00:01:38,232 --> 00:01:41,232
was talking about, this Auto Layout demo.
Auto Layout 示例程序开始吧

34
00:01:41,301 --> 00:01:45,770
What we're gonna do here, and I apologize for any technical
我提前为我们将要做的过程中会出现的任何技术

35
00:01:45,839 --> 00:01:48,873
problems we have here because, actually, my computer died,
问题向你们道歉。因为实际上我的电脑死机了

36
00:01:48,942 --> 00:01:51,008
and I had to put it. This is all brand new computer, so
所以我不得不用这台全新的电脑

37
00:01:51,077 --> 00:01:54,512
I hope everything's installed properly. But here's the code,
我希望一切都安装好了。但这是我们的代码

38
00:01:54,581 --> 00:01:58,016
I think, that we had at the end of the last lecture.
我们在上节课结束时的代码

39
00:01:58,085 --> 00:02:01,986
And the UI looks pretty good. We laid it out.
我们布局的 UI 看起来很不错

40
00:02:02,055 --> 00:02:04,156
But I just did this by dragging these things and
仅仅是通过拖拽这些东西并

41
00:02:04,224 --> 00:02:06,624
using the little dash blue lines to put them
利用蓝色的虚线把它们放到了位

42
00:02:06,693 --> 00:02:11,763
in position. And when we run this thing, it looks okay but
当我们运行它的时候看起来很不错

43
00:02:11,832 --> 00:02:13,464
only on an iPhone X and
不过只是在 iPhone X

44
00:02:13,533 --> 00:02:16,534
only in portrait mode like this. If I were to for
像这样竖屏的时候。但比如我

45
00:02:16,603 --> 00:02:20,772
example, rotate this iPhone to the side which I can do
沿着侧边旋转这台 iPhone，我可以通过

46
00:02:20,841 --> 00:02:23,742
in a simulator by going, Hardware, rotate left or
Simulator 菜单栏里的 Hardware > Rotate Left 或

47
00:02:23,811 --> 00:02:28,579
right, you can see that my UI looks like this. My buttons
Right。你可以看到我的 UI 看起来是这样子。我的按钮

48
00:02:28,648 --> 00:02:31,983
are kind of all jammed in the corner here. I've lost flips,
都挤在了这个角落里。我丢失了一些卡片

49
00:02:32,052 --> 00:02:34,285
it's down here somewhere. I can't even see it.
它们在下面某个地方，甚至都看不见了

50
00:02:34,354 --> 00:02:37,756
Still works, but it's kind of off in the middle of nowhere.
仍然可以工作，但都偏到不知道什么鬼地方去了

51
00:02:37,824 --> 00:02:40,826
What we really want is for this UI to spread itself
我们真正想要的是让 UI 能够伸展开来

52
00:02:40,894 --> 00:02:44,762
out and fill the whole space that's involved. By the way,
填满整个可用的空间。顺便说一下

53
00:02:44,831 --> 00:02:47,766
you can also rotate your device with Command and
你可以用 Command 键和方向键来旋转设备

54
00:02:47,835 --> 00:02:51,102
the arrows. Kind of a cool way to flip back and
这是用来旋转设备的比较酷的方式

55
00:02:51,171 --> 00:02:54,305
forth. All right, so how are we gonna do that?
好的，接下来我们该如何做呢？

56
00:02:54,374 --> 00:02:57,209
How are we gonna make our UI expand? Let's go ahead and
我们该如何让我们的 UI 展开？让我们

57
00:02:57,277 --> 00:02:59,444
open up here, give ourselves some more space.
清理下工作环境，给自己更多的空间

58
00:02:59,513 --> 00:03:00,846
And also I'm gonna zoom in a little so
我还想再放大一点让你们

59
00:03:00,914 --> 00:03:03,949
you can see. Another thing I'm gonna do is we're gonna be
可以看到。我要做的另一件事情是我们将要

60
00:03:04,018 --> 00:03:06,150
using these blue lines, the dashed blue
利用这些蓝色的线，这些当你移动组件的时候

61
00:03:06,219 --> 00:03:09,488
line that appears as you move things around as part of this.
出现的虚线作为解决方案的一部分

62
00:03:09,556 --> 00:03:12,256
So I'm gonna change my background from
我要将我的背景

63
00:03:12,325 --> 00:03:15,494
to back to white temporarily, just so
暂时从黑色变成白色，仅仅是让

64
00:03:15,563 --> 00:03:18,296
that we can see that those blue lines and
我们能够更好的看到那些蓝色的线

65
00:03:18,364 --> 00:03:20,331
stuff a little bit better. So I'm just gonna go to white.
和组件。所以我设置成白色

66
00:03:20,400 --> 00:03:22,400
When we come to run, I'll turn it back to black.
当我们运行的时候，我会改回黑色

67
00:03:22,469 --> 00:03:27,104
So this is purely for dealing development issues here. So
这完全是为了方便开发而做的

68
00:03:27,173 --> 00:03:31,009
it's really kinda two things I need to do to make this work.
为了让它能够工作，我需要做的是两件事情

69
00:03:31,077 --> 00:03:35,246
One is, I need to kinda take all those buttons and
第一件事，我需要选中所有的按钮并

70
00:03:35,315 --> 00:03:37,249
make them stick to the edges, right?
让它们粘在屏幕的边缘，对吧？

71
00:03:37,318 --> 00:03:38,483
So that when they rotate and
这样子当它们旋转

72
00:03:38,552 --> 00:03:42,287
the edges get longer and skinnier, they stick.
屏幕边缘变得更加细长，它们可以粘在上面

73
00:03:42,355 --> 00:03:45,390
Right now, everything's stuck to the upper left corner.
现在，所有东西都堆在了左上角

74
00:03:45,458 --> 00:03:47,258
The upper left corner, you're gonna find out next week,
你会在下周发现左上角

75
00:03:47,327 --> 00:03:50,829
is the origin of drawing. In IOS where everything is kinda
是绘图的原点。在 iOS 里任何东西

76
00:03:50,897 --> 00:03:52,998
stuck up to the upper left and then just, so
都会堆到左上角，所以

77
00:03:53,066 --> 00:03:55,600
when we rotate it all, it just goes off the bottom,
当我们旋转整个屏幕的时候，界面会延伸到下方

78
00:03:55,668 --> 00:03:58,536
we can't see it. So that's really what we need to do, but
导致我们没法看到它。所以那是我们需要做的事情

79
00:03:58,605 --> 00:03:59,904
to stick them to the edges,
但要将按钮粘连到边缘

80
00:03:59,973 --> 00:04:02,807
we also kind of need to group them together. Because when
我们先需要把它们组合在一起。因为当

81
00:04:02,876 --> 00:04:05,544
the edges pull this group of 12 buttons apart,
边缘把这 12 个一组的按钮拉开的时候

82
00:04:05,613 --> 00:04:07,812
they all need to kinda share that space.
它们需要分享这个空间

83
00:04:07,881 --> 00:04:09,581
So there's two things we have to do.
所以这就是我们必须要做的两件事情

84
00:04:09,650 --> 00:04:12,584
One is group them together, one is pin them to the edges.
一是把他们组合在一起，一是把它们钉在边缘上

85
00:04:12,653 --> 00:04:17,756
So we're gonna do that with two different features in IOS.
我们将要用 iOS 中两个不同的特性来做这件事

86
00:04:17,824 --> 00:04:19,257
One, the grouping things together,
其一，把按钮组合在一起

87
00:04:19,326 --> 00:04:22,227
we're gonna do with stack view. Okay, so UI stack view
我们要用 stack view（栈）来做。UIStackView 是

88
00:04:22,296 --> 00:04:26,231
is just another class in IOS like UI Button is a class and
iOS 中另一个类，就像 UIButton 是一个类

89
00:04:26,300 --> 00:04:29,734
UI label is just another view in fact. And
UILabel 实际上也是个视图一样

90
00:04:29,803 --> 00:04:32,770
what it does is it will take other views, like let's
它所做的就是将其他的视图，像这

91
00:04:32,839 --> 00:04:36,508
say these four buttons and it will stack them together.
四个按钮，然后把它们堆叠在一起

92
00:04:36,577 --> 00:04:39,244
Now, it only knows how to stack horizontally or
它只知道如何横向或竖向地堆叠

93
00:04:39,313 --> 00:04:42,981
vertically. It can't stack 12 of these things in two
它不能直接将这 12 个按钮进行

94
00:04:43,050 --> 00:04:45,950
dimensions like this. So I'm gonna have to make three
二维的排列，所以我不得不创建三个

95
00:04:46,019 --> 00:04:50,155
horizontal stacks out of this group, out of this group, and
横向的栈，这些一组，这些一组

96
00:04:50,223 --> 00:04:53,024
out of this group. But then I'll take those three stacks
这些一组。之后我再将这三个栈

97
00:04:53,092 --> 00:04:55,794
and stack them vertically. Cuz it's perfectly fine to put
竖向地堆在一起。因为把栈放到栈里

98
00:04:55,863 --> 00:04:59,230
stacks inside stacks, all right? And once I do that,
是完全可行的。一旦我这么做了

99
00:04:59,299 --> 00:05:02,667
I'll have all 12 of these kinda stocked together. And
我将把全部的 12 个按钮都堆叠在了一起

100
00:05:02,736 --> 00:05:05,803
then I can pin it to the edges and they'll stretch out. So
再钉到边缘，这些按钮就会自己分散开

101
00:05:05,872 --> 00:05:07,405
how do we make this stack use?
我们该如何创建 stack view 呢？

102
00:05:07,473 --> 00:05:10,074
Super simple, you just select it here. Let me zoom in so
非常简单，你仅需要选中这里。让我放大一点

103
00:05:10,143 --> 00:05:12,977
we can really see what's going on here. We only need the top
方便看到正在发生什么。我们暂时仅需要

104
00:05:13,046 --> 00:05:15,347
part for now. So I selected these four things.
顶端的部分。所以我选中了这四个按钮

105
00:05:15,416 --> 00:05:17,215
I'm going down to this button right here.
我去到下面这里的这个按钮

106
00:05:17,284 --> 00:05:19,751
You see this button, embed in stack?
你看到这个写着 Embed In Stack 的按钮了么？

107
00:05:19,820 --> 00:05:22,020
Well, that's what it does. It embeds in stack.
没错，那就是它所做的事情：把东西嵌入栈中

108
00:05:22,089 --> 00:05:24,188
And it embedded it. Now, couple of things.
它把这四个按钮嵌进去了，但有几个问题

109
00:05:24,257 --> 00:05:27,392
One is, it made the buttons as small as it could when you put
一是 stack view 会让你放进去的按钮尽量地小

110
00:05:27,460 --> 00:05:30,028
in the stack. It has 50 point font, remember, for
记得么按钮里那些 emoji 的字号是 50 点

111
00:05:30,097 --> 00:05:32,730
those emojis. So that's just as small as they'll go.
所以这就是能放下这些表情符号的最小尺寸

112
00:05:32,799 --> 00:05:36,434
It also has no spacing between. But I can put spacing
其次它们之间也没有空隙，但是我可以

113
00:05:36,503 --> 00:05:40,638
in-between by just selecting it. It was left selected after
选中它并在给它加上。它现在是保持了我堆到一起后的

114
00:05:40,707 --> 00:05:43,809
I stacked. And going over here to the inspector because this
选中状态。去到这里检查器，因为这个

115
00:05:43,877 --> 00:05:47,145
stack view, just like a button, can be inspected,
UIStackView 就像按钮一样是可以被检查的

116
00:05:47,213 --> 00:05:49,881
right? And you can see it made it horizontal,
你可以看到它自动是 Horizontal，横向堆叠

117
00:05:49,950 --> 00:05:52,617
it kinda noticed my buttons were mostly horizontal. So
它注意到我的按钮大致是以横向分布的，所以

118
00:05:52,686 --> 00:05:57,522
it picked horizontal. And so here's how I set the spacing.
选择了 Horizontal。然后这是我设置间隙的地方

119
00:05:57,590 --> 00:06:00,492
I go down here. I'm gonna use a standard spacing.
我在下面选择标准间距，Use Standard Value

120
00:06:00,560 --> 00:06:03,027
There's a lot of places when you're doing UI design where
当你进行 UI 设计的时候，有很多地方

121
00:06:03,096 --> 00:06:05,463
you can pick an UI standard value and
你可以选择 UI 标准值

122
00:06:05,532 --> 00:06:07,498
it'll pick a standard spacing.
它会选择一个标准间距

123
00:06:07,567 --> 00:06:09,167
This is a standard spacing between buttons.
这就是按钮间的标准间距

124
00:06:09,235 --> 00:06:11,336
And you wanna use that pretty much as much as possible.
你应该尽可能多的使用这个功能

125
00:06:11,404 --> 00:06:14,005
That way, your UI will be spaced like other UI and
以这种方式，你的 UI 将像其他 UI 一样布局

126
00:06:14,074 --> 00:06:17,609
you will feel like we are all on the same page as
这样你就会发现，我们和其他程序的 UI 设计师

127
00:06:17,678 --> 00:06:21,746
UI designers across all these apps. Also I wanna make sure
达成了一种共识。我还想确保

128
00:06:21,814 --> 00:06:26,317
that these four buttons get equal amount of space. Okay,
这四个按钮有着相同的间距

129
00:06:26,386 --> 00:06:29,421
whatever space I am given here gets equally distributed and
无论这里给了多大的空间都能够均匀分布

130
00:06:29,489 --> 00:06:31,322
I do that with this distribution thing here,
我通过这里的分布选项来做这件事

131
00:06:31,391 --> 00:06:36,228
I say fill equally. Alignment just means I fill the whole
我选择均匀填满。Alignment Fill 意味着填满整个

132
00:06:36,296 --> 00:06:38,563
space, I could have these things being centered or
空间，我本可以令这些东西居中或者

133
00:06:38,632 --> 00:06:40,431
kinda pushed up to the top of the stack but
把它们推到栈的顶端

134
00:06:40,500 --> 00:06:42,801
I'm gonna have it fill the whole space. So that's it.
但是我要把它填满整个空间。就这么简单

135
00:06:42,869 --> 00:06:45,503
So I'm just gonna do the same thing with these two rows.
我要对这两行做相同的事情

136
00:06:45,572 --> 00:06:48,373
So this one go down here, embed in stack,
选中这一行，点击下面的嵌入栈中

137
00:06:48,441 --> 00:06:52,210
this group right here embed in stack. Oops,
这里这一组也嵌入栈中。不好

138
00:06:52,279 --> 00:06:56,080
I did it twice there. Now I'm gonna select both of these.
我不小心点了两下。现在我同时选中这两个

139
00:06:56,149 --> 00:07:00,851
Make them fill equally and standard value spacing. So
让它们均匀填满并且标准间距分布

140
00:07:00,920 --> 00:07:04,756
now I've got three horizontal stacks. I'm gonna stack these
现在我得到了三个横向的栈。我要把它们堆叠

141
00:07:04,824 --> 00:07:06,991
together, I'm gonna select them. By the way,
在一起，所以先选中它们。顺便说

142
00:07:07,060 --> 00:07:09,694
dragging to select is really an awesome way to select.
拖拽选中真的是一种很酷的选中方式

143
00:07:09,763 --> 00:07:12,163
I highly recommend you do that rather than trying to click on
我非常推荐你们这样做，而不是尝试点选

144
00:07:12,231 --> 00:07:15,433
things. Because by the way, let's say I try to click on
因为比如说，我尝试点击这里

145
00:07:15,502 --> 00:07:19,370
here to select this row. Oops, I selected the button inside.
来选择这一行。啊哦，我选中了里面的按钮

146
00:07:19,439 --> 00:07:21,940
I didn't want that, I wanted the whole row. But
我并不想这么做，我想要这一整行。但是

147
00:07:22,008 --> 00:07:25,610
if I just drag, not control drag but regular drag here,
如果我只是拖拽，正常的拖拽而不是按住 Control 键来拖拽

148
00:07:25,679 --> 00:07:30,048
it selects the thing that I intercepted with my drag.
它会选中我拖拽截取的东西

149
00:07:30,117 --> 00:07:32,650
Anyway, so I'm gonna select all three of these with drag.
总之，我会通过拖拽选中所有三个栈

150
00:07:32,719 --> 00:07:35,086
And I'm gonna go embed in stack. You put them in
然后嵌入栈中。你把它们

151
00:07:35,155 --> 00:07:37,622
a vertical stack. You notice this time it's vertical,
放到了一个竖向的栈中。你注意到这次它是竖向的

152
00:07:37,691 --> 00:07:39,623
cuz it noticed those three things are vertical.
因为它注意到了这三个东西是竖向的

153
00:07:39,692 --> 00:07:40,925
If your things are random,
如果你的东西是随机分布的

154
00:07:40,994 --> 00:07:43,461
it'll pick the one that it thinks is the most likely.
它会选择一个它认为最可能的方向

155
00:07:43,530 --> 00:07:44,863
You can always change it by going here and
你可以通过 Axis 这里来改变它

156
00:07:44,931 --> 00:07:47,932
changing it to the other one. So we have vertical,
改成另一个。所以我们有了竖向排布

157
00:07:48,001 --> 00:07:51,135
we also wanna fill equally, top to bottom here, and
我们还想要均匀填满，从上到下

158
00:07:51,204 --> 00:07:53,271
we also want standard spacing. So
我们还想要标准间距

159
00:07:53,340 --> 00:07:56,607
it's great. We got our buttons in this nice grid.
这太棒了。我们把按钮放置到了这个很好的栅格中

160
00:07:56,676 --> 00:08:02,046
They're all Perfectly laid out in this rectangle. Now,
它们都完美地布局在了这个矩形中。现在

161
00:08:02,115 --> 00:08:05,483
we want to pin this rectangle to the edges. Okay, so
我们想要把这个矩形固定到边缘上

162
00:08:05,552 --> 00:08:08,820
that when the device rotates, or if the device was bigger,
那样当设备旋转的时候，或者如果设备更大的时候

163
00:08:08,888 --> 00:08:10,388
like if it was an iPhone 8 Plus, or
比如它是一台 iPhone 8 Plus 或者

164
00:08:10,457 --> 00:08:12,223
something like that and it was wider, so
更宽的设备

165
00:08:12,292 --> 00:08:15,026
that it would all just stretch out. So, the way we do
以便它能够伸展开来。所以

166
00:08:15,095 --> 00:08:17,529
that is first I'm going to use those dash blue lines.
我们要做的就是首先，我要利用这些蓝色的虚线

167
00:08:17,598 --> 00:08:21,065
I picked up this thing. Again, picking it up,
我拖拽这个东西。再一次，要拖拽这个整体

168
00:08:21,134 --> 00:08:23,601
you wanna select it first, then pick it up.
你需要先选中它，然后再拖拽

169
00:08:23,669 --> 00:08:26,538
If you don't select it first and try to pick it up, oops,
如果你不先选中它，尝试去拖拽的话，阿哦

170
00:08:26,606 --> 00:08:28,706
you might try and pull one of these things out of there.
你可能把其中一个东西拉出来

171
00:08:28,775 --> 00:08:30,742
Okay? So, be careful about that. All right.
好么？所以，小心一点。好的

172
00:08:30,810 --> 00:08:32,176
So, I'm gonna use the blue lines. I'm gonna
我要利用这些蓝色的线，我要

173
00:08:32,245 --> 00:08:35,013
put this where it kinda suggests for
把它放置到它建议的

174
00:08:35,082 --> 00:08:36,147
the upper left hand corner.
左上角的角落里

175
00:08:36,216 --> 00:08:39,484
You see that? That's pretty much where the blue line,
你看到了它了么？那蓝线所在的地方

176
00:08:39,552 --> 00:08:41,953
that would be the standard spacing from the edges.
就是和边缘有着标准的间距的地方

177
00:08:42,022 --> 00:08:43,387
That's what the blue lines are telling you.
那就是蓝线正告诉你的东西

178
00:08:43,456 --> 00:08:45,857
This is a standard place to put this. Now,
这是放置它的标准位置

179
00:08:45,926 --> 00:08:49,227
I need to pin it and the way we make relationships between
我需要把它固定在这里。我们把 UI 里的视图

180
00:08:49,296 --> 00:08:52,764
views in the UI like pinning them to each other and
关联起来的方式，比如让它们相互固定在一起

181
00:08:52,832 --> 00:08:56,200
stuff is with control drag. Exact same way that we made
是通过按住 Control 键拖拽。和我们将 UI

182
00:08:56,269 --> 00:08:58,202
a relationship between our UI and our code,
和代码关联起来的方式完全一样

183
00:08:58,271 --> 00:09:01,239
by dragging the code, we do the same thing between views.
通过拖拽到代码里，我们也可以在视图间做相同的事情

184
00:09:01,308 --> 00:09:04,675
So, I'm gonna control drag from this already selected
所以，我将要从选中的这里按住 Control 键拖拽

185
00:09:04,744 --> 00:09:09,047
box here to the top. Okay, so I'm just dragging up towards
到顶部。好的，我向上拖拽到顶部

186
00:09:09,115 --> 00:09:11,750
the top, and when I let go it's going to say, okay,
当我松开鼠标的时候，它会问

187
00:09:11,818 --> 00:09:14,619
what relationship do you want between that view and
你想要视图和顶端用什么关系关联

188
00:09:14,687 --> 00:09:17,588
the top. And there's various relationships you can have,
这里有各种关系你可以选择

189
00:09:17,657 --> 00:09:19,090
like I said, in three weeks we're going to have
正如我说过，三周后我们将有

190
00:09:19,159 --> 00:09:21,159
a whole lecture on these relationships, but
一整节课来讨论这些关系

191
00:09:21,227 --> 00:09:24,962
at the very top is the one Top Space to Safe Area.
在最顶部的是 Top Space to Safe Area

192
00:09:25,031 --> 00:09:28,132
You see that Top Space to Space Area? The safe area
你看到它了么？Safe Area（安全区域）

193
00:09:28,201 --> 00:09:31,336
is a safe edge around the screen where you can
是一个安全的屏幕边缘，在那里你可以

194
00:09:31,405 --> 00:09:34,639
safely draw without overlapping some other UI.
安全地绘制内容而不和其他 UI 重叠

195
00:09:34,707 --> 00:09:37,241
So, here it's putting it right under the place where all
所以，在这里把它放在了所有的摄像头

196
00:09:37,310 --> 00:09:40,578
the cameras and face recognition stuff is all in
面部识别模块等所有东西的下方

197
00:09:40,647 --> 00:09:44,883
here. So, it's to keeping it below that. Now, if I had
所以，它是为避免被那些东西遮挡。如果我有

198
00:09:44,951 --> 00:09:47,752
other UI on this, like tab bars, or title bars, or
其他 UI 在上面，比如 tab bar 或者 title bar

199
00:09:47,820 --> 00:09:51,455
whatever, then the safety area would be inside those. So,
或其他任意东西，那么安全区域会在他们内部

200
00:09:51,524 --> 00:09:54,325
we wouldn't overlap our titles and stuff. It's really cool.
所以我们不会和标题或其他东西重叠。这是非常棒的

201
00:09:54,394 --> 00:10:00,264
So, I'm gonna put this top space little pin, so
这样我们就把它固定到了屏幕顶部

202
00:10:00,333 --> 00:10:03,501
I'm kinda connected it and you can see this blue line appears
我把它连接了起来，你可以看到蓝色的线出现在

203
00:10:03,570 --> 00:10:07,371
right here. Okay? This blue line here, long blue line.
这里，好么？这里的蓝色的线，这条长长的蓝色的线

204
00:10:07,440 --> 00:10:11,375
It represents that pinning and I can even click on it. Okay,
它代表着那个关系，我甚至可以点击它

205
00:10:11,444 --> 00:10:14,045
and when I click on it, look, it's inspectable in the top
当我点击它的时候，它变成了可被检查的

206
00:10:14,113 --> 00:10:17,248
half here. Okay? And it's just telling me that I'm pinned
在这上半部分。好么？它就是告诉我

207
00:10:17,317 --> 00:10:20,284
from the safe area top to the top of that stack view. And
栈视图的顶端固定到了安全区域的顶端

208
00:10:20,353 --> 00:10:23,321
we're zero points away from it.
它们的之间的距离是 0 点

209
00:10:23,389 --> 00:10:25,824
We wanna be right up against that safe edge.
我们就在安全区域的边缘上

210
00:10:25,892 --> 00:10:28,058
That's where the blue dashed lines told me to put it, so
那里就是蓝色的虚线告诉我放置的地方，所以

211
00:10:28,127 --> 00:10:30,661
that's where I'm gonna put it. Now, we can do the same thing
我就放置到了那里。现在我们可以对

212
00:10:30,730 --> 00:10:34,032
to the left edge over here, so I'm gonna control drag over.
左边缘做相同的事情，按住 Control 拖到那里

213
00:10:34,101 --> 00:10:37,001
This time it says, Leading Space to Safe Area.
这次它写着，到安全区域的前导间距

214
00:10:37,069 --> 00:10:40,872
Now, why do you think that says leading instead of left?
现在，你认为为什么它写的是前而不是左呢？

215
00:10:40,941 --> 00:10:45,743
Anyone wanna guess? It says leading instead of left,
有人想猜猜么？它写的是前而不是左

216
00:10:45,812 --> 00:10:50,081
because some languages Hebrew, Arabic, they go right to
因为一些语言，比如希伯来语，阿拉伯语，它们是从右

217
00:10:50,150 --> 00:10:53,117
left. The letters come from the right, and they flow
向左排列的。字母从右边来

218
00:10:53,186 --> 00:10:55,820
out towards the left. In those cases, you want pretty much
流向左边。在那些例子里，你基本就是想要

219
00:10:55,889 --> 00:10:58,656
your whole UI flipped over. So, you would want these
你的整个 UI 翻转过来。所以你会想要

220
00:10:58,725 --> 00:11:01,259
buttons pinned to the other side, because the text on
这些按钮固定到另一边，因为按钮上的

221
00:11:01,328 --> 00:11:03,761
the buttons is gonna be coming from the right. Okay?
文字是从右向左的，好么？

222
00:11:03,830 --> 00:11:05,830
Now, it doesn't matter with our emojis, but
现在，对于 emoji 来说并不重要，但是

223
00:11:05,898 --> 00:11:08,332
that's why we do leading and trailing instead of left and
这是为什么我们使用前导和后导而不是左和右

224
00:11:08,401 --> 00:11:11,435
right. Okay? So, I'm gonna click this Leading Space to
的原因。好么？所以，我要点击这里的 Leading Space to

225
00:11:11,504 --> 00:11:14,405
Safe Area right here. Connect it, I get another little blue
Safe Area。连接它，在这里我得到了另一个小的蓝色的

226
00:11:14,474 --> 00:11:17,141
thing right here. You see this one? If I click on it,
东西。你看到这个了么？如果我点击它

227
00:11:17,210 --> 00:11:19,143
it looks like a little I-beam,
它看起来就像一个“工”字

228
00:11:19,212 --> 00:11:22,947
it's pinning these 2 and it's pinned it with 16 points.
它正关联着这两个，并且间距是 16 点

229
00:11:23,016 --> 00:11:25,950
You see 16 points, evidently the blue lines think from
你看这是 16 点的距离。显然这些蓝色的线认为

230
00:11:26,019 --> 00:11:28,986
the left edge, or the leading edge you want 16 points.
到左，或者前导边缘的距离，你想要的是 16 点

231
00:11:29,055 --> 00:11:31,489
Okay, I'll take that. And then, of course,
好的，我会采用它。之后，当然

232
00:11:31,557 --> 00:11:36,026
I could pin to the other side. Ctrl+drag over here.
我能够固定到另一边。按 Ctrl 拖拽到这里

233
00:11:36,095 --> 00:11:39,397
And now, here I didn't use the blue line for that edge.
现在，在这里我没有利用蓝线来处理这个边缘

234
00:11:39,466 --> 00:11:42,634
So, here if I say trailing space to safe area.
如果我选择到安全区域的后导间距

235
00:11:42,702 --> 00:11:44,635
I get an I-beam, this huge, okay.
我得到了这个工字，但却非常的长

236
00:11:44,704 --> 00:11:46,537
So, it goes all the way across like that.
几乎穿过了整个屏幕

237
00:11:46,606 --> 00:11:50,241
And I don't want that, I want it to be the same as the other
但是我不想要这样子，我要它和其他边一样

238
00:11:50,310 --> 00:11:53,444
side, 16 points. So, in my inspector right here,
16 点。所以在这里的检查器

239
00:11:53,513 --> 00:11:56,681
this distance is this constant right here, 215 points.
这段距离，就是这里的 Constant 215 点

240
00:11:56,749 --> 00:11:58,882
So, I'm gonna change that to be 16,
所以我要把它改成 16

241
00:11:58,951 --> 00:12:02,219
so it matches the other side. Oh, and look what happened, it
所以它会和另一边匹配。噢，看发生了什么

242
00:12:02,288 --> 00:12:06,223
pinned the edge of my buttons and they spread out, equally,
它固定了按钮的边缘，然后等距离伸展开来

243
00:12:06,292 --> 00:12:09,727
filling equally, because we told we want to fill equally.
均匀填充起来，因为我们说过我们想要均匀的填满

244
00:12:09,796 --> 00:12:13,664
Okay, so that's pretty cool, now we have the bottom.
好的，这是非常酷的。现在我还剩下底部

245
00:12:13,733 --> 00:12:16,467
So, the bottom is a little trickier, because we've got
处理底部要麻烦一些，因为我们

246
00:12:16,536 --> 00:12:20,771
flips down here. So, we want flips to be on the bottom, and
在底部有 Flips 标签。所以我们想要 Flips 处于底部并且

247
00:12:20,840 --> 00:12:23,874
we want this thing to be above flips. So,
让这些按钮在 Flips 上方。所以

248
00:12:23,943 --> 00:12:26,310
let's work on flips first, let's just get it, so
让我们先处理 Flips，好让

249
00:12:26,379 --> 00:12:28,947
that flips is on the bottom and we're gonna do exact same
Flips 位于底部。我们要做的是一样的

250
00:12:29,015 --> 00:12:31,549
thing. So, I'm gonna grab flips and use the blue lines,
所以我要拖拽 Flips，然后利用这些蓝色的线

251
00:12:31,618 --> 00:12:33,517
okay, put it in the center on the bottom.
把它放到底部的中央

252
00:12:33,586 --> 00:12:36,520
And then a controlled drag to the bottom,
然后按住 Ctrl 键拖拽到底部

253
00:12:36,589 --> 00:12:40,658
and say that I want the bottom space to be pinned to the safe
选择固定到安全区域的底部间距

254
00:12:40,726 --> 00:12:44,962
area. So, that's good. Now, when I did that,
所以，那是好的。现在，当我完成后

255
00:12:45,031 --> 00:12:47,632
look I got this yellow and red lines and
看我得到了这条黄色和红色的线

256
00:12:47,701 --> 00:12:50,434
I got a warning up here. See a warning this warning,
并且在这里我得到了一个警告。看这个警告

257
00:12:50,503 --> 00:12:53,037
this means there is a warning and it can be red if you have
它意味着这里有一个警告，并且如果你有一个错误，它会是红色的

258
00:12:53,106 --> 00:12:56,140
an error. And if you click on it it will tell you what all
并且如果你点击它，它会告诉你

259
00:12:56,209 --> 00:12:59,210
your warnings are kind of a quick summary there, and
那些警告是什么，有一点像一个概要

260
00:12:59,278 --> 00:13:02,179
here it says horizontal position is ambiguous for
这里它写到 Flip Count Label 的

261
00:13:02,248 --> 00:13:06,183
your flip count label. In fact, it is ambiguous.
横向位置是模棱两可的。事实上，它是不确定的

262
00:13:06,252 --> 00:13:08,052
I never told it where it horizontally,
我从没告诉过它在横向要位于哪里

263
00:13:08,121 --> 00:13:09,587
I pinned it to the bottom, but
我把它固定在了底部，但是

264
00:13:09,656 --> 00:13:11,322
I didn't say it was in the middle, or left, or
我没有告诉它是处于中央，还是左边，还是

265
00:13:11,390 --> 00:13:14,625
right. Now I dragged it there with a blue lines, but
右边。我也没有用蓝色的线拖拽它

266
00:13:14,694 --> 00:13:18,362
just dragging with blue lines, just put there, it doesn't pin it there. So
但这样只会把它放在哪里，并不会固定

267
00:13:18,431 --> 00:13:19,897
really what I want with flips is,
所以我真正想要 Flips

268
00:13:19,966 --> 00:13:22,599
I want it to be in the center. Okay, I want it to be in
我想要它位于中央。好的，我想要它位于

269
00:13:22,668 --> 00:13:24,134
center. Just to show you something a little different.
中央。恰好给你们展示一些不一样的东西

270
00:13:24,203 --> 00:13:27,738
And to do that, again, I Control+drag from flips right
为了做这件事，再一次的，我按住 Ctrl 键拖拽 Flips 标签到

271
00:13:27,807 --> 00:13:30,808
here, to the thing I wanted to be in the center of,
这里，我想要它位于其中心的东西

272
00:13:30,876 --> 00:13:33,144
which is this background here. So,
即这里的背景

273
00:13:33,212 --> 00:13:35,112
I'm just gonna Control+drag to the background. And
所以我按住 Control 键拖拽到背景

274
00:13:35,181 --> 00:13:39,750
another option is center this horizontally in the safe area.
另一个选项是在安全区域横向居中

275
00:13:39,819 --> 00:13:44,621
So, I'm gonna do that. Now, it, it puts it in the middle.
所以我要这么做。现在，它居中了

276
00:13:44,690 --> 00:13:47,758
It's still yellow here. So, what does this yellow say?
但它仍是黄色的。所以，这个黄色警告说了什么？

277
00:13:47,827 --> 00:13:50,727
It says the frame for the Flip Count Label will be different
它说这个 Flip Count Label 的 frame

278
00:13:50,796 --> 00:13:55,332
at run time. That's, because I have not constrained the size
在运行时将会不同。那是因为我还没有为标签的尺寸

279
00:13:55,401 --> 00:13:58,168
of this Flip Count Label. I've let it be any size it wants.
添加约束。我让它可以是它想要的任意尺寸

280
00:13:58,237 --> 00:13:59,536
And since it can be any size it wants,
正因为这样子

281
00:13:59,605 --> 00:14:02,206
it's gonna want to be its natural size,
它将想变成它的自然尺寸

282
00:14:02,274 --> 00:14:03,841
whatever size fits it.
能显示所有文字的大小

283
00:14:03,910 --> 00:14:07,211
Now, I can fix this warning down here in this button right
现在，我能够在这里这个按钮，解决这个警告

284
00:14:07,280 --> 00:14:09,813
here. This is where all your constraints.
这里是你所有的约束所在的地方

285
00:14:09,882 --> 00:14:12,984
All this pinning things to edges is called constraints
所有这些把东西固定到边缘的东西叫做约束

286
00:14:13,052 --> 00:14:15,686
we're constraining these views to be in a certain place,
我们将要约束这些视图到一个具体的位置

287
00:14:15,755 --> 00:14:18,522
that we can just, um, actually we don't fix it there,
我们能够仅仅，呃...实际上我们不在这里处理

288
00:14:18,591 --> 00:14:20,458
but we're gonna fix that over here.
但是我们要在这里解决

289
00:14:20,526 --> 00:14:23,627
So, remember, our document outline that we had over here
所以记得，我们这里的的文件大纲

290
00:14:23,696 --> 00:14:26,464
this little thing we hide. If you unhide that and
这个我们隐藏的小东西。如果你取消隐藏

291
00:14:26,533 --> 00:14:29,500
look in the upper right, if there are any of these little
并且向右上方看，如果这里有任何的警告

292
00:14:29,569 --> 00:14:32,436
warnings you have this little button, if you click on it,
你会得到这个按钮。如果你点击它

293
00:14:32,505 --> 00:14:34,338
it will tell you all the problems. So,
它会告诉你所有的问题。所以

294
00:14:34,407 --> 00:14:39,310
this one is a misplaced view, cuz this flip is too big. For
它是一个错误放置的视图，因为这个 Flips 标签太大了

295
00:14:39,379 --> 00:14:41,345
what it should be. So, again, if you click on this little
相比自然尺寸而言的话。所以，如果你点击这个

296
00:14:41,414 --> 00:14:44,715
triangle, it'll offer, hey, you wanna fix this? And
三角形，它会提供给你，嘿，你想要解决这个问题？

297
00:14:44,784 --> 00:14:47,051
you can fix it by updating the frames, which we want,
你可以通过我们想要的更新 frame 来解决

298
00:14:47,120 --> 00:14:49,653
cuz we don't care what the frame this is, the rectangle
因为我们并不关心它的 frame 是什么

299
00:14:49,722 --> 00:14:51,389
that encloses it. It could be anything as long as it's
无论包含 label 的矩形是什么样的

300
00:14:51,457 --> 00:14:54,058
pinned to the bottom and in the center. And we can
只要固定在底部的中央就好

301
00:14:54,126 --> 00:14:56,160
do other things too, we'll talk about in a couple of weeks.
我们还可以做其他事情，那会在几周后讨论

302
00:14:56,229 --> 00:14:58,129
So, I am just gonna update frame right here fix
所以，我选择 Update frames 来解决

303
00:14:58,198 --> 00:15:01,032
missplacement. Look at moved flips down,
这个错位问题。看它把 Flips 标签向下移动了

304
00:15:01,100 --> 00:15:04,168
it made the frame around it just barely contain it.
令它周围的框架刚好包含着它

305
00:15:04,237 --> 00:15:07,171
Okay, and now they frame around that flip zero is it's
现在围绕在 Flip 标签周围的框架就是

306
00:15:07,240 --> 00:15:10,407
natural size. If I run this and do a hundred flips, so
它的自然尺寸。如果我运行程序并且翻一百张牌的话

307
00:15:10,476 --> 00:15:12,810
that it has to be bigger it will naturally get bigger.
如果它需要变大就能够自然地变大

308
00:15:12,879 --> 00:15:15,079
Because it's size is not constrained.
因为它的尺寸并没有被约束

309
00:15:15,147 --> 00:15:17,482
It's not pinned to anything, only its location. So,
除了位置之外是没有固定的

310
00:15:17,550 --> 00:15:20,818
its size will get as big, or small it needs to to contain
所以它的尺寸会根据它所包含文字的大小

311
00:15:20,887 --> 00:15:23,521
its stuff. And now, we see we have no Auto Layout issues.
来变大或变小。现在我们就没有了自动布局的问题

312
00:15:23,590 --> 00:15:27,591
We have no warning up here, all is well. One last thing we
这里没有了警告，一切都正常。我们需要做的最后一件事是

313
00:15:27,660 --> 00:15:30,661
need to do is the relationship between the top of the flips,
建立 Flips 标签顶部和

314
00:15:30,730 --> 00:15:34,632
and the bottom of this. Now, I could just take this thing up
和按钮底部之间的关系。我可以选中上面的东西

315
00:15:34,701 --> 00:15:38,336
here and control drag between that and the flips, right?,
按住 Control 键拖动到 Flips 标签，对吧？

316
00:15:38,405 --> 00:15:40,837
that's a good idea. And we could, for example,
那是一个好主意。举个例子，我们可以

317
00:15:40,906 --> 00:15:43,875
constrain the vertical spacing between the two, so I'm gonna
为两者间的垂直间距添加约束

318
00:15:43,943 --> 00:15:48,679
click Vertical Spacing, there it is. It's this huge bar.
点击 Vertical Spacing 就可以了。但太长了

319
00:15:48,748 --> 00:15:52,917
I could go over here and change it from 454 to 0, and
我可以去到这里把它从 454 改为 0

320
00:15:52,985 --> 00:15:55,986
use all the space here. But that didn't look very good.
利用这里所有的空间。但是这看起来并不好看

321
00:15:56,055 --> 00:15:58,722
I don't really like tall thin buttons like that.
我不太喜欢像这样子的高高瘦瘦的按钮

322
00:15:58,791 --> 00:16:01,492
So I'm gonna leave this constraint in here. But I'm
所以我会把这个约束保留在这里

323
00:16:01,561 --> 00:16:04,962
gonna change it from equal, where it has to be equal,
不过我要改变它，从原本的关系是等于

324
00:16:05,031 --> 00:16:08,899
to 0 with the flips. Also I probably don't want 0, I want
和 Flips 零距离。可能我也不想要 0，我想要

325
00:16:08,968 --> 00:16:11,936
a standard value here so I'm gonna change to standard value
一个标准值所以我要改成标准值

326
00:16:12,004 --> 00:16:14,605
difference, okay, this, this, this distance.
好的，就是这段距离

327
00:16:14,674 --> 00:16:17,007
And I don't it to be equal, I want it to be greater than or
我不想要它是等于，我想要大于等于

328
00:16:17,076 --> 00:16:19,677
equal. So I just wanna make sure that these things on
我只是想要上方的这些东西

329
00:16:19,746 --> 00:16:23,113
the top are always above the flips, greater than or equal.
总是在 Flips 标签上方，即大于等于

330
00:16:23,182 --> 00:16:25,716
But it doesn't have to be right above it like that. So
但它们没有必要靠的太近

331
00:16:25,785 --> 00:16:28,318
you don't have to always have these constraints be equal.
所以你没有必要总是把这些约束设定为等于

332
00:16:28,387 --> 00:16:31,388
They can be greater than or equal, less than or
它们可以是大于等于，小于等于

333
00:16:31,457 --> 00:16:35,526
equal kind of relative constraints. You see all this?
之类的现对约束。看到了么？

334
00:16:35,594 --> 00:16:37,795
Now, we can run the app and this should all work.
现在，我们可以运行这个程序，它应该可以正常工作

335
00:16:37,864 --> 00:16:40,097
Everything is kind of constrained to each other.
一切都互相约束

336
00:16:40,165 --> 00:16:43,834
We can actually kinda take a look at it here in interface
实际上我们通过 Interface Builder 看一看

337
00:16:43,903 --> 00:16:46,470
builder. Right, remember this button down here that showed
记得按下面这个按钮就会展示

338
00:16:46,538 --> 00:16:49,373
us all these phones? We can say, okay, what's this thing
所有的手机么？我们可以看，它在

339
00:16:49,442 --> 00:16:52,810
gonna look like on an iPhone 8? Here's iPhone 8,
iPhone 8 上看起来怎么样？这里是 iPhone 8

340
00:16:52,879 --> 00:16:55,346
we click on it, and sometimes when it does it,
我们点击它，有时当你点击它的时候

341
00:16:55,415 --> 00:16:58,015
you can kind of zoom in and out to get it to redraw.
你需要稍微放大和缩小来让它重新绘制

342
00:16:58,084 --> 00:17:00,284
So this is what it's gonna look like on iPhone 8.
所以这就是它在 iPhone 8 上看起来的样子

343
00:17:00,353 --> 00:17:03,988
We can look at, back on iPhone X, but rotate it.
我们返回查看在 iPhone X 上的效果，但是旋转它

344
00:17:04,056 --> 00:17:06,557
So here's what it's gonna look like rotated on iPhone X,
这就是它在 iPhone X 旋转下的样子

345
00:17:06,626 --> 00:17:08,960
that looks like that's gonna look okay. So
它看起来还不错

346
00:17:09,028 --> 00:17:11,963
we can kind of preview a little bit what's going on
我们可以在 Interface Builder 中预览

347
00:17:12,031 --> 00:17:13,997
here in interface builder, but there's no substitute for
会显示成什么样子，但并不能代替

348
00:17:14,066 --> 00:17:16,667
running it. So let's just run it on our simulator and
实际运行程序查看。所以让我们在模拟器上运行它

349
00:17:16,736 --> 00:17:19,537
see if it looks like what we expect.
看看它看起来是否和我们期待的一样

350
00:17:21,040 --> 00:17:23,340
Right here it is, app seems to be working. Oh,
这就是了，应用看起来正在运行

351
00:17:23,409 --> 00:17:27,678
let's go make our background black again. So go back here,
让我们把背景再次设为黑色。回到这里

352
00:17:27,746 --> 00:17:32,183
background black, keep our Halloween theme intact.
背景为黑色，复原我们的万圣节主题

353
00:17:35,488 --> 00:17:38,655
Right now here, okay, so this thing is working we can still
就是现在，应用正在运行我们仍然

354
00:17:38,724 --> 00:17:41,458
match things, etc. But now when we rotate,
可以匹配卡片，等等，但是当我们旋转的时候

355
00:17:41,527 --> 00:17:45,496
remember Command+Arrow, look, it re-lays out the entire UI
记得按住 Command 加方向键，看，它重新布局整个 UI

356
00:17:45,565 --> 00:17:48,766
to fit the space. And it's doing this, it's relaying
来适应空间。它之所以在重新布局

357
00:17:48,835 --> 00:17:50,868
it out because of those constraints we put it.
是因为我们放置的那些约束

358
00:17:50,936 --> 00:17:53,337
We constrained this edge to be stuck to here,
我们约束这个边固定到这里

359
00:17:53,405 --> 00:17:55,573
we constrained this edge to be stuck up here.
我们约束这个边固定到这里

360
00:17:55,641 --> 00:17:57,541
We constrained this distance to be
我们约束这段距离

361
00:17:57,610 --> 00:17:59,610
greater than or equal to a standard distance.
大于等于标准距离

362
00:17:59,679 --> 00:18:02,980
We constrained the bottom of this to be a distance down
我们约束它的底部到下面一段距离

363
00:18:03,049 --> 00:18:05,783
here. We constrained the x position of this to be in
我们约束它的横坐标处在中央

364
00:18:05,852 --> 00:18:08,319
the center. We put those constraints on here, and so
我们把这些约束放到这里

365
00:18:08,388 --> 00:18:12,756
that when we flip this thing around, it's living with those
以便当我们旋转手机的时候，它能够和这些

366
00:18:12,825 --> 00:18:18,095
constraints. Got it? So like I said, this is just a teaser
约束友好相处。明白了么？所以正如我说的

367
00:18:18,163 --> 00:18:21,031
of this constraint stuff. It's a very powerful system for
它仅是这些约束的一个预告示例。约束是一个

368
00:18:21,100 --> 00:18:23,768
doing these constraints and we'll talk all about that,
非常强大的系统，正如我说的

369
00:18:23,837 --> 00:18:27,738
like I said, in about three weeks. Okay,
我们会在大约三个星期后详细讨论它

370
00:18:27,806 --> 00:18:30,441
back to the slides. All right, so
回到幻灯片

371
00:18:30,510 --> 00:18:32,876
here's your brief review of week 1, okay,
这里是第一周的一个简单回顾

372
00:18:32,945 --> 00:18:35,846
hyperspeed review. Of course you know about target action,
超快速的回顾。你了解了目标操作

373
00:18:35,914 --> 00:18:38,015
outlet out to out collection, outlet collections.
出口变量，出口变量集合

374
00:18:38,083 --> 00:18:40,651
The card buttons, your flip count label. The touch card,
卡片按钮，你的计数标签，触摸卡片

375
00:18:40,720 --> 00:18:43,454
you know about that. You learned all about methods and
你了解了它们。你学习了方法

376
00:18:43,523 --> 00:18:46,056
properties, what their syntax was for all of those things.
和属性，它们的语法是什么

377
00:18:46,125 --> 00:18:49,794
Properties like flip count and tons of methods all the ones
例如 flipCount 属性，还有

378
00:18:49,862 --> 00:18:53,397
in concentration in card and view controller. You learned
ConcentrationCardViewController 里所有的方法

379
00:18:53,466 --> 00:18:56,367
about property observing right when the flip count changed,
你学习了属性观察，当 flipCount 改变的时候

380
00:18:56,435 --> 00:18:58,902
we have that didSet that would cause the UI to change as
我们有 didSet，它可以导致 UI 也发生变化

381
00:18:58,971 --> 00:19:01,138
well. You obviously learned about arrays,
显然你学习了数组

382
00:19:01,207 --> 00:19:04,041
how to put things in arrays, how to declare an array.
如何把东西放到数组里，如何声明一个数组

383
00:19:04,110 --> 00:19:06,477
You learned a ton about model view controller.
你学会了关于 MVC 的很多知识

384
00:19:06,545 --> 00:19:09,646
We went and made the Concentration game have
我们令翻牌游戏拥有了一个模型

385
00:19:09,715 --> 00:19:12,816
a model like concentration on the card.
像基于 Card 的 Concentration 文件

386
00:19:12,885 --> 00:19:15,986
You learned about value types versus reference types, right?
你学习了值类型和引用类型，对吧？

387
00:19:16,055 --> 00:19:18,655
The card, which is a struct, a value type that gets copied
Card，它是一个结构体，一个值类型，当你把它丢到其他地方

388
00:19:18,724 --> 00:19:21,525
when you throw it around. So when we put them in the array
它会被拷贝。所以当我们把它们放到数组里时

389
00:19:21,594 --> 00:19:23,961
there, we made the copy by just putting it in twice.
我们通过放置两次来完成这次拷贝的操作

390
00:19:24,029 --> 00:19:25,729
And they copied it each time you put it in there,
并且每次你把它放到那里都会拷贝

391
00:19:25,798 --> 00:19:28,265
remember that? You learned about initializers,
记得么？你学习了构造器

392
00:19:28,334 --> 00:19:31,001
we had initializers both for Card
我们添加了构造器到 Card

393
00:19:32,069 --> 00:19:32,469
and for Concentration
和 Concentration

394
00:19:32,470 --> 00:19:33,870
they each did different things to get
它们每个都做了不同的事情来

395
00:19:33,940 --> 00:19:36,741
themselves an initializer. We didn't do initializer for
让自己被初始化。我们并没有给 UIViewController 实现构造器

396
00:19:36,809 --> 00:19:40,278
our UI view controller and we probably never will.
而且我们大概永远都不会这么做

397
00:19:40,346 --> 00:19:44,548
UI view controllers initialization is messy. Okay,
UIViewController 的构造过程是混乱的

398
00:19:44,617 --> 00:19:47,585
so we try at all possible not to use init for our view
所以我们尝试尽可能地不使用视图控制器

399
00:19:47,653 --> 00:19:50,154
controller. And I explained that in your homework
的 init 方法。我在你们的家庭作业里解释了这件事

400
00:19:50,223 --> 00:19:53,557
that's going out today, you can read about it. You learned
它会在今天发布，你们可以阅读相关内容。你们学习了

401
00:19:53,625 --> 00:19:56,327
about static methods like get unique identifier, static
关于静态方法的知识，比如获取唯一识别码的方法，还有静态

402
00:19:56,395 --> 00:19:58,829
vars like the identifier factory that we've created
变量，比如我们创建的识别码工厂

403
00:19:58,898 --> 00:20:01,698
there. You learned about lazy properties like game, which
你们学习了惰性属性，比如 game 变量

404
00:20:01,767 --> 00:20:05,736
depended on another property, and so it couldn't initialize.
它依赖于另一个属性，所以它不能被初始化

405
00:20:05,804 --> 00:20:07,838
We just made it lazy so that it wouldn't actually
我们通过懒加载它，所以

406
00:20:07,907 --> 00:20:09,606
initialize until someone asked for it,
直到需要的时候才会被初始化

407
00:20:09,675 --> 00:20:12,776
which would of course be after the thing is all initialized.
当然这只可能在实例初始化之后才会发生

408
00:20:12,845 --> 00:20:15,946
You learned about for in loops, which in Swift only
你们学习了 for 循环，它在 Swift 中

409
00:20:16,015 --> 00:20:19,183
work by iterating over what's called a sequence.
只能用来迭代序列

410
00:20:19,252 --> 00:20:21,852
And we learned that countable range is a sequence, right?
我们学习的 CountableRange 是一个序列，对吧？

411
00:20:21,921 --> 00:20:24,421
0..< than whatever is a countable range,
0..< 是一个 CountableRange

412
00:20:24,490 --> 00:20:26,923
that's a sequence. But also array is a sequence,
它是一个序列。而且数组也是一个序列

413
00:20:26,992 --> 00:20:28,893
and string is a sequence of characters.
String 是字符的序列

414
00:20:28,961 --> 00:20:31,862
A lot of things are sequences, you can for in over them.
很多事物都是序列，你可以对它们进行 for 循环

415
00:20:31,931 --> 00:20:34,464
We're gonna talk about what it means to be a sequence
之后我们将会讨论成为一个序列意味着什么

416
00:20:34,533 --> 00:20:37,734
little later, probably on Wednesday. You learned about
大概是在周三。你们学习了

417
00:20:37,803 --> 00:20:40,637
dictionary. Of course our emoji were in a dictionary.
字典，当然我们的 emoji 是在一个字典里

418
00:20:40,706 --> 00:20:41,839
We learned about type conversion.
我们学习了类型转换

419
00:20:41,908 --> 00:20:45,342
We convert types by creating a new thing. And using an init
我们通过创建一个新的事物来转换类型。比如

420
00:20:45,411 --> 00:20:49,480
with the old thing like uint 32 of an int makes a uint,
通过一个 UInt32 的 init 方法，那么这个 UInt32

421
00:20:49,548 --> 00:20:53,016
convert into a uint 32. And of course, you learned a lot
就是一个 Int 转变而来的。 当然，你们学习了很多

422
00:20:53,085 --> 00:20:55,852
about optionals which I'm sure are all still new to you and
关于可选类型，只是我确定它对你们来说还十分陌生

423
00:20:55,921 --> 00:20:58,522
I'm gonna talk a lot today about optionals and how they
我会在今天讨论很多关于可选类型的内容，它们是如何

424
00:20:58,591 --> 00:21:01,058
really work. And what's really going on with optionals, okay?
工作的，到底发生了什么，好么？

425
00:21:01,126 --> 00:21:02,759
So that's your review of week one.
这就是你们第一周的回顾

426
00:21:02,828 --> 00:21:04,995
If for some of these, if you don't feel like you understand
如果你感到你还没明白这些内容

427
00:21:05,063 --> 00:21:08,799
these, probably haven't done your homework yet, then you
你可能还没有做完家庭作业

428
00:21:08,868 --> 00:21:11,402
won't understand this, very important. Okay, the first two
所以你不理解它。都是非常重要的。好的

429
00:21:11,470 --> 00:21:13,804
things I'm gonna talk about here are just a little quick
首先，我要讨论的两个事情

430
00:21:13,873 --> 00:21:17,741
minor things, asides. I mentioned doing a for
小事。我提到过用浮点数

431
00:21:17,810 --> 00:21:22,279
loop over floats. So this for i = 0.5, i < 15.25 whatever,
做 for 循环。比如 for i = 0.5; i < 15.25

432
00:21:22,348 --> 00:21:26,083
that's something you might see in C. You can't do that
这是你可能会在 C 语言中看到的东西，你不可以

433
00:21:26,151 --> 00:21:28,919
in Swift, okay? Swift doesn't have, it only has for in,
在 Swift 中这么做，好么？Swift 只有 for in

434
00:21:28,988 --> 00:21:32,589
that's all it has. But how do we create a countable range or
这是它拥有的全部。但是我们该如何创建一个 CountableRange 或者

435
00:21:32,658 --> 00:21:36,026
some kind of sequence of those floats because 0.5...15.25,
类似的浮点数序列？因为 0.5...15.25

436
00:21:36,094 --> 00:21:40,163
that's actually legal to say, but
事实上这么说是合法的，但是

437
00:21:40,232 --> 00:21:44,134
that's only a range in Swift not a countable range. And
在 Swift 中它只是一个 Range 而不是 CountableRange

438
00:21:44,203 --> 00:21:47,071
that's because we don't know what to count by there,
这是因为我们不知道间隔数是多少

439
00:21:47,140 --> 00:21:49,739
so it can't create a countable range. So
所以它没办法创建一个 CountableRange

440
00:21:49,808 --> 00:21:52,977
the way we do that is using a global function called stride.
我们实现它的方法就是使用一个叫做 stride 的全局函数

441
00:21:54,547 --> 00:21:58,114
Stride has form, through or from and
stride 有 from:through: 或者 from:to:

442
00:21:58,183 --> 00:22:00,784
to depending on whether you are gonna include the last
两种形式，取决于是否要包含区间的上限

443
00:22:00,852 --> 00:22:04,588
thing, and a by tells you what it strides by. Stride is
最后一个 by 告诉你每一步的跨度是多少。stride

444
00:22:04,656 --> 00:22:08,492
function that creates a countable range. Countable
是一个创建 CountableRange 的函数

445
00:22:08,561 --> 00:22:11,461
range is a generic type like array is a generic type.
CountableRange 是一个泛型，正如数组是一个泛型

446
00:22:11,530 --> 00:22:13,296
It can count over not just ints,
它不仅能够在整数间计数

447
00:22:13,365 --> 00:22:15,932
it could count over floats, it could even count over indexes
还能够计数浮点数，它甚至可以计数

448
00:22:16,001 --> 00:22:18,535
into a string, all kinds of things it can count over.
字符串的索引，所有种类的事物它都可以计数

449
00:22:18,604 --> 00:22:22,172
And this stride knows how to create a countable range,
stride 了解如何创建一个 CountableRange

450
00:22:22,241 --> 00:22:25,476
in this case a closed countable range because I did
在这个例子里是一个 ClosedCountableRange 因为

451
00:22:25,545 --> 00:22:28,345
through 15.25, not to 15.25.
我写的是 through: 15.25 而不是 to: 15.25

452
00:22:28,414 --> 00:22:31,581
It creates one that goes over floats and knows to step by
它创建了一个浮点数闭区间，以 0.3 为跨度

453
00:22:31,650 --> 00:22:34,951
three, 0.3 there. So that's how you do floating point.
看这里的 0.3。所以这就是处理浮点数的方法

454
00:22:35,020 --> 00:22:37,020
And you don't have to do that for your homework or anything,
家庭作业里用不到这个

455
00:22:37,089 --> 00:22:38,555
but I just wanted to be complete about how we do
我只是想要完整的讲述我们该如何处理

456
00:22:38,624 --> 00:22:41,892
a countable range for floats. All right, tuples.
浮点数的 CountableRange。元组

457
00:22:41,961 --> 00:22:45,262
I try to fit everything into Concentration that I can,
我尽力尝试把一切都纳入 Concentration 中去

458
00:22:45,331 --> 00:22:48,332
an example of everything. But I couldn't figure out
一个包含一切的例子，但是我没法想出

459
00:22:48,400 --> 00:22:51,101
how to fit a tuple in even though tuple is a very simple
如何把元组融入进去，即使元组是一个非常

460
00:22:51,170 --> 00:22:55,572
little data structure. And all that tuple is, essentially,,
简单的数据结构。元组基本上

461
00:22:55,641 --> 00:22:59,943
like a mini struct that has no methods or vars or anything.
就像一个没有方法或变量的迷你结构体

462
00:23:00,012 --> 00:23:04,114
Just has values in it. So it's kind of like struct in other
在里面只有值，所以它有点像其他语言中的结构体

463
00:23:04,183 --> 00:23:06,784
languages, like C structs. They don't have methods or
比如 C 语言结构体。它们没有方法

464
00:23:06,852 --> 00:23:08,719
vars or anything, or they kind of have vars,
变量或其他东西，或者说它们在某种程度上拥有变量

465
00:23:08,788 --> 00:23:10,554
they have the data stores and that's it.
它们有储存的数据，但也就那样了

466
00:23:10,623 --> 00:23:12,956
So but the tuple is super lightweight and
但是元组是非常轻量的

467
00:23:13,025 --> 00:23:15,392
you kinda define everything in line.
所有的都能在一行里定义

468
00:23:15,461 --> 00:23:19,296
So here's what a tuple looks like. Here's a tuple x. x,
这是一个元组看起来的样子。这是一个元组 x

469
00:23:19,365 --> 00:23:23,734
is up here, is of type tuple. And this tuple has three
x 的类型是元组。这个元组里有三个

470
00:23:23,802 --> 00:23:26,437
things in it. A string, an int, and a double. And
部分。一个 String，一个 Int，一个 Double

471
00:23:26,505 --> 00:23:29,839
I set its value by just saying equals parentheses,
通过 = (三个值)

472
00:23:29,908 --> 00:23:33,544
the three things, okay, the three values. Now, what's
来给它赋值。关于元组

473
00:23:33,612 --> 00:23:37,214
kinda cool about a tuple, as a lightweight struct kinda
一个轻量的数据结构来说，非常酷的事情是

474
00:23:37,283 --> 00:23:41,451
thing, is that the names of the elements is very flexible.
其元素的名称是可变通的

475
00:23:41,520 --> 00:23:44,855
You can define the names when you get the values, like this,
你能够在当你获得值的时候定义名称，像这样子

476
00:23:44,924 --> 00:23:49,092
let parentheses word number value equal x. And
let (word, number, value) = x

477
00:23:49,161 --> 00:23:52,062
that actually assigns each of the values of x to the three
那就能够把 x 的每个值都赋给了

478
00:23:52,131 --> 00:23:55,833
variables word, number and value. Okay? So I'm kind of
word，number，value 三个变量，好么？

479
00:23:55,901 --> 00:23:59,603
giving these struct elements names as I grab them out, or
有点像当我揪出这些元素的时候给了它们名字

480
00:23:59,672 --> 00:24:02,506
we can do the other way around. When I define x,
或者我们可以用另一种方式来做。当我定义 x 的时候

481
00:24:02,574 --> 00:24:05,042
I can say x is a tuple that has a string and
我可以写 x 这个元组有着 String

482
00:24:05,110 --> 00:24:09,045
Int and double called w i and v. Then,
Int 和 Double，它们分别称为 w、i 和 v

483
00:24:09,114 --> 00:24:13,484
when I have x in my hands, I can get w,
当我使用 x 的时候，我可以通过

484
00:24:13,552 --> 00:24:16,186
i and v with using, using this dot notation,
使用点语法来获得 w、i 和 v 的值

485
00:24:16,255 --> 00:24:20,057
kind of like it's a var almost in a struct, x.w, x.i, x.v.
它有点像是一个结构体中的变量，x.w，x.i，x.v

486
00:24:20,125 --> 00:24:23,026
See, so now I'm declaring the names when I declare
所以我可以在声明变量的时候就选好名称

487
00:24:23,095 --> 00:24:27,131
the thing. But, and even if you do this, you can still
但是即使你这么做，你仍可以

488
00:24:27,199 --> 00:24:29,766
redeclare the names to be something else by saying, let
重新声明这些名字，通过写

489
00:24:29,835 --> 00:24:33,904
word num val = x, it'll crate those three local variables so
let (word, num, val) = x 就会创建三个局部变量

490
00:24:33,972 --> 00:24:37,273
super flexible on the naming of those three things.
所以这三个事物的命名是可以变通的

491
00:24:37,342 --> 00:24:39,943
Usually when we crate a tuple we want to use the second way
通常当我们创建一个元组的时候，我们想要用第二种方法

492
00:24:40,012 --> 00:24:43,146
the x : i : v way although we probably would not use x,
x: i: v:，即使我们可能不会使用 x

493
00:24:43,215 --> 00:24:45,615
i and v those are terrible names that is just my
i 和 v，这些是糟糕的名字，那是因为

494
00:24:45,684 --> 00:24:47,350
slide only has so much space.
我的幻灯片横向的只有这么多空间

495
00:24:47,419 --> 00:24:49,386
Horizontally, probably word, number or
大概 word、number 和 value

496
00:24:49,455 --> 00:24:51,789
value would have been better names. Usually we do that, and
会是更好的名字。通常我们这样做

497
00:24:51,858 --> 00:24:53,457
that's mostly because of documentation,
是为了方便写文档

498
00:24:53,526 --> 00:24:56,226
we want people to know what those three things are. If we
我们想要人们了解那三个东西是什么

499
00:24:56,295 --> 00:24:59,163
just declare it like x at the very top there, string, int,
如果我们仅仅声明它，像上面的那个 x 那样，String，Int

500
00:24:59,231 --> 00:25:01,865
double, people are like, hm, what are those three things?
Double，人们会说，这些东西到底是什么？

501
00:25:01,933 --> 00:25:03,266
So, what's a tuple good for? Well,
所以，元组的优点是什么？

502
00:25:03,335 --> 00:25:06,336
it's good any time you wanna group some stuff together
它适合用来把一些事物组织在一起

503
00:25:06,404 --> 00:25:08,205
that's really lightweight, it doesn't have any methods or
它是非常轻量的，它没有任何方法或者

504
00:25:08,274 --> 00:25:10,974
anything associated with it. It's also very good for
关联的东西。同时它对于

505
00:25:11,042 --> 00:25:14,945
returning multiple values from a function. A function of
返回多个值的函数来说也是非常好的

506
00:25:15,014 --> 00:25:17,781
Swift can only return a single thing, but
Swift 的函数只能返回一个单独的事物

507
00:25:17,850 --> 00:25:21,251
that thing could be a tuple, and now you can return as many
但是它可以是一个元组。用元组就可以想返回多少

508
00:25:21,319 --> 00:25:24,821
things as you want, okay? So if I had a function getSize,
就返回多少事物，好么？所以如果我有一个函数 getSize

509
00:25:24,890 --> 00:25:28,158
get's a person's size, their height and their weight.
获得一个人的尺寸：身高和体重

510
00:25:28,227 --> 00:25:32,229
Let's say I can return a tuple with weight and height, and
我可以返回一个包含体重和身高的元组

511
00:25:32,298 --> 00:25:34,898
so when I got it back I just x.weight or
所以当我得到返回值的时候，我只需要 x.weight

512
00:25:34,966 --> 00:25:38,902
even just getSize().weight or getSize().height, access
甚至只需要 getSize().weight 或者 getSize().height

513
00:25:38,970 --> 00:25:42,773
it directly. So that's what tuples, is I didn't make you
直接获取它。所以这就是元组，我没有在你们的

514
00:25:42,841 --> 00:25:45,109
read about it tuple in your first reading assignment but
第一个阅读作业中让你们阅读元组

515
00:25:45,177 --> 00:25:46,376
you'll be reading about it in your next one.
但是你会在下一个作业里阅读它的内容

516
00:25:46,445 --> 00:25:48,178
it's very simple, it's exactly what it seems,
它是非常简单的，它完全是它看起来的样子

517
00:25:48,247 --> 00:25:50,981
there's nothing magical here, there's no hidden things, it's
这里没有魔法，没有隐藏的内容

518
00:25:51,049 --> 00:25:56,120
just a simple little struct, yeah? Sorry? Do they support
它就是一个简单的小结构。抱歉？>> 它们支持索引么？

519
00:25:57,523 --> 00:25:59,589
indexing? Do tuples support indexing, you mean like,
>> 元组支持索引么，你的意思是，像

520
00:25:59,658 --> 00:26:04,194
get thing number 1, or get thing number 2? Not really,
得到第一个元素，第二个元素？并不

521
00:26:04,262 --> 00:26:06,730
and we wouldn't really wanna do it that way. If we really
我们也不想要用这种方式做。如果我们真的

522
00:26:06,798 --> 00:26:09,299
had something we'd index, we'd wanna use an array there,
需要被索引的事物，我们会在那里使用一个数组

523
00:26:09,368 --> 00:26:12,369
because, you know what I'm saying? It would obfuscate
因为，你懂得，它会混淆

524
00:26:12,438 --> 00:26:14,204
what's going on. The whole great thing about tuples,
我们用的究竟是什么。元组美妙的地方在于

525
00:26:14,273 --> 00:26:16,740
you can name each one and let people know what they are, so.
你可以命名每一个元素让人们知道它们是什么，所以你懂的

526
00:26:18,477 --> 00:26:21,111
All right, now, okay, that was it for
好的，这就是那些小知识

527
00:26:21,180 --> 00:26:23,813
little things, now we're back to something very important.
现在我们返回一些非常重要的事情

528
00:26:23,882 --> 00:26:27,651
This is a big thing. This is computed properties.
这是一个重要的事情：计算属性

529
00:26:27,720 --> 00:26:30,888
So all the properties that you saw in Concentration,
你在 Concentration 中看到的所有属性

530
00:26:30,956 --> 00:26:34,057
were stored properties. They were just normal vars
都是存储属性。它们就是正常的变量

531
00:26:34,126 --> 00:26:36,126
like you're used to in another languages, right?
就像你在其他语言中用的那些一样，好么？

532
00:26:36,195 --> 00:26:39,429
Like this var foo: Double, that's a double precision
像这个变量 foo: Double，它是一个双精度

533
00:26:39,498 --> 00:26:42,332
floating point number, and it's just stored in memory.
浮点数，它只是储存在内存中

534
00:26:42,400 --> 00:26:45,536
It's stored with whatever struct or class it's part of.
它储存在任何它属于的结构体或类里面

535
00:26:45,604 --> 00:26:48,405
But it is possible to declare foo like this,
但是也可以像这样子声明 foo

536
00:26:48,474 --> 00:26:53,410
foo Double open curly brace, get with the curly brace, set,
for: Double { get {}

537
00:26:53,478 --> 00:26:55,445
with some curly brace
set {} }

538
00:26:55,514 --> 00:26:59,316
In that case, foo is never stored anywhere, instead,
在这个例子中，foo 从没有被储存，相反

539
00:26:59,385 --> 00:27:00,751
every time someone asks for
每次人们请求 foo 的时候

540
00:27:00,820 --> 00:27:05,255
foo, it gets calculated with the code inside get. And
它被 get 中的代码所计算

541
00:27:05,324 --> 00:27:07,624
every time someone sets the value of foo,
每次人们设置 foo 的值

542
00:27:07,692 --> 00:27:13,196
this code that's in here inside set gets executed.
在 set 里面的代码得到执行

543
00:27:13,265 --> 00:27:14,531
Okay, so I got a little pointer here. So
好的，我现在用这个小的指示器

544
00:27:14,600 --> 00:27:17,801
this code gets executed when you set, this code up here
当你设置 foo 的值时，这行代码得到执行。上面

545
00:27:17,870 --> 00:27:21,070
gets executed when you get. Instead of it being stored
这行代码当你获取 foo 的值时执行，而不是被储存

546
00:27:21,139 --> 00:27:25,942
somewhere. Now, the set by the way, that set(newValue) part,
在某个地方。顺便说一下，set(newValue) 部分

547
00:27:26,011 --> 00:27:28,478
that's optional. So you can have computed properties
不是必须的。所以你可以拥有只有 get 部分的

548
00:27:28,547 --> 00:27:32,215
that are only get, call those read only computed properties.
计算属性，我们称之为只读计算属性

549
00:27:32,284 --> 00:27:34,618
You can't have ones that are only set,
你无法拥有只有 set 的计算属性

550
00:27:34,687 --> 00:27:36,920
you can have get only but not set only.
你可以只拥有 get 但不能只拥有 set

551
00:27:36,988 --> 00:27:40,523
If you have set only make a function set whatever.
如果你要只拥有 set，那就做成一个 setXXX 方法

552
00:27:40,592 --> 00:27:44,894
You wouldn't use a var like that. Okay, so why a computed
你不会像那样子使用一个变量。所以为什么计算属性

553
00:27:44,963 --> 00:27:49,065
properties important? What do you use them for?
如此重要？我们用它来做什么？

554
00:27:49,134 --> 00:27:51,835
Well, a lot of times you have something that is perceived as
很多时候，你有一些东西被看作

555
00:27:51,904 --> 00:27:56,940
a property of your struct or class that actually is derived
结构体或者类的属性，但其实

556
00:27:57,008 --> 00:28:00,510
from other state inside of your struct. And when you have
基于其他状态演变而来的。这时

557
00:28:00,578 --> 00:28:03,313
that situation, you do not want to have a stored property
你不希望拥有一个存储属性

558
00:28:03,382 --> 00:28:04,881
because you don't want to have the same
因为你不想在两个不同的变量里

559
00:28:04,950 --> 00:28:09,886
information in two different vars. Because they can get
储存着相同的信息。因为它们会

560
00:28:09,955 --> 00:28:11,755
out of sync, all kinds of problems happens, so
失去同步，还有各种各样的问题发生

561
00:28:11,824 --> 00:28:14,257
you one way or the other wants to derive itself
你的某一个变量会想从另一个中推导出自身

562
00:28:14,326 --> 00:28:17,761
from the other one. Here's an incredibly good example
这里是一个非常好的例子

563
00:28:17,829 --> 00:28:21,765
indexOfOneAndOnlyFaceUpCard in concentration.
Concentration 中的 indexOfOneAndOnlyFaceUpCard

564
00:28:21,833 --> 00:28:26,736
That is easily derived by looking at the cards. So
它可以轻松的通过观察卡片得到

565
00:28:26,805 --> 00:28:30,373
you really, we'll really kind of bad to have made that
所以让它成为一个寄存属性对我们来说是不太好的

566
00:28:30,442 --> 00:28:33,143
a stored property, becauase we have to keep that thing
因为我们不得不保持它完全

567
00:28:33,211 --> 00:28:37,146
exactly in sync with the face up state of all the cards.
与所有卡片正面朝上的状态同步

568
00:28:37,215 --> 00:28:41,184
That's really error prone way to design. So, we could
那是一个非常糟糕的设计方式。所以我们可以试着

569
00:28:41,253 --> 00:28:44,654
imagine doing, implementing indexOfOneAndOnlyFaceUpCard as
想象实现 indexOfOneAndOnlyFaceUpCard

570
00:28:44,723 --> 00:28:45,822
computed property
为计算属性

571
00:28:45,891 --> 00:28:48,591
with the get just looks at all the cards. And if you'll
它的 get 只需要查看所有的卡片。如果你

572
00:28:48,660 --> 00:28:51,862
only find one FaceUpCard it returns that index, otherwise
只发现一张正面向上的卡片，就返回那个索引，否则

573
00:28:51,930 --> 00:28:56,332
it it returns nil. And the set just looked to that index,
它返回 nil。set 只需要查看那个索引

574
00:28:56,401 --> 00:28:59,035
make sure that card face up and all the rest will face
确认那张卡片为正面朝上而其他卡片正面朝下

575
00:28:59,104 --> 00:29:03,940
down, you see? So, we're just using this computed property
看到了么？本质上我们正使用这个计算属性

576
00:29:04,009 --> 00:29:07,678
to essentially provide this conceptual property,
来提供这个只是概念上的属性

577
00:29:07,747 --> 00:29:09,546
which is the indexOfOneAndOnlyFaceUpCard,
也就是唯一向上的卡片的索引

578
00:29:09,615 --> 00:29:11,982
that is the property of our game, but
它是我们游戏的一个属性

579
00:29:12,050 --> 00:29:14,885
it's computed from the other one. Everyone get what
但是它从另一个属性演算而来。所有人都

580
00:29:14,953 --> 00:29:18,354
I'm saying there? Okay, so let's go to Concentration and
理解我在说什么么？好的，让我们去到 Concentration

581
00:29:18,423 --> 00:29:20,290
make this change, see what this would look like
进行这个修改，看看如果使用一个计算属性的话

582
00:29:20,358 --> 00:29:22,426
if you used a computed property here like we
它会是什么样子，好么？

583
00:29:22,495 --> 00:29:25,228
should've in the first place, all right?
起初我们本应就这么做

584
00:29:25,297 --> 00:29:30,700
So let's go back here to Xcode,
我们回到 Xcode

585
00:29:30,769 --> 00:29:33,971
here we go bring our code back up, get rid of that.
把我们的代码拿回来，隐藏这个

586
00:29:34,039 --> 00:29:38,208
Let's go, oops, let's go to concentration, that's where
让我们去到 Concentration，我们代码所在

587
00:29:38,277 --> 00:29:41,811
this is all right? So everyone recognize this code, right?
的地方，好么？大家都还认得到这些代码么？

588
00:29:41,880 --> 00:29:43,680
This is our entire concentration,
这是我们完整的 Concentration

589
00:29:43,748 --> 00:29:45,882
pretty efficient code as is but it's actually gonna look
已经是足够有效率的代码了，但是它会看起来更好

590
00:29:45,951 --> 00:29:49,586
even better once we do this as you'll see. So we're here,
一旦我们实现这个功能，你马上就会看到

591
00:29:49,655 --> 00:29:51,354
we have index of one and only FaceUpCard. So
我们有 indexOfOneAndOnyFaceUpCard

592
00:29:51,423 --> 00:29:54,557
I'm gonna make it computed by putting these curly braces in,
我要把它写成计算属性，通过放置这些大括号

593
00:29:54,626 --> 00:29:57,827
as soon as I do that, now it's a computed property. Actually,
我一完成它，它就变成了一个计算属性

594
00:29:57,896 --> 00:30:00,330
before we do that, let me show you even simpler case of this
事实上，在我们做之前，让我给你们展示一个更简单的例子

595
00:30:00,399 --> 00:30:04,401
just to kinda get you warmed up on computed property.
仅仅是让你们熟悉一下计算属性

596
00:30:04,469 --> 00:30:07,804
Sometimes, you have just a simple calculation like this.
有时候，你有一个像这样子的简单计算

597
00:30:07,873 --> 00:30:11,040
The number of pairs of cards which are calculated from
numberOfPairsOfCard，它由 cardButtons

598
00:30:11,109 --> 00:30:14,444
the card buttons, all right? There might be other times
计算出来。可能在我们的 ViewController 里还有其他时候

599
00:30:14,513 --> 00:30:17,013
inside our view controller, we wanna know this number,
我们想要知道这个数字

600
00:30:17,082 --> 00:30:19,949
how many pairs of cards do we have. So
我们拥有多少对卡片。所以

601
00:30:20,018 --> 00:30:23,787
that's kind of a property and is derived from this data. So
它是一种属性，并且通过这个数据推导出来

602
00:30:23,856 --> 00:30:25,789
I'm gonna take this out of here and
所以我要把它拿出来而且

603
00:30:25,857 --> 00:30:30,127
have number of pairs of cards be a property.
把 numberOfPairsOfCard 写成一个属性

604
00:30:30,195 --> 00:30:35,766
It's gonna be a new var numberOfPairsOfCards, and
它会是一个新的变量 numberOfPairsOfCard

605
00:30:35,834 --> 00:30:39,870
it's gonna be of type Int, and it's gonna be computed, so
它的类型是 Int，它是一个计算属性

606
00:30:39,938 --> 00:30:43,339
I'm gonna have a get. It's gonna be read only, so
我会拥有一个 get，它会是只读的，所以

607
00:30:43,408 --> 00:30:45,976
I'm gonna return this. It's not gonna have a set,
我会返回这个，它不会有一个 set

608
00:30:46,044 --> 00:30:49,112
there's no, there's not gonna be any set right here. And
这里不会有任何的 set

609
00:30:49,181 --> 00:30:52,950
voila I've created a simple computed property that's read
我已经创建一个简单的只读的计算属性

610
00:30:53,018 --> 00:30:56,119
only. By the way if you have a read only property,
顺便说如果你有一个只读属性

611
00:30:56,187 --> 00:31:00,456
you do not actually have to have the word get there. So
实际上你不必须在这里写 get 关键字

612
00:31:00,525 --> 00:31:01,190
a read only property
所以一个只读属性

613
00:31:01,259 --> 00:31:04,094
can look like that. Only if you only have a get,
可以是这个样子。你仅有一个 get 的时候可以这么做

614
00:31:04,162 --> 00:31:07,663
if you have a set can't do that. So this is a super
如果你有一个 set 不能这么做。所以这是一个非常

615
00:31:07,732 --> 00:31:10,567
simple little one. So now let's go back over here and
简单的计算属性。现在让我们返回这里

616
00:31:10,635 --> 00:31:12,436
do the little more complicated one over here.
完成这个稍微复杂的计算属性

617
00:31:12,504 --> 00:31:16,840
This one does have a get and it also has a set. And
这个属性既有一个 get 也有一个 set

618
00:31:16,909 --> 00:31:20,577
set right here, I put in the slide that has newValue.
set 就在这里，我放到幻灯片里的那个有一个 newValue

619
00:31:20,646 --> 00:31:23,146
This is just gonna be the local variable inside here
这只是里面一个局部变量

620
00:31:23,215 --> 00:31:25,482
that contains the new value that someone set,
包含着某个人设置的新

621
00:31:25,551 --> 00:31:29,018
indexOfTheOneAndOnlyFaceUpCard to. A lot of times we don't
indexOfTheOneAndOnlyFaceUpCard。大部分时候

622
00:31:29,087 --> 00:31:31,421
put anything there, if you do that,
我们在这里不放任何东西，如果你这么做了

623
00:31:31,490 --> 00:31:34,858
it defaults to newValue. That's the name of the locals,
它的默认值就是 newValue。它是那个局部变量的名字

624
00:31:34,926 --> 00:31:36,960
there's a special variable in here called newValue.
这里有一个特殊的变量叫做 newValue

625
00:31:37,028 --> 00:31:39,562
But if you wanted to call it something like index,
但是如果你想称呼它，比如 index

626
00:31:39,631 --> 00:31:42,632
you could do that, it's totally up to you,
你可以那么做，这完全取决于你

627
00:31:42,701 --> 00:31:46,936
a lot of times we just say use newValue though. Okay,
不过大部分时候我们直接使用 newValue

628
00:31:47,005 --> 00:31:50,173
so getting the index what do we have to do
至于获取 index 的值，我们必须这么做

629
00:31:50,241 --> 00:31:53,110
to calculate the index of faceup card. So I'm just gonna
来计算正面朝上卡片的索引。我要

630
00:31:53,178 --> 00:31:56,346
write the little code and have a little localvariable,
写一小段代码，得到一个局部变量

631
00:31:56,415 --> 00:32:00,417
say foundIndex which is gonna be an optional Int. So
叫做 foundIndex，它会是一个可选类型的 Int

632
00:32:00,485 --> 00:32:03,453
I'm gonna look through all the face cards and
我会遍历所有的卡片

633
00:32:03,522 --> 00:32:05,622
see if I can find one that's gonna be the one I found.
查看是否能找到我翻开的那张卡片

634
00:32:05,691 --> 00:32:07,490
So I'm gonna use a for loop here
所以我要使用一个 for 循环

635
00:32:07,559 --> 00:32:10,227
go through all the cards.indicises, all right?
遍历所有的 cards.indices

636
00:32:10,295 --> 00:32:15,398
I'm gonna look at each card, and if that card is FaceUp.
我会查看每一张卡牌，如果那张卡牌是正面朝上的

637
00:32:15,467 --> 00:32:17,667
So I found the FaceUp card, whoo-hoo.
我就找到了它

638
00:32:17,735 --> 00:32:20,870
I'm gonna say, if foundOne is nil, in other words,
如果 foundOne 是 nil，换句话说

639
00:32:20,939 --> 00:32:24,041
I haven't found the card yet and this is my first one.
我还没找到那张卡片，也就是这是第一个正面朝上的

640
00:32:24,109 --> 00:32:28,211
Then I'm gonna set not foundOne, what is it called,
不是 foundOne，它被叫做

641
00:32:28,280 --> 00:32:32,849
foundIndex = index, all right? So here I'm just saying if I
foundIndex = index，好么？所以这里我写的是

642
00:32:32,918 --> 00:32:35,985
just found my first one let's remember it.
如果我找到了我的第一张卡片，让我们记住它

643
00:32:36,054 --> 00:32:39,522
Otherwise, if foundIndex is not nil that means this is
否则，如果 foundIndex 不是 nil，它意味着

644
00:32:39,591 --> 00:32:41,958
the second FaceUpCard that I found.
这是我找到的第二张正面朝上的卡片

645
00:32:42,027 --> 00:32:44,494
Cuz I already found one and I found another one, so
因为我已经找到了一张并且找到了另一张

646
00:32:44,563 --> 00:32:47,431
here I am just gonna to return nil. Because if there's two
所以这里我会返回 nil。因为如果这里有两张

647
00:32:47,499 --> 00:32:49,900
FaceUpCards then obviously the index of the one and
正面朝上的卡片，那么显然 indexOfOneAndOnlyFaceUpCard

648
00:32:49,968 --> 00:32:53,270
only FaceUpCard is nil, there's no such thing. And
是 nil，没有这样的东西

649
00:32:53,339 --> 00:32:55,371
if I make it all the way through this for
如果我完成了整个 for 循环

650
00:32:55,440 --> 00:32:58,708
loop I'm just gonna return the foundIndex, which is either
我会返回 foundIndex，它要么

651
00:32:58,776 --> 00:33:01,211
going to have been set to the one card I found or
被设定成了我找到的那张卡片或者

652
00:33:01,280 --> 00:33:03,680
it'll still be nil from this declaration.
仍然是 nil，通过这个声明来说的话

653
00:33:03,748 --> 00:33:05,682
Remember that optionals always get
还记得可选类型在声明的时候总是自动

654
00:33:05,750 --> 00:33:09,051
this free equals nil when they're declared, right? So it
获得这个缺省值，对吧？所以

655
00:33:09,120 --> 00:33:12,222
starts out nil and if I never found one, it'll still be nil,
它以 nil 开始，如果我没有找到一张卡片，它将仍是 nil

656
00:33:12,291 --> 00:33:15,692
which is right cuz that means there'll be no FaceUpCards.
这是正确的，因为它意味着这里没有正面朝上的卡片

657
00:33:15,761 --> 00:33:18,395
We're gonna understand this simple code right here,
我们都理解这里的这块简单的代码

658
00:33:18,464 --> 00:33:20,730
how about the set case? On the set case,
至于 set 的情况呢？在 set 例子中

659
00:33:20,799 --> 00:33:22,198
I'm just gonna loop through all the cards and
我要遍历所有的卡片

660
00:33:22,267 --> 00:33:26,236
turn all face down except for this one that they just set it
把它们全部翻到背面，除了这张，它刚刚

661
00:33:26,304 --> 00:33:29,338
to, which is gonna be new value, all right? So I'm just
被设置成了 newValue，对么？

662
00:33:29,407 --> 00:33:33,243
gonna go through my cards for index in cards.indices.
我要遍历我的卡片，for index in cards.indices

663
00:33:33,312 --> 00:33:36,412
Great way to go iterate through this countable
这是一个很棒的方式来迭代这个包含

664
00:33:36,481 --> 00:33:39,348
range of all the indexes in my array. I'm gonna say,
数组里所有索引的 CountableRange。我会写

665
00:33:39,417 --> 00:33:45,756
cards.index.isFaceUp = false,
cards.index.isFaceUp = false

666
00:33:45,824 --> 00:33:50,327
for most cards. But in case the index here,
对于大部分卡片来说。但是对于这个索引来说

667
00:33:50,395 --> 00:33:54,264
this index equals the new value of this, then I'm gonna
如果它等于 newValue

668
00:33:54,332 --> 00:33:59,369
set it to true. Okay, so here this is an expression
我把它设置为 true。好的，这是一个表达式

669
00:33:59,438 --> 00:34:03,874
that's true if someone said indexOfTheOneAndOnlyFaceUpCard
如果某个人说 indexOfTheOneAndOnlyFaceUpCard 等于

670
00:34:03,942 --> 00:34:07,210
equals whatever. If this is the whatever they said,
无论什么 ，如果这是那个值的话

671
00:34:07,279 --> 00:34:10,547
then we're gonna have this be true if the card's face up,
那么我们会让正面朝上的它是 true

672
00:34:10,615 --> 00:34:13,549
o therwise this will always be false. Everybody got this
否则它会一直是 false。每个人都理解了

673
00:34:13,618 --> 00:34:17,553
little code right there? Come through with that? All right,
这一小段代码么？能够理解它么？好的

674
00:34:17,622 --> 00:34:21,391
that's it. Okay, now the indexOfTheOneAndOnlyFaceUpCard
这就是它了。现在 indexOfTheOneAndOnlyFaceUpCard

675
00:34:21,459 --> 00:34:22,859
is computed like this,
就像这样子被计算了

676
00:34:22,927 --> 00:34:26,329
from the card, we do not need to take responsibility for
我们没有必要负责去做一些像

677
00:34:26,398 --> 00:34:30,233
doing things like setting it to nil here. This is the case
把它设为 nil 之类的事情。这是一个例子

678
00:34:30,302 --> 00:34:33,136
where we found two cards, we got two cards that we're
在这里我们找到了两张卡片，我们有两张要尝试匹配

679
00:34:33,204 --> 00:34:36,273
trying to match, well, obviously there's two cards.
的卡片，很明显这里是两张卡片

680
00:34:36,341 --> 00:34:38,474
So we had to set the indexOfTheOneAndOnlyFaceUpCard
所以我们不得不设置 indexOfTheOneAndOnlyFaceUpCard

681
00:34:38,543 --> 00:34:40,744
to nil cuz there were two. But we don't have to do that
为 nil 因为这里有两张。但是我们现在再也不必这么做了

682
00:34:40,812 --> 00:34:42,912
anymore, because it's always computing that,
因为它总是会计算它的值

683
00:34:42,981 --> 00:34:45,749
every time we ask, it goes and looks at the card. And
每一次我们请求，它去到程序里查看卡片

684
00:34:45,817 --> 00:34:49,418
even better than that is this case down here. Okay,
比这更好的是下面这个例子

685
00:34:49,487 --> 00:34:51,520
this case down here, we are setting the
下面这个例子里，我们正在设置

686
00:34:51,589 --> 00:34:53,523
indexOfTheOneAndOnlyFaceupCard to
indexOfTheOneAndOnlyFaceUpCard 为

687
00:34:53,592 --> 00:34:56,259
be the index. That's because this was the case where there
index。那是因为在这种情况下

688
00:34:56,328 --> 00:34:57,894
were already two or there were none,
已经有了两张卡片或者没有卡片正面朝上

689
00:34:57,963 --> 00:35:01,364
and now we turn those faceDown and do this new one.
我们把它们翻转朝下然后进行新的选择

690
00:35:01,433 --> 00:35:04,734
So we're already setting this and it does all of this.
我们已经设置过它了，程序做了所有的事情

691
00:35:04,802 --> 00:35:07,470
Setting this thing to something already turns all
设置它为某个值已经把所有其他的卡片

692
00:35:07,539 --> 00:35:11,641
the other cards faceDown. And already sets that card faceUp,
翻到了背面。而且已经设置那张卡片朝上

693
00:35:11,709 --> 00:35:16,178
so we don't need any of that code. So you see how making
所以我们不需要这里任何的代码。所以你看

694
00:35:16,247 --> 00:35:20,083
the computed property makes this code much simpler and
计算属性令我们的代码多么的简单易懂

695
00:35:20,152 --> 00:35:23,819
straightforward. Cuz it really gets at the heart of what's
因为它完全囊括了正在发生的事情的核心

696
00:35:23,888 --> 00:35:26,656
going on. I'm just setting the indexOfTheOneAndOnlyFaceUpCard
我只需要设置 indexOfTheOneAndOnlyFaceUpCard 的值

697
00:35:26,725 --> 00:35:27,223
to this index
为这个 index

698
00:35:27,292 --> 00:35:28,191
that I just clicked on or
我点击的 index

699
00:35:28,260 --> 00:35:30,727
I'm just turning this card faceUp. And the next time
把这张卡片翻到正面。下一次某人

700
00:35:30,795 --> 00:35:34,063
someone asks for the indexOfTheOneAndOnlyFaceUpCard
请求 indexOfTheOneAndOnlyFaceUpCard 的时候

701
00:35:34,132 --> 00:35:36,466
it's gonna do the right thing, right?
它就会是正确的值，对吧？

702
00:35:36,535 --> 00:35:39,302
So let's go and run, make sure we didn't break
让我们运行程序，确保我们在把它创建成一个计算属性

703
00:35:39,371 --> 00:35:43,306
anything making this into a computed property. Here we go,
过程中没有改坏任何东西。让我们开始吧

704
00:35:43,374 --> 00:35:46,009
hopefully we can still match, yeap, that matches,
希望我们仍然可以匹配，好的，它匹配了

705
00:35:46,077 --> 00:35:48,645
and the matching is working, and the mismatching is also
匹配正在工作，不匹配也

706
00:35:48,714 --> 00:35:52,982
working. Really cool computed properties,
是好的。计算属性真的很酷

707
00:35:53,050 --> 00:35:55,718
you're gonna see computed properties everywhere in iOS,
你将会在 iOS 的每个地方看到计算属性的身影

708
00:35:55,787 --> 00:36:01,223
they get very common, yeah. >> [INAUDIBLE]
它们是非常常见的 >> [学生提问]

709
00:36:01,292 --> 00:36:02,258
>> Okay great question, so
>> 好的，非常棒的问题。所以

710
00:36:02,326 --> 00:36:04,995
when would I ever use this var versus
什么时候我会使用这个变量而不是

711
00:36:05,063 --> 00:36:07,664
having two methods, one which get's the index and
用两个方法，一个得到 index 的值

712
00:36:07,732 --> 00:36:09,833
one really [INAUDIBLE] and one that sets it.
一个设置 index 的值

713
00:36:09,901 --> 00:36:14,003
Okay, it's all about whether it's perceived as property.
好的，这取决于它是否被认定为一个属性

714
00:36:14,072 --> 00:36:17,807
This index in effect is perceived by us as programmers
这个 index 实际上被我们程序员视为

715
00:36:17,875 --> 00:36:20,710
it's a property right? It's, it's a property of the game
一个属性，对么？它是翻牌游戏的一个属性

716
00:36:20,779 --> 00:36:22,379
is the index on the face of the card, so
它是唯一朝上的卡片的索引，所以

717
00:36:22,447 --> 00:36:27,049
that's what you would do here. If another way of kind of
这就是这里使用计算属性的原因。另一种决定的方法

718
00:36:27,118 --> 00:36:32,021
deciding is if the set or the get really does a lot of work.
是 set 或者 get 是否做了很多的工作

719
00:36:32,090 --> 00:36:35,158
Like it's really crunching on something,
比如它处理了很多事情

720
00:36:35,227 --> 00:36:36,826
you might wanna make that a function.
你可能想把它做成一个函数

721
00:36:36,895 --> 00:36:38,628
Just so the people don't think, oh it's a lightweight
那样子的话，人们就不会认为，它是一个轻量

722
00:36:38,696 --> 00:36:41,731
little property that I can get. Now, this might seem like
可以随时获取的属性。现在，它可能看起来

723
00:36:41,800 --> 00:36:43,966
a lot of work but it's actually very very simple.
做了很多的工作，但是实际上非常非常简单

724
00:36:44,035 --> 00:36:46,703
And then later in the lecture, probably on Wednesday,
之后可能在周三的课堂上

725
00:36:46,771 --> 00:36:50,073
I'm gonna show you an even much simpler version of this.
我会展示给你们一个更简单的版本

726
00:36:50,141 --> 00:36:51,775
When we learn a little bit more about Swift.
当我们学习更多一点 Swift 的内容后

727
00:36:51,843 --> 00:36:53,676
But it really is not that much work it's just looking at
不过它真的不是那么多的工作，它只是查找

728
00:36:53,745 --> 00:36:56,412
another data structure. But if you were doing a lot of work
另一个数据结构。但是如果你正在做很多的工作

729
00:36:56,481 --> 00:36:58,114
then you probably want to do set and
那么你可能想要做 set 和 get（两个方法）

730
00:36:58,182 --> 00:37:01,651
get to make it clear. But otherwise if it is
来让它清晰。否则的话如果概念上它是

731
00:37:01,720 --> 00:37:06,322
a var if it seems like a var make it a var. Good question.
一个变量，感觉应该是个变量，就让它成为一个变量。非常好的问题

732
00:37:06,391 --> 00:37:09,892
Alright where is my, here it is, keynote,
好的，我的 Keynote 在哪里，哦，在这

733
00:37:09,961 --> 00:37:13,897
lets go back here, back to our slides. All right,
让我们返回这里，返回我们的幻灯片。好的

734
00:37:13,965 --> 00:37:17,199
so the next thing we're gonna talk about is here,
我们要讨论的下一件事情

735
00:37:17,268 --> 00:37:20,303
is another topic something we knew, access control. Okay, so
它是我们所了解的另一个主题，访问控制

736
00:37:20,372 --> 00:37:23,372
what is access control? So, how many people have worked on
什么是访问控制？有多少人编写过一个项目

737
00:37:23,441 --> 00:37:27,243
a project, an object oriented program project of more
一个有很多类的面向对象编程项目？

738
00:37:27,312 --> 00:37:31,147
than a dozen classes? Okay, like two or
好的，像是两三个

739
00:37:31,216 --> 00:37:35,284
three of you, four maybe, so, not very many of you. Okay,
同学，可能四个，总之并不是非常多

740
00:37:35,353 --> 00:37:37,853
well when you're working on a very small project like that,
当你从事一个小项目的时候

741
00:37:37,922 --> 00:37:40,056
you can call any method in any class, whatever,
你可以随意地在任何类里调用任何方法

742
00:37:40,124 --> 00:37:42,224
you're probably the only programmer working on it.
你可能是工作的唯一的程序员

743
00:37:42,293 --> 00:37:44,627
Or maybe you're working out with a buddy, and so
或者你和一个好朋友一起从事

744
00:37:44,695 --> 00:37:47,229
you can talk to each other. Okay, but now imagine
所以你们可以互相交谈。但是想象

745
00:37:47,298 --> 00:37:50,967
that you're working for Google. Or Facebook, or Apple,
你为 Google 工作，或者 Facebook 或者 Apple

746
00:37:51,035 --> 00:37:54,471
or something like that, and this is kind of ridiculous.
等其他差不多的大公司，那这就有点荒唐了

747
00:37:54,539 --> 00:37:57,273
But let's say you're working on concentration there. And
你正从事于翻牌游戏这个项目

748
00:37:57,342 --> 00:37:59,942
there's a whole another group in another building that does
这里有另外一整个团队在另一幢建筑里从事

749
00:38:00,011 --> 00:38:03,546
game design and they write the model. And
游戏设计，并且由它们编写模型

750
00:38:03,615 --> 00:38:05,848
you are just the UI team for iOS,
你仅仅是 iOS 的 UI 团队

751
00:38:05,917 --> 00:38:08,050
so you're only writing the view controller.
你只是写写视图控制器

752
00:38:08,119 --> 00:38:11,054
Okay, well now, you don't wanna be calling each others
好的，那你不想只是混乱地互相调用代码

753
00:38:11,122 --> 00:38:13,656
code just willy-nilly. Calling any old method like
你不会想调用任何老旧的方法

754
00:38:13,724 --> 00:38:16,225
you wouldn't want your view controller cal someone like
比如你的视图控制器要调用

755
00:38:16,294 --> 00:38:17,761
indexOfOneAndOnlyFaceUpCard.
indexOfOneAndOnlyFaceUpCard

756
00:38:17,829 --> 00:38:20,363
If those guys are like they got rid of that method
但如果某些人移除了那个方法

757
00:38:20,431 --> 00:38:23,566
into the next month, and now your code broke. Now,
那么下一个月你的代码就不能用了

758
00:38:23,634 --> 00:38:26,236
there are some methods that you have to be able to call
现在，这里有一些方法你一定能够去调用

759
00:38:26,304 --> 00:38:29,172
over there and their code, and we're gonna make it clear
我们将会通过使用访问控制来表明

760
00:38:29,241 --> 00:38:31,541
which ones of those are using access control.
哪些代码可以被我们调用

761
00:38:31,610 --> 00:38:35,244
So access control is about having keyword that we're gonna put
所以访问控制是通过吧关键字放到

762
00:38:35,313 --> 00:38:37,981
into our API, put it on the methods and vars,
放到 API，我们的方法和变量上

763
00:38:38,049 --> 00:38:41,684
it says to other groups that we're programming with, yes,
告诉和我们合作的其他的小组说，是的

764
00:38:41,753 --> 00:38:45,088
you are allowed to call this, I promise not to break this
你被允许调用这个，我保证不会让你的代码出问题

765
00:38:45,156 --> 00:38:48,892
on you. It also tells them how to use your thing because
它也告诉他们如何使用你的东西，因为

766
00:38:48,960 --> 00:38:51,794
the ones they're allowed to call or the ones they should
他们被允许调用的，也是他们应该使用的东西

767
00:38:51,863 --> 00:38:54,997
be using to use your concentration game or
是为了使用你的翻牌游戏

768
00:38:55,066 --> 00:38:57,300
whatever. So what are these keywords?
所以这些关键字是什么？

769
00:38:57,368 --> 00:39:01,237
Well the first one is called internal. These are keywords
第一个叫做 internal（内部的）。这些关键字你都可以放到

770
00:39:01,306 --> 00:39:04,541
you put in front of vars and funcs. Or even classes and
变量和函数前面，或者甚至是类和

771
00:39:04,609 --> 00:39:07,176
structs, you can make entire classes and structs,
结构体前面，你可以对整个类和结构体

772
00:39:07,245 --> 00:39:10,813
have their access controlled. So the default internal,
进行访问控制。所以默认的 internal

773
00:39:10,881 --> 00:39:12,682
this one we never actually type in
实际上我们没来没敲过这个关键字

774
00:39:12,751 --> 00:39:15,485
because it's the default. So all of the methods and
因为它是默认的。所以我们现在在翻牌游戏里完成的

775
00:39:15,554 --> 00:39:17,653
vars that we've done so far in Concentration are all
所有方法和变量都是

776
00:39:17,722 --> 00:39:20,656
internal. Now what does internal Access Control mean?
internal。internal 在访问控制中意味着什么呢？

777
00:39:20,725 --> 00:39:26,061
It means anyone in your app, any object, any code anywhere
它意味着在你的应用中的任何人，任何对象，任何代码

778
00:39:26,130 --> 00:39:29,665
can call that method or access that var. So it's pretty much
都可以调用这个方法或者访问这个变量。所以它在你的应用里是

779
00:39:29,734 --> 00:39:33,335
unlimited control inside your app. Now as we start talking
非常不受限的一种控制。现在当我们谈论

780
00:39:33,404 --> 00:39:35,772
about access control, we have to realise there's always two
访问控制的时候，我们不得不意识到这里总有两种

781
00:39:35,841 --> 00:39:39,442
kinds of programming, there's writing an app,
编程类型，一种是编写应用

782
00:39:39,510 --> 00:39:42,445
then there's writing a framework. Like Apple does,
一种是编写框架，像 Apple 做的

783
00:39:42,514 --> 00:39:46,582
UI kit, okay? That's framework. A lot more access
UIKit，好么？那是框架。如果你在编写框架的时候

784
00:39:46,651 --> 00:39:49,285
control issues if you're writing a framework. So
会有更多的访问控制事项

785
00:39:49,354 --> 00:39:51,120
I'm gonna tell you what the things are for
所以我要告诉你对于编写一个框架来说

786
00:39:51,188 --> 00:39:53,789
writing a framework but, We're not gonna really pay much
访问控制是什么，但是我们并不会花费太多

787
00:39:53,858 --> 00:39:55,625
attention to them because we are only going to learn to
注意力到上面，因为我们这门课只学习

788
00:39:55,694 --> 00:39:59,228
write apps in this course. So internal means everything in
编写应用。所以 internal 意味着你的应用

789
00:39:59,296 --> 00:40:02,699
your app, or in your framework is, can access this code.
或者你的框架里的任何事物可以访问这块代码

790
00:40:02,767 --> 00:40:05,000
So it's pretty much almost unlimited inside
所以它在你的框架里

791
00:40:05,069 --> 00:40:08,671
your App's framework. Then there's the three privates.
是非常不受限制的。之后这里有三种私有的

792
00:40:08,740 --> 00:40:10,473
These are very important, these are the ones you're
它们是非常重要的，它们是你会一直

793
00:40:10,542 --> 00:40:14,143
gonna be using all the time. One is just private,
使用的。一个就叫 private

794
00:40:14,212 --> 00:40:17,313
that means its internal implementation to this object,
它意味着是这个对象的内部实现

795
00:40:17,381 --> 00:40:22,384
no other objects can call it. This is a good one to set,
没有其他的对象可以调用它，这是很好的访问控制

796
00:40:22,453 --> 00:40:25,722
it keeps someone in the other group at Google and the other
它能避免在 Google 其他建筑里的小组

797
00:40:25,790 --> 00:40:28,858
building from accessing that code. Because you're
访问那块代码。因为你让他

798
00:40:28,927 --> 00:40:31,527
keeping it private, it's your private implementation.
成为私有的，这是你的私有实现

799
00:40:31,596 --> 00:40:35,164
Private set is almost exactly the same, it's only for vars,
private(set) 大致上是一样的，它只针对变量

800
00:40:35,232 --> 00:40:39,201
it means that setting this var is private, but getting it
它意味着赋值这个变量的权限是私有的，但是访问它

801
00:40:39,270 --> 00:40:43,639
is not private. So you allow people to get the var, access
并不是私有的。所以你允许人们得到这个变量，访问

802
00:40:43,708 --> 00:40:46,676
it, but they can not set it. That's you purview,
这个变量，但是不能给它赋值。那是你的权利

803
00:40:46,744 --> 00:40:48,611
that's your internal implementation sets it.
你的内部实现可以给它赋值

804
00:40:48,679 --> 00:40:51,514
We'll see a good example of that in concentration.
我们会在翻牌游戏里看到个好的例子

805
00:40:51,583 --> 00:40:54,850
And then there's fileprivate. Fileprivate in a Swift file,
然后是 fileprivate，文件内私有。在一个 Swift 文件里

806
00:40:54,919 --> 00:40:56,852
you can have multiple classes and structs in there,
你可以有多个类和结构体

807
00:40:56,921 --> 00:40:58,955
you don't have to be just one class which is what we've done
不需要像我们现在这样一个文件只有一个类

808
00:40:59,024 --> 00:41:02,158
so far and fileprivate means anything in that in that
而 fileprivate 的意思是，任何在那个

809
00:41:02,227 --> 00:41:06,162
file can access each other, right. So classes,
文件里的都可以互相访问，也就是类

810
00:41:06,230 --> 00:41:09,665
all classes in there, it can each others methods, okay,
所有的都可以访问 fileprivate 的方法（和变量）

811
00:41:09,734 --> 00:41:12,501
that's what file private means. Okay, the other ones
这就是 fileprivate 的意思。好，其他的

812
00:41:12,570 --> 00:41:15,204
are public and open, those are for framework writers.
public 和 open，这两个是给框架作者用的

813
00:41:15,273 --> 00:41:18,007
Public means that people outside the framework
public 的意思是编写框架以外的人

814
00:41:18,076 --> 00:41:21,444
can call it. Doesn't make sense for outside your app,
也可以调用它。在你的程序外使用是说不通的

815
00:41:21,512 --> 00:41:23,746
that would never happen, so outside your framework.
这也不可能发生，所以是在框架外使用

816
00:41:23,815 --> 00:41:26,416
And open means not only can people outside your framework
open 的意思是不仅框架外可以

817
00:41:26,484 --> 00:41:29,585
call it but they could sub class that class,
调用，他们还可以继承那个类

818
00:41:29,654 --> 00:41:31,320
override your methods all that stuff,
重写你的方法等

819
00:41:31,388 --> 00:41:35,124
so open is like wide open, okay. We don't care about that
所以 open 是很开放的权限。但我们不用管

820
00:41:35,193 --> 00:41:38,361
cuz we're only, we're not doing frameworks, right. So
因为我们只写程序，不会写框架，好吧，所以

821
00:41:38,430 --> 00:41:41,030
we're gonna focus on private of the various privates.
我们主要关注这几种私有的访问权限

822
00:41:41,099 --> 00:41:43,999
A good strategy to use these is pretty much put private on
最好的做法是基本都用 private

823
00:41:44,068 --> 00:41:46,969
anything until you're sure, yeah I want someone else to be
除非你确信说，我想要其他人

824
00:41:47,038 --> 00:41:48,904
able to call this method somewhere.
在其他地方能够调用这个方法

825
00:41:48,973 --> 00:41:53,509
Right that's by default you should make things private. So
所以默认你应该让所有的都是 private

826
00:41:53,578 --> 00:41:56,312
let's look a concentration, what it would look like to
所以让我们看看翻牌游戏，它看起来是什么样的

827
00:41:56,381 --> 00:41:58,114
put access control on concentration and
如果我们给玩牌游戏加上访问权限的话

828
00:41:58,182 --> 00:42:00,883
pay attention here because I'm gonna require in all your
你要注意了，因为我要求你所有的

829
00:42:00,952 --> 00:42:04,153
homeworks going forward that you mark things properly.
之后的作业里正确地标记访问权限

830
00:42:04,222 --> 00:42:05,922
I want you to mark things private if they should be
我想要你把私有的都标记为 private

831
00:42:05,990 --> 00:42:08,224
private. Okay, cuz I wanna just make sure that you
因为我想要确保你

832
00:42:08,292 --> 00:42:11,895
understand what this is all about. So let's go back here
理解了这是什么。那我们回到这里

833
00:42:13,565 --> 00:42:16,665
to Xcode. Let's start with our ViewController.
到 Xcode 里，从 ViewController 开始

834
00:42:16,734 --> 00:42:19,134
Okay, we have three classes, or three data structures,
好，我们有三个类，准确说是三个数据结构

835
00:42:19,203 --> 00:42:21,304
our ViewController, Card, and Concentration. So let's start
我们的 ViewController、Card 和 Concentration。那我们

836
00:42:21,372 --> 00:42:27,210
with ViewController. So this right here is our model. So
从 ViewController 开始改。这个是我们的模型

837
00:42:27,278 --> 00:42:31,514
would we want our model to be public, to be not private?
我们想要模型是公开的，非私有的吗？

838
00:42:31,583 --> 00:42:33,582
Well that depends, actually.
这不一定

839
00:42:33,651 --> 00:42:36,319
It depends of what your model is and how it works. Often,
那取决于你的模型是什么，怎么工作的。一般来说

840
00:42:36,387 --> 00:42:40,256
ViewControllers models are public by public I mean
ViewController 的模型是公开的。我这个公开不是指 public

841
00:42:40,325 --> 00:42:43,492
non-private. We're inside an app so forget about public and
意思是非私有。我们写的是一个 App，所以你可以忽略 public 和

842
00:42:43,561 --> 00:42:47,096
open keywords. I mean, when I say public I mean non-private.
open 这两个关键字。所以我所谓的 public 公开是指非私有

843
00:42:47,165 --> 00:42:49,932
So a lot of times you do because you give a model to
而大部分时候都是这样的，因为你把一个模型提供给

844
00:42:50,001 --> 00:42:51,433
a view controller and it displays it,
视图控制器，然后控制器就显示它

845
00:42:51,502 --> 00:42:54,870
that's what it does. But that is not the case here. This one
这就是他的工作。但我们这里不是这样的情况。这里

846
00:42:54,939 --> 00:42:58,240
wants to be private. And the reason it wants to be private
我们想要是 private 的。它应该是私有的

847
00:42:58,309 --> 00:43:01,477
is because the number of pairs of cards in the game is
原因是 numberOfPairsOfCards

848
00:43:01,545 --> 00:43:04,480
intimately tied to the UI, okay the number of
游戏里卡片的对数是和 UI 捆绑着的

849
00:43:04,549 --> 00:43:07,083
cards we have in the UI. So if we wanted to make
是我们 UI 里卡的对数。如果我们想要

850
00:43:07,151 --> 00:43:09,585
this public then we'd also have to make something public
让它公开的的话，我们也需要让另一个公开的

851
00:43:09,653 --> 00:43:13,356
to specify the number of card buttons that we allow and
来指定我们允许的显示卡片的按钮的个数

852
00:43:13,425 --> 00:43:15,391
we don't do that currently,
但我们现在并不是这样的

853
00:43:15,460 --> 00:43:18,127
that's something that is in our little scene and
那现在是我们在 Interface Builder

854
00:43:18,195 --> 00:43:21,430
interface builder, so we don't do it. So we keep this, we
的场景里设置的，所以我们不这样做。所以我们保持这个

855
00:43:21,499 --> 00:43:25,067
keep this private. How about number of pairs of cards?
让他就是 private 的。那 numberOfPairsOfCards 呢？

856
00:43:25,136 --> 00:43:28,271
Well, this is one where I don't mind if someone asks
嘛，这个我不介意如果其他人知道

857
00:43:28,340 --> 00:43:30,706
what the number of pairs of cards is but
有多少对卡片，但是

858
00:43:30,775 --> 00:43:36,612
setting the number of pairs of cards would be bad. But
设置有多少对卡片是不好的。但

859
00:43:36,680 --> 00:43:40,816
the thing about this is it's already a get-only property.
这个的话，它已经是只读的属性了

860
00:43:40,885 --> 00:43:43,419
You can't set it anyway, it derives it from other data.
你怎么都没法设置它，它是从其他数据衍生出来的

861
00:43:43,488 --> 00:43:47,022
So we're just gonna make this private, sorry, not private.
所以我们就让他是 private 的。不好意思，让他不是 private

862
00:43:47,091 --> 00:43:49,358
And we're gonna allow people to call this,
我们要让别人能够访问这个

863
00:43:49,427 --> 00:43:51,493
people who are using my ViewController, they can say,
使用我这个 ViewController 人可以问

864
00:43:51,562 --> 00:43:53,496
how many pairs of cards are there? But they can't set it,
这里有多少对卡片，但他们不能给它赋值

865
00:43:53,565 --> 00:43:55,998
cuz this is not settable anyway. Okay, so
因为这个本来就没法赋值。好，所以

866
00:43:56,067 --> 00:43:57,366
that's okay to make that in public.
这个是可以公开的

867
00:43:57,435 --> 00:43:59,902
Same thing flipCount, I think flipCount,
flipCount 也是类似的，我认为 flipCount

868
00:43:59,970 --> 00:44:03,272
it's okay for people to get it, but definitely, we don't
人们是可以读取它的，但肯定我们不

869
00:44:03,341 --> 00:44:06,508
want people setting flipCount. That's something we do
想让人们赋值给 flipCount，那是我们

870
00:44:06,577 --> 00:44:08,978
internally when the cards are flip, we implement flipCount.
在翻牌的时候内部实现的，我们管理的

871
00:44:09,046 --> 00:44:12,148
So that's private for the setter, but will allow people
所以 setter 是 private 的，但我们允许其他人

872
00:44:12,216 --> 00:44:14,684
to get the flipCount who are using our thing.
在使用的时候获得 flipCount

873
00:44:14,752 --> 00:44:19,021
Our outlets, almost always we have private outlets.
我们这些 @IBOutlet，几乎我们都是保持 private

874
00:44:19,090 --> 00:44:19,989
Cuz our private outlets,
因为我们私有的出口

875
00:44:20,057 --> 00:44:23,159
these things, and even our actions these are all kind of
这些，甚至包括 @IBAction 操作，这些都是

876
00:44:23,227 --> 00:44:26,295
internal implementation of how we implement our UI.
内部的 UI 实现

877
00:44:26,364 --> 00:44:29,365
That's what a ViewController does it controls our UI.
这就是视图控制器的作用，控制 UI

878
00:44:29,433 --> 00:44:32,702
Definitely something like update model from UI would be
肯定类似于 updateViewFromModel 的方法

879
00:44:32,771 --> 00:44:35,271
private, that's internal implementation.
应该是 private 的，这也是内部实现

880
00:44:35,339 --> 00:44:38,808
All this emoji business that's all private. Although you
这些表情相关的也应该是 private 的，虽然

881
00:44:38,876 --> 00:44:42,845
could imagine trying to expose some public API eventually
你可以计划尝试最终暴露些公有 API

882
00:44:42,914 --> 00:44:45,848
in this ViewController that let's someone who's using
让其他使用 ViewController 的人可以

883
00:44:45,917 --> 00:44:49,051
our ViewController specify the emojis they want.
指定他们想用的表情

884
00:44:49,120 --> 00:44:53,756
Like, you know, this theme required task that you have,
比如某个任务要求用某个主题

885
00:44:53,824 --> 00:44:57,460
you could imagine that there was a way to specify I want
你可以设想我们有一种方法指定我想要

886
00:44:57,528 --> 00:44:59,995
you mister view controller to play this game,
ViewController 玩这个游戏

887
00:45:00,064 --> 00:45:02,998
but I want you to use this emoji as your theme.
但是我想要用这套表情作为主题

888
00:45:03,067 --> 00:45:05,534
See, so you could imagine that something being public.
所以设想那种情况下可以是公开的

889
00:45:05,603 --> 00:45:08,471
I don't think it would be exactly this API,
但我不认为会是和这个一样的 API

890
00:45:08,539 --> 00:45:10,439
it would be some other kind of API,
那会是不同的 API

891
00:45:10,508 --> 00:45:13,942
I'm not sure what they would let you set the emoji to
我不确定是什么样的，但它能让你设置使用的表情

892
00:45:14,011 --> 00:45:16,946
use. We can't really make this public cuz we actually consume
这个我们是不能公开的，因为我们实际会消耗

893
00:45:17,014 --> 00:45:20,883
this. This is a var and we consume it. We have obviously
这个数组；这是个变量，而我们会移除里面的内容。肯定

894
00:45:20,952 --> 00:45:23,119
had to deal with that in your homework I'm sure. And
在你们的作业里要解决这个问题。还有

895
00:45:23,187 --> 00:45:24,954
you know, this dictionary we're building on a fly,
你知道的，这个字典我们是及时构建的

896
00:45:25,022 --> 00:45:26,755
we wouldn't want anyone messing with it, so
我们不会想其他人使用它，所以

897
00:45:26,824 --> 00:45:27,857
I'm gonna keep all this private.
我让这些都是 private 的

898
00:45:27,925 --> 00:45:30,259
This is an example of making it private first and
这就是个例子，先让这些都是 private

899
00:45:30,328 --> 00:45:33,296
then I'm gonna think about what I want to be public.
之后我再考虑我要公开哪些

900
00:45:33,364 --> 00:45:34,997
You see, the design approach there?
看到我们用的设计方法了吗？

901
00:45:35,066 --> 00:45:39,802
All right, let's go look at card, so
好，我们再来看看 Card 结构体

902
00:45:39,871 --> 00:45:42,304
here's Card. Card definitely, this has to be public.
这就是 Card。Card 里这个肯定是公开的

903
00:45:42,373 --> 00:45:43,839
We need to know whether the cards are face up,
我们需要知道是否朝上

904
00:45:43,908 --> 00:45:45,908
we, this has to be public. Unfortunately,
这个也必须是公开的。不幸的是

905
00:45:45,977 --> 00:45:48,110
this has to be public. Cuz otherwise,
这个也得是公开的，因为否则的话

906
00:45:48,179 --> 00:45:50,846
we can't tell if two cards are the same without that,
没有这个的话我们不能判断两张是否相同

907
00:45:50,915 --> 00:45:54,516
but these two guys definitely don't need to be public.
但这两个肯定不用是公开的

908
00:45:54,585 --> 00:45:58,620
This whole idea of I, making identierFactory that's purely
我这整个使用 identierFactory 只是为了

909
00:45:58,689 --> 00:46:02,458
internal implementation, okay, so no reason for that to be
内部实现，所以没有理由把它

910
00:46:04,295 --> 00:46:06,995
public. And this really, I'd love this to be private as
公开。然后这个 identifier，我虽然想要是 private

911
00:46:07,064 --> 00:46:09,965
well, because a card it's either face up it's matched
因为这卡，我就想知道是否朝上，是否配对了

912
00:46:10,034 --> 00:46:12,134
whether it's the same as another card,
而两张卡是否相同

913
00:46:12,203 --> 00:46:14,971
I shouldn't have to look an identifier to find that.
我不应该靠 identier 标识符来判断

914
00:46:15,039 --> 00:46:18,007
I should be able to say the this card == the other card,
我应该能用 一张卡 == 另一张卡 来判断

915
00:46:18,076 --> 00:46:20,308
wouldn't that be cool? And yeah it is cool and
那不更好么？是的，那是挺酷的

916
00:46:20,377 --> 00:46:23,646
we're gonna be doing that, in, later in this lecture or next
而我们也就会这样做，要么等会儿这节课，要么

917
00:46:23,714 --> 00:46:26,582
lecture. Um, this is really kind of gross but for now we
下节课。我挺讨厌这个，但现在我们

918
00:46:26,650 --> 00:46:28,350
have to leave that public because otherwise we do,
就让他保持公开，因为否则的话

919
00:46:28,419 --> 00:46:31,687
we can't tell what two cards are the same. Okay,
我们就不能判断两张卡是否相同了吧

920
00:46:31,756 --> 00:46:35,090
here's the Concentration game, this is a really interesting
然后这个是 Concentration 游戏本身，这是个很有趣的

921
00:46:35,159 --> 00:46:38,660
case of private and public because, here is an object,
决定私有还是公开的例子，因为这个对象

922
00:46:38,729 --> 00:46:41,697
a model that is intended to be used by some UI somewhere,
模型本身就是给其他的某个 UI 使用的

923
00:46:41,765 --> 00:46:44,500
okay. It's very intentional use kind of thing, and
就是为了被使用而存在的

924
00:46:44,569 --> 00:46:46,535
there's some things we know are private,
这里有我们知道是 private 的

925
00:46:46,604 --> 00:46:49,271
like this guy for sure, indexOfTheOneAndOnlyFaceUpC-
比如肯定有这里的 indexOfOneAndOnlyFaceUpCard

926
00:46:49,340 --> 00:46:51,640
ard, we don't need someone using us to know that,
我们不需要让使用的人知道

927
00:46:51,709 --> 00:46:53,142
they don't need to know that.
他们不需要知道这个

928
00:46:53,211 --> 00:46:55,944
And in fact, if we left that public, someone using us would
实际上，如果我们把它公开的话，使用我们的人会

929
00:46:56,013 --> 00:46:58,613
be like when am I supposed to set that, I wonder?
想，“我要把它设置为什么呢？”

930
00:46:58,682 --> 00:47:01,483
Okay, but it has nothing to do with it, it's internal to our
但他们和这个是无关的，这是我们内部

931
00:47:01,552 --> 00:47:06,488
implementation. Cards has to be public
实现用的。cards 必须要是公开的

932
00:47:06,557 --> 00:47:09,625
because otherwise the UI can't display the cards.
否则的话 UI 就不能显示卡片了

933
00:47:09,694 --> 00:47:12,961
However, cards being flipped up and down or
但是把牌翻面，或是

934
00:47:13,030 --> 00:47:18,200
matching that's my job. So I am gonna make this one private
让他们配对,这是我的工作，所以我要让它是 private(set)

935
00:47:18,269 --> 00:47:22,405
set, okay, so this is gonna be yeah you can look at my cards
所以这个会是，使用的人可以看我有哪些牌

936
00:47:22,473 --> 00:47:25,608
if you wanna use Concentration game but I am responsible for
如果他们在用 Concentration 游戏的话。但我负责

937
00:47:25,676 --> 00:47:29,077
setting face up and is matched. So
把卡片翻面，设置是否配对了，所以

938
00:47:29,146 --> 00:47:32,114
you can see this one's clearly private set,
我们可以明确地看出这个是 private(set)

939
00:47:32,183 --> 00:47:35,784
everyone see that? Yeah. >> So for that you can access
大家都看到了吗？>> 所以 private(set) 就是你可以获得

940
00:47:35,853 --> 00:47:38,487
the cards but you can't access the methods or
cards 数组的元素，但是你不能访问元素的方法

941
00:47:38,556 --> 00:47:40,956
properties associated with it? >> Yeah, so
或者实例的属性吗？>> 好，所以

942
00:47:41,025 --> 00:47:43,759
the question is when it's like this does that mean I
问题是用 private(set) 是否意味着

943
00:47:43,827 --> 00:47:46,962
can access the cards but I can't access the methods that
我可以访问 cards 的元素，但是不能访问方法

944
00:47:47,031 --> 00:47:50,366
are on the cards you mean? No the methods on the cards,
这是你的问题吧？不，Card 实例的方法

945
00:47:50,435 --> 00:47:53,436
that's over here, those are public, okay,
那是在这里定义的，这些是公开的

946
00:47:53,504 --> 00:47:56,905
those are not internal so I can access those from here,
这些不是内部实现，所以我这里可以访问他们

947
00:47:56,974 --> 00:48:00,542
okay? But you remember that this is a value type, so
但你要记得 Card 是值类型，所以

948
00:48:00,611 --> 00:48:03,745
I can't set is face up and stuff, I can only set that
我不能赋值给 isFaceUp 这些，我只能直接

949
00:48:03,814 --> 00:48:07,950
directly in the array. Like I'm doing right here. You see,
通过数组给它赋值，就像我这里这样，你看

950
00:48:08,018 --> 00:48:10,252
here I'm modifying the thing in place in the array.
我这里直接更改了在数组里的 Card 实例的属性

951
00:48:10,321 --> 00:48:13,121
That's the only way to do it. Well, I can't do this if this
这是我唯一能用的方法。而在其他地方是不能这样做的，如果这个

952
00:48:13,190 --> 00:48:17,559
is private set. Okay? Cuz this is a value type.
是 private(set) 的话，对吧？因为这个是值类型

953
00:48:17,628 --> 00:48:20,796
So this makes it so this, this it's kind of like it's a let.
这个让它有点像是 let 声明的常量

954
00:48:20,865 --> 00:48:22,731
This almost makes it like a let for
对于其他人

955
00:48:22,800 --> 00:48:25,101
other people, people other than me. And then, and so
private(set) 就像是 let 一样，也就是

956
00:48:25,169 --> 00:48:28,571
you can't touch anything in an array when it's a let. So
在数组是 let 常量的时候你不能修改数组的元素

957
00:48:28,639 --> 00:48:31,573
that's a really cool feature of value types.
所以这是值类型很酷的特性

958
00:48:31,642 --> 00:48:33,875
And remember that array's a value type and
然后，要记得数组是值类型

959
00:48:33,944 --> 00:48:37,646
card is a value type. So that whole thing is frozen for
Card 也是值类型，所以这整个就被“冻”住了

960
00:48:37,715 --> 00:48:41,616
people who, you can't be modified for outside people.
其他人就没法修改它

961
00:48:41,685 --> 00:48:44,152
But for us, it's private set so
但 private(set) 对于我们来说

962
00:48:44,221 --> 00:48:46,789
we can do anything we want in there which we have been
我们可以像现在这样为所欲为

963
00:48:46,857 --> 00:48:50,259
doing. All right. And then of course, choose card.
好吧。然后肯定的，chooseCard

964
00:48:50,328 --> 00:48:53,929
That's our fundamental public API. So we got to leave that
这是我们基础的公有 API，所以我们就让他

965
00:48:53,998 --> 00:48:56,298
not private, okay. That's how people do it. And
不是私有的，这是别人调用的方法。然后

966
00:48:56,367 --> 00:48:59,869
initializing, initializers can be made private as well. But
构造过程，构造器也可以是私有的，但是

967
00:48:59,937 --> 00:49:02,971
this one obviously can't be private because otherwise no
这个不能是私有的，否则的话

968
00:49:03,040 --> 00:49:06,976
one could create a game, all right. So that's it. Everyone
没有人可以新建一个游戏，好，就是这样

969
00:49:07,044 --> 00:49:10,045
got that? Now, while I'm here, I'm gonna show you another
大家都明白吧？现在我在这里还要给你展示另一种

970
00:49:10,114 --> 00:49:12,982
API protection thing that's different from access control.
方法来保护 API。不是靠访问权限控制

971
00:49:13,050 --> 00:49:16,618
That's still good, which is using assertions, okay.
这也是中好方法，那就是使用 assert，断言

972
00:49:16,687 --> 00:49:18,654
Do anyone know what an assertion is from other
大家从其他语言知道了 assert/断言是什么吗？

973
00:49:18,722 --> 00:49:21,957
languages? An assertion is just a function that you call
断言就是一个你调用的 assert 函数

974
00:49:22,026 --> 00:49:25,027
where you assert something to be true. And if it's not,
以此来确保某个条件是成立的；如果不是的话

975
00:49:25,095 --> 00:49:28,063
your program crashes and print out an error.
你的程序就会崩溃，然后打印出错误信息

976
00:49:28,131 --> 00:49:31,533
And you put it in your code, the asserts are ignored when
你这代码里使用 assert 函数，但发布到

977
00:49:31,602 --> 00:49:33,936
you ship to the App Store. But when you're in development,
App Store 时会被忽略。但你在开发的时候

978
00:49:34,005 --> 00:49:35,504
it'll be crashing your program, which is good,
他会让你的程序崩溃，这是好事情

979
00:49:35,572 --> 00:49:38,807
cuz it takes the debugger right to the assertion failed.
因为调试器会带你到断言失败了的地方

980
00:49:38,876 --> 00:49:42,477
And asserts are a great way to protect your API. For example,
断言是保护你 API 的好方法，比如说

981
00:49:42,546 --> 00:49:43,979
look at this API, chooseCard.
看 chooseCard 这个 API

982
00:49:44,047 --> 00:49:46,448
What if someone says at index -1?
如果别人传的 index 是 -1 呢？

983
00:49:46,517 --> 00:49:51,620
Or at index 100 and they're only 12 cards.
或者我们只有 12 张，但他们选择在索引 100 的卡

984
00:49:51,689 --> 00:49:54,657
Okay, that's gonna crash somewhere deep inside here,
那种情况程序会在这里的某个地方崩溃

985
00:49:54,726 --> 00:49:56,425
probably like maybe here or
可能是在这里或者

986
00:49:56,494 --> 00:49:59,694
something like that. And if I'm the Google guys again, and
类似的地方。再次设想如果我是 Google 的员工

987
00:49:59,763 --> 00:50:01,363
these guys are in another building and
他们在另一栋建筑里

988
00:50:01,431 --> 00:50:05,900
I accidentally pass -1 here and I don't know what's. And
我不小心传了 -1 给 index，然后

989
00:50:05,969 --> 00:50:09,438
the crash happens in here, I'm gonna need to have this code,
程序在这里面崩溃了，那我需要拿到这份代码

990
00:50:09,507 --> 00:50:11,807
and look in there, and I'm debugging it.
然后到这里面找，去调试它

991
00:50:11,876 --> 00:50:13,842
That code belongs to someone in another building,
这段代码是在别的地方的其他人写的

992
00:50:13,910 --> 00:50:16,712
why would I ever wanna be in here debugging it? Instead,
为什么我会想去帮他调试代码？取而代之

993
00:50:16,780 --> 00:50:20,382
the guys in the other building should put an assert here.
在另一个建筑里的人应该在这里使用断言

994
00:50:20,450 --> 00:50:28,290
That asserts that the cards indices contain that index.
assert(cards.indices.contains(index), )

995
00:50:28,359 --> 00:50:31,360
Okay, if the card's indices don't contain this index,
如果 cards 数组的索引 indices 不包含 index

996
00:50:31,429 --> 00:50:34,563
then we're going to crash, if we're in development and so,
如果我们在开发的过程中，那程序就会崩溃

997
00:50:34,632 --> 00:50:37,266
then we want to put some kind of crash message here.
然后这里我们应该放崩溃的时候显示的信息

998
00:50:37,334 --> 00:50:40,736
I like to put the name of the struct or class and
我个人喜欢放这个结构体或类的名字

999
00:50:40,805 --> 00:50:44,739
the function which chooseCard. I even like to include
以及函数名，也就是 chooseCard。我甚至喜欢包括

1000
00:50:44,808 --> 00:50:47,876
the actual arguments that you passed so you can see what you
传给我的实际参数，这样调用的人就能知道

1001
00:50:47,944 --> 00:50:51,914
passed there and then, I give the message. In this case,
传给我的参数。最后是我的错误信息，这里

1002
00:50:51,983 --> 00:50:57,186
something like chosen index not in the cards.
就用比如“选择的索引不在 cards 数组里”

1003
00:50:59,523 --> 00:51:02,091
So that, so now if someone calls to choose
这样的话，其他人调用 chooseCard

1004
00:51:02,159 --> 00:51:04,860
card at minus one, it's gonna crash right away and
传入负一，那就会直接崩溃

1005
00:51:04,928 --> 00:51:06,695
put that on the console. And they're gonna be like,
然后显示这个信息到控制台里。调用的人就知道

1006
00:51:06,763 --> 00:51:08,564
oh, shows the index not on the card, oh, and
哦，说索引不在 cards 数组里，哦

1007
00:51:08,632 --> 00:51:11,667
I passed minus one. You see, they're gonna one stop shop.
我传的是 -1。你看，一步到位

1008
00:51:11,735 --> 00:51:14,803
Know what they did. And with the similar thing thing down
能知道他们干了什么。下面这也是类似的

1009
00:51:14,872 --> 00:51:18,239
here for number of pairs of cards because it's illegal to
对于 numberOfPairsOfCards，是不能有

1010
00:51:18,308 --> 00:51:22,678
have 0 or less pairs of cards. You have to have at least one
0 或者更少对卡片的。你必须要有至少一对

1011
00:51:22,747 --> 00:51:25,514
pair of card. So here I'm just gonna have the assertion be
卡片，所以我这里就加个断言

1012
00:51:25,583 --> 00:51:29,184
that the number of Pairs Of Cards is greater than 0.
确保 numberOfPairsOfCards 大于 0

1013
00:51:29,253 --> 00:51:30,986
And if there is an error then I'm gonna say yes,
如果不是的话，那我就会说

1014
00:51:31,054 --> 00:51:34,890
I'm in the concentrations Init and
我在 Concentration.init 里

1015
00:51:34,959 --> 00:51:40,629
you passed me this number of pairs of cards right here and
然后是你传给我的这个 numberOfPairsOfCards

1016
00:51:40,698 --> 00:51:45,100
the problem here is that you must have at least
问题是你必须至少有

1017
00:51:45,169 --> 00:51:49,604
one pair of cards. Okay? So, you see how I'm, I'm using
一对卡片。好吧？你看到我是怎么使用

1018
00:51:49,673 --> 00:51:53,476
assert here to kinda protect my API against improper use.
断言来保护我的 API 不被错误地使用

1019
00:51:53,544 --> 00:52:00,282
Question back there? Yeah? >> Sorry when you,
后面同学有什么问题？>> [学生提问]

1020
00:52:00,351 --> 00:52:01,616
Sorry when you- >> When would you set init
>> 能重复你的问题么？>> 你什么时候会让 init

1021
00:52:01,685 --> 00:52:02,250
as private? >> Oh, so
是 private 的呢？>> 哦

1022
00:52:02,319 --> 00:52:07,122
the question is when would I set my init as private, okay.
这个同学问我什么时候会有私有的构造器

1023
00:52:07,191 --> 00:52:10,826
Well, you might have a complicated object that
举个例子，你可能会有一个复杂的对象

1024
00:52:10,895 --> 00:52:14,062
only creates instances of itself. For example,
只允许它自己构造实例，通过比如

1025
00:52:14,131 --> 00:52:16,030
with static methods or something like that.
static 的静态方法一类的来实现

1026
00:52:16,099 --> 00:52:18,600
Or you might have multiple inits. Some of which you'll allow
或者你有多个 init。有些你允许

1027
00:52:18,669 --> 00:52:21,537
other people to call. But some of which you call internally
其他人调用，而有些只是你内部使用的

1028
00:52:21,605 --> 00:52:24,906
to create, okay. You might even have public ones that is
你甚至可能有公开的构造器

1029
00:52:24,975 --> 00:52:27,409
part of their implementation called the private ones. Okay,
会调用私有的构造器来实现

1030
00:52:27,477 --> 00:52:30,312
cuz inits can call each other which we'll talk about on
因为构造器可以调用另一个构造器。这个我们会在

1031
00:52:30,381 --> 00:52:34,149
Wednesday. So that's why you might have some private. Okay,
星期三讲。这就是为什么可能你的某些构造器是私有的

1032
00:52:34,218 --> 00:52:36,451
everybody cool with access control and
大家都对访问权限和断言没问题了吧？

1033
00:52:36,520 --> 00:52:40,922
assertions? All right, back to the slides.
好，我们接着讲幻灯片

1034
00:52:40,991 --> 00:52:45,127
Where are we? Here, okay. Cool one, all right extensions. So
我们讲到哪里了来着？这里，这个很厉害，extension

1035
00:52:45,195 --> 00:52:49,732
extensions are super powerful. They're kind of like
扩展非常强大，它就像一种武器

1036
00:52:49,800 --> 00:52:52,367
a weapon you'll want to be careful when you're wielding,
当你使用的时候需要额外小心

1037
00:52:52,436 --> 00:52:56,004
because you can go crazy with them. And what an extension
因为你可能会走火入魔。在 extension 里

1038
00:52:56,073 --> 00:53:01,176
allows you to do is add vars and functions to other classes
你可以给其他的类添加变量和方法

1039
00:53:01,245 --> 00:53:03,378
even if you don't have the code to those classes.
即使你没有那个类的源代码也能做到

1040
00:53:03,447 --> 00:53:06,681
Even if there in another frame work like UI Kits or something
即使那个类属于另一个如 UIKit 一类的框架

1041
00:53:06,750 --> 00:53:10,753
like that. So you can add vars and methods to Int, you can add
你可以给 Int 添加变量和方法，你可以添加

1042
00:53:10,821 --> 00:53:14,389
it to UI Button. You can add it UI View Controller.
到 UIButton 里，可以添加给 UIViewController

1043
00:53:14,458 --> 00:53:17,459
Anything you want. Okay? So this is a very, very, very
任何你想要的类，知道了吧？所以这是个非常非常

1044
00:53:17,528 --> 00:53:21,296
powerful feature. And really I'm sure what's swimming in your mind about
非常强大的功能。我确信能猜到你们脑袋里想的

1045
00:53:21,364 --> 00:53:23,865
the possibilities is nothing compared to the actual
各种可能性只是实际能实现的微不足道

1046
00:53:23,934 --> 00:53:26,702
possibilities because there are other data structures that
的一部分，因为还有很多数据结构

1047
00:53:26,770 --> 00:53:30,105
we haven't even talked about that adding an extension to
我们还没有讲到，但给它们添加扩展

1048
00:53:30,173 --> 00:53:33,141
really is powerful and we'll get to that by end of
是真的很实用，我们会在星期三

1049
00:53:33,210 --> 00:53:38,213
Wednesday as well. The basic line of it is, is very simple.
下课之前讲。要添加扩展很简单

1050
00:53:38,281 --> 00:53:40,949
You just use the keyword extension and the name of
你只需要用关键字 extension，然后数据类型的名字

1051
00:53:41,018 --> 00:53:44,319
the struct or class you wanna add a var property to and
就是你想要添加变量的结构体或类的名字

1052
00:53:44,388 --> 00:53:46,554
then just put the thing you want in there.
然后在大括号里写你要扩展的内容

1053
00:53:46,623 --> 00:53:51,560
Now, it has one very some serious restriction which is
但是有一个限制是

1054
00:53:51,629 --> 00:53:56,331
that it can have no storage. This extension, this code that
扩展没有存储空间。作为扩展，这些代码

1055
00:53:56,400 --> 00:53:59,300
you're extending this other thing, it can have no vars
扩展了另一个数据类型，它是不能扩展

1056
00:53:59,369 --> 00:54:01,270
that are storage. It could have vars that are computed.
存储属性的。但它可以添加计算属性

1057
00:54:01,338 --> 00:54:04,373
But it can't have any vars with storage. So
但任何存储属性都不行

1058
00:54:04,441 --> 00:54:07,676
that does restrict the kind of thing that you can
这肯定会限制你们想添加的

1059
00:54:07,745 --> 00:54:11,013
add to a function. Okay, but you kinda turn out that
某些功能。但其实

1060
00:54:11,081 --> 00:54:14,149
restriction is actually a good restriction. It's not like
这个限制是很正确的，并不是说

1061
00:54:14,217 --> 00:54:16,952
the too bad they could invent it with storage. You
它们水平太差实现不了。你

1062
00:54:17,020 --> 00:54:19,354
actually don't want storage, and you will see as we
其实并不会想要有存储，而且你会从我们

1063
00:54:19,423 --> 00:54:22,690
go along why that is. So, this feature as you might imagine
之后讲的领悟到为什么。正如你所想的，这个功能

1064
00:54:22,759 --> 00:54:26,728
is easily abused and the number one ways to get abuse,
经常被滥用，而其中最常见的情况是

1065
00:54:26,797 --> 00:54:29,598
and I encourage you not to abuse at this way is you do
我建议你也不要这样做，那就是

1066
00:54:29,667 --> 00:54:33,835
not want to add a var or a func to class that doesn't
你不应该添加一个变量或方法到某个类

1067
00:54:33,904 --> 00:54:38,840
make sense for that class. It's a real temptation for
但对于那个类来说是毫不相关的。最吸引人的

1068
00:54:38,909 --> 00:54:43,578
example for an Int or String to add a function that has to
是比如扩展 Int 或 String，添加一个

1069
00:54:43,647 --> 00:54:47,916
do with concentration. Some concentration specific method
只为了翻牌游戏而存在的方法

1070
00:54:47,984 --> 00:54:50,719
you're adding to string cuz it'll clean up your code or
好让你的代码更简洁或者

1071
00:54:50,788 --> 00:54:53,689
look nice or whatever But you really don't wanna do that.
看起来更好看，但是你不应该这样做

1072
00:54:53,757 --> 00:54:56,658
The only method and functions you wanna add to string or
你想给 String 添加的方法和变量

1073
00:54:56,727 --> 00:54:59,962
methods that make string a better class. They make it a better
应该是为了让 String 成为一个更好的字符串

1074
00:55:00,030 --> 00:55:03,398
string not they make it knows about concentration. Now,
而不是为了让它了解翻牌游戏

1075
00:55:03,467 --> 00:55:06,134
it's probably possible to add string methods to make it
虽然可以添加方法给字符串来让它

1076
00:55:06,203 --> 00:55:08,503
know about concentrations that nothing really wrong with it.
了解翻牌游戏，这也不是什么错误的做法

1077
00:55:08,572 --> 00:55:10,405
It's just kind of bad design. Okay so
但并不是很好的设计。所以

1078
00:55:10,474 --> 00:55:14,209
this extension's feature like I said is very powerful,
就像我说的扩展是很强大的功能

1079
00:55:14,277 --> 00:55:17,979
since you're just beginning here, you can think of it at
但你们才刚开始学，你目前可以把它当作

1080
00:55:18,048 --> 00:55:21,783
the beginning as just a way to add utility, functions and
只是一种方法来添加实用工具，方法

1081
00:55:21,852 --> 00:55:24,419
things like that to clean up your code.
和其他东西来整理你的代码

1082
00:55:24,488 --> 00:55:27,622
Okay, that the first level of learning about extensions so
这就是我们对 extension 的简单认识

1083
00:55:27,691 --> 00:55:29,925
I am going to show you how we could do that for
我会给你们展示我们如何扩展

1084
00:55:29,994 --> 00:55:33,862
example in Concentration. So let's go to concentration and
比如我们的翻牌游戏，那我们回到翻牌游戏

1085
00:55:33,930 --> 00:55:37,298
use an extension to add something interesting and
使用扩展来添加有趣的东西

1086
00:55:37,367 --> 00:55:41,202
what interesting thing we are going to do is we are going to
我们要做的有趣的事情是

1087
00:55:41,271 --> 00:55:43,805
go to our view controller over here and
到 ViewController 里

1088
00:55:43,874 --> 00:55:47,876
look at this code right here which is kind of messy.
然后看看这有些乱的代码

1089
00:55:47,945 --> 00:55:50,245
Right here. Okay? What is messy about this code?
就这个。为什么说它很乱呢？

1090
00:55:50,314 --> 00:55:55,150
Well. Okay. All I really wanna do is remove a random emoji.
因为我想要做的只是随机移除一个表情

1091
00:55:55,219 --> 00:55:57,051
And you have to have a whole other line of code.
但却为此多写了一行代码

1092
00:55:57,120 --> 00:56:02,457
And that line of code has this horrendous amount of. Changing
而且这行代码还很复杂，转换

1093
00:56:02,526 --> 00:56:06,328
from unsigned ints to regular ints and all that stuff.
无符号整数和整数这些乱七八糟的

1094
00:56:06,396 --> 00:56:08,930
So it just really looks bad, and it's hard to read,
看起来很不好看，而且很难读

1095
00:56:08,999 --> 00:56:10,865
it's hard to understand what is going in here.
而且很难理解到底发生了什么

1096
00:56:10,934 --> 00:56:13,502
I'm having to do so many type conversions, stuff like that.
我需要太多的类型转换等

1097
00:56:13,570 --> 00:56:18,006
It's awful, okay? Really what I'd like to do is generate
非常糟糕是吧？我想要的只是生成

1098
00:56:18,075 --> 00:56:24,146
a random number and put it right here. So what if int,
一个随机数然后放到这里。如果整数

1099
00:56:24,215 --> 00:56:27,916
the type int, had a var which gave me a random
Int 类型有个变量可以给我随机的某个

1100
00:56:27,984 --> 00:56:31,319
integer? Okay, that's a very int thing, nothing to
整数该多好？这确实和整数相关

1101
00:56:31,388 --> 00:56:33,822
do with concentration, it's just int thing.
和翻牌游戏无关，只是整数的功能

1102
00:56:33,891 --> 00:56:38,126
It gives me a random integer. So we're going to extend int
它就给我一个随机的整数，所以我们要扩展 Int

1103
00:56:38,195 --> 00:56:42,263
to give back a random integer. Specifically, we're gonna make
来随机返回某个整数。更具体实现是

1104
00:56:42,332 --> 00:56:44,799
it so that when you ask an int please give me a random
我们要去请某个整数返回这个随机整数

1105
00:56:44,868 --> 00:56:47,436
integer it gives a random integer between 0 and that
那个随机数会在零到它本身之间

1106
00:56:47,504 --> 00:56:51,840
int. Okay, so if I say five, I can even say, I'm gonna be
比如我用 5，我还能够用

1107
00:56:51,909 --> 00:56:55,143
able to say here let x equal five dot random integer.
let x = 5.随机整数

1108
00:56:55,212 --> 00:56:58,580
And I'm gonna call this thing arc4random, this var.
我把这个随机整数变量叫 arc4random

1109
00:56:58,649 --> 00:57:01,349
Because I'm gonna use arc4random to generate it and
因为我是用 arc4random 生成它的

1110
00:57:01,418 --> 00:57:03,919
people know the semantics of arc4random which is
而且大家都知道 arc4random

1111
00:57:03,988 --> 00:57:04,786
a random a number
就是随机数

1112
00:57:04,854 --> 00:57:08,523
between 0 and another number. So this is, I'm gonna make
0 到另一个数之间的随机数。我会让

1113
00:57:08,592 --> 00:57:13,428
it so this will work and that will give me 0, 1, 2, 3, or 4.
这段代码通过编译，而且返回 0, 1, 2, 3, 4 中的一个

1114
00:57:13,496 --> 00:57:18,634
So how do I do that? Extension int and then in here
那我要怎么做呢？ extension Int 然后

1115
00:57:18,702 --> 00:57:24,306
I put this var arc4random. I have to say what type it is,
把 var arc4random 放在里面。我必须要声名它的类型

1116
00:57:24,374 --> 00:57:27,175
it's also gonna be an int. It could could be a string or
它也是 Int 类型的。扩展里的变量也可以是 String

1117
00:57:27,244 --> 00:57:29,411
whatever but it's also gonna be an int. And
或是其他的类型，但这个是 Int 类型的

1118
00:57:29,479 --> 00:57:33,014
I'm essentially gonna return all this mess right here. So
它最终返回的就是所有这里这些乱七八糟的

1119
00:57:33,083 --> 00:57:37,819
I'm just gonna cut that out of there. I'm gonna return this.
我就把它剪切然后粘贴到 return 后面

1120
00:57:37,888 --> 00:57:40,622
But it's not a random number between 0 and
但这里就不是 0..<emojiChoices.count

1121
00:57:40,691 --> 00:57:44,526
emojiChoices.count, it's a random order between 0 and
之间的随机数了，应该是 0 到

1122
00:57:44,595 --> 00:57:50,665
what? Yes, whoa, I wish I could give extra credit or
是什么？没错，我希望我能够给附加分或者

1123
00:57:50,734 --> 00:57:53,201
like Mehran, throwing some candy out there or
像 Mehran（斯坦福 CS106A 的教授）一样扔糖给你

1124
00:57:53,270 --> 00:57:56,337
something because yes absolutely, it's between 0 and
因为没错，它应该是 0 到

1125
00:57:56,406 --> 00:58:01,443
self. Because this is a var in int. And so self is the int
self 之间。因为这是 Int 到属性，所以 self 就是

1126
00:58:01,512 --> 00:58:06,514
you sent it to. Which is really kind of cool. So now,
你访问这个属性的整数。这还蛮有趣的

1127
00:58:06,583 --> 00:58:09,784
since int can do this, all we need to do right here is we
现在 Int 有了这个属性，我们这里需要做的就是

1128
00:58:09,853 --> 00:58:13,789
don't need any of this junk up here. Instead of randomIndex,
我们可以不要这些乱七八糟的 randomIndex

1129
00:58:13,857 --> 00:58:17,993
we're just gonna say emojiChoices.count.arc4random.
我们只用写 emojiChoices.count.arc4random

1130
00:58:18,062 --> 00:58:22,664
Okay, so, that cleaned up our code a lot. Now,
这样我们就让代码整洁了许多

1131
00:58:22,733 --> 00:58:25,467
if we were to do something like this, and we wanted to
如果我们写了这段代码，而我们想要

1132
00:58:25,536 --> 00:58:28,803
be really good programmers, we'd look at this and say, hm,
做优秀的程序员，我们看了这个应该想

1133
00:58:28,872 --> 00:58:30,905
what if self is 0? Eh, this is not gonna work,
如果 self 是 0 怎么办？这个就不行了

1134
00:58:30,974 --> 00:58:32,674
cuz arc4random_uniform doesn't work, but
因为 arc4random_uniform 不接受 0。那

1135
00:58:32,743 --> 00:58:35,744
what if self is negative? Actually, if self were
如果 self 是负数怎么办？事实上如果 self

1136
00:58:35,812 --> 00:58:38,513
negative, maybe I could do a random number between 0 and
是负数的话，我应该可以随机选择 0 到

1137
00:58:38,582 --> 00:58:42,684
that negative number. So, I might decide, I'm gonna say if
那个那个负数之间的整数。所以我决定判断

1138
00:58:42,753 --> 00:58:46,955
self is greater than 0, then I'll do this.
如果 self 大于 0，我们就用这段代码

1139
00:58:47,024 --> 00:58:52,026
Else if self is less than 0, then I'm gonna almost do this.
否则如果 self 小于 0，那代码基本不变

1140
00:58:52,095 --> 00:58:56,865
What I'm gonna do, is I'm gonna say return minus this,
我要做的就是返回负的这个

1141
00:58:56,934 --> 00:59:00,202
the absolute value of myself. Okay,
上限用 abs 取 self 的绝对值

1142
00:59:00,270 --> 00:59:04,339
abs is just a global function. But I could also just say
这个 abs 就是个全局函数，但我也可以用

1143
00:59:04,408 --> 00:59:06,675
minus self cuz I checked to see if it's negative.
-self 因为我已经知道它是负数了

1144
00:59:06,743 --> 00:59:10,345
Or else if self is 0, which would be the else case here,
否则如果是 0，也就是 else 分支

1145
00:59:10,414 --> 00:59:12,580
then maybe I'll just return 0. So if you say, 0,
就可以直接返回 0。如果你用 0.arc4random

1146
00:59:12,649 --> 00:59:15,950
give me a random number, it gives you a 0. So here I've
来获取一个随机数，它就会返回 0。这样我

1147
00:59:16,019 --> 00:59:19,887
made it that this never crashes. This doesn't have to
就保证它绝对不会让程序崩溃了，这个也不必要是

1148
00:59:19,956 --> 00:59:23,825
be an optional int and it gives a reasonable response.
可选的整数，同时返回的也是合理的结果

1149
00:59:23,894 --> 00:59:26,995
See, and that's pretty good. When you add vars and
看，这挺不错的。当你添加变量

1150
00:59:27,063 --> 00:59:30,632
functions to any class, not even just extensions,
或者函数到任何类型的时候，不只是在扩展里

1151
00:59:30,700 --> 00:59:34,302
you want them to have good semantics, sensible semantics.
你应该让他们有好的，合理的语义

1152
00:59:34,371 --> 00:59:36,905
And you don't generally don't want them to crash which is
而且一般你也不希望它容易让程序崩溃

1153
00:59:36,974 --> 00:59:38,607
what this would have done otherwise.
也就是我们之前一行代码的实现

1154
00:59:38,675 --> 00:59:40,942
If you sent it to -3.
比如你通过 -3 访问的话

1155
00:59:41,011 --> 00:59:45,346
Everyone see how this makes our code a lot more readable.
大家看到扩展让我们的程序更加易读了吗？

1156
00:59:45,415 --> 00:59:48,083
And how we added something that was sensible for int.
以及我们是如何给 Int 添加了合理的功能？

1157
00:59:49,953 --> 00:59:53,755
All right, that's it, let's get back to our slides again.
好，这就是扩展，让我们继续讲幻灯片

1158
00:59:55,659 --> 00:59:58,960
Here is arc4random. Okay, optionals,
这是我们刚讲的 arc4random，接着讲可选类型

1159
00:59:59,029 --> 01:00:03,832
the dreaded word optionals. So I told you last
听起来很吓人的 Optional。我上周

1160
01:00:03,901 --> 01:00:06,701
week that an optional is just a regular old type in Swift.
说 Optional 在 Swift 里就是个普通的类型

1161
01:00:06,770 --> 01:00:07,969
In fact it's a enum,
事实上它是个 enum

1162
01:00:08,037 --> 01:00:11,539
an enumeration. So let's learn about enum because enum is
枚举类型。我们先来学习下 enum，因为

1163
01:00:11,608 --> 01:00:13,909
another thing I wasn't able to work it into concentration,
另一个我没法加到翻牌游戏的就是枚举

1164
01:00:13,977 --> 01:00:17,045
although I am gonna work it into next week's demo. Okay,
虽然我下周的演示里会用到

1165
01:00:17,114 --> 01:00:19,981
our drawing demo. But I want to explain what it is so
我们演示绘画的程序。但我想先解释它是什么

1166
01:00:20,050 --> 01:00:22,751
that I can explain what optionals are a little better.
这样我就能更好地把可选类型解释清楚

1167
01:00:22,820 --> 01:00:25,753
So an enum is just like an enum in other languages.
enum 和其他语言的枚举类型是一样的

1168
01:00:25,822 --> 01:00:28,156
It's a data type, just like struct is a type or
就是种数据类型，就像 struct 是一种类型

1169
01:00:28,225 --> 01:00:29,824
class is a type, enum is a type.
class 也是种类型一样，enum 也是种类型

1170
01:00:29,893 --> 01:00:32,828
Exactly the same, you can use it in exactly the same places.
都是数据类型，可以在同样的地方使用

1171
01:00:32,896 --> 01:00:37,899
It's just that it has only discrete values. Here's
只不过区别就是枚举类型包含了所有不同的可能性

1172
01:00:37,968 --> 01:00:40,701
a FastFoodMenuItem enum, it can only be hamburger, fries,
枚举 FastFoodMenuItem，快餐店的菜单上只会有汉堡，薯条

1173
01:00:40,770 --> 01:00:43,471
drink, or cookie. That's it, it can't be anything else
饮料或是饼干，就这些，不能是其他任何的东西

1174
01:00:43,540 --> 01:00:45,172
besides one of those four things, so
只能是这四种中的一种

1175
01:00:45,241 --> 01:00:50,645
that's what an enum is. Enums are value types, like structs,
这就是枚举。枚举也是值类型，和结构体一样

1176
01:00:50,714 --> 01:00:55,783
they get copied as you pass them around. Now enums in
当你把它四处传递的时候会被拷贝

1177
01:00:55,852 --> 01:01:00,488
Swift little bit more powerful then your typical enum because
在 Swift 里的枚举比其他语言的枚举更厉害

1178
01:01:00,556 --> 01:01:05,026
each case can also have what's called associated data, or
因为每个 case 还能有与之关联的数据

1179
01:01:05,094 --> 01:01:08,296
an associated value. So in my fast food item one my
叫作关联值。比如我 FastFoodMenuItem 里的

1180
01:01:08,365 --> 01:01:10,565
hamburgers have the number of patties,
hamburger 的关联值就是 numberOfPatties

1181
01:01:10,634 --> 01:01:12,400
is it a double burger or a triple or
汉堡的肉饼是双层的还是三层的还是

1182
01:01:12,469 --> 01:01:15,303
a single? The fries has the size of the fries,
只有一层？fries 的关联值是薯条的大小

1183
01:01:15,371 --> 01:01:18,773
a large fry, or a small. And I've even used another enum,
大号还是小号。这里我用了另一个枚举

1184
01:01:18,842 --> 01:01:20,842
you see down here at the bottom.
就是下面你看到的这个

1185
01:01:20,911 --> 01:01:24,245
I have another, oops, my thing work here. There it is.
我有另一个，让我把它鼠标聚焦在这里

1186
01:01:24,314 --> 01:01:29,250
This is not very good. Okay, we got it. There it is. So
这个并不是很容易操作。好，终于，就这个

1187
01:01:29,319 --> 01:01:32,153
I can use another enum there to do the size of it and
所以我可以用另一个枚举表示它的大小

1188
01:01:32,222 --> 01:01:37,058
then drink. It has two pieces of associated data.
然后 drink 的关联值是两个数据构成的

1189
01:01:37,127 --> 01:01:39,160
Okay, let's see if we can get this working for that.
让我来试试能不能好好聚焦

1190
01:01:39,229 --> 01:01:41,062
And if you look at its two pieces of associated data,
你看这关联值的两部分

1191
01:01:41,130 --> 01:01:42,097
look at the first one.
这第一个

1192
01:01:42,165 --> 01:01:45,499
That string, it has no name. These other ones have names,
那个 String 没有名字，其他的都有

1193
01:01:45,568 --> 01:01:47,969
like number of patties, size, this one has no name for
像 numberOfPatties 和 size，但饮料的第一个

1194
01:01:48,038 --> 01:01:50,705
the first one, it does have a name for the second one.
没有名字，虽然它第二个是有名字的

1195
01:01:50,774 --> 01:01:53,374
First the strings and then an int. Now the names here don't
一个是 String，一个是 Int。但这个名字并

1196
01:01:53,443 --> 01:01:56,544
matter that much because when we extract this information,
不是那么重要，因为当我们提取这个信息的时候

1197
01:01:56,613 --> 01:01:59,246
we're gonna be able to give it our own name anyway,
我们总是要给它另取一个名字的

1198
01:01:59,315 --> 01:02:02,350
kind of like tuples. In fact, these look a lot like tuples,
就像元组一样。关联值其实和元组很像

1199
01:02:02,419 --> 01:02:04,552
don't they? These little associated datas,
不是吗？这些关联值

1200
01:02:04,620 --> 01:02:07,055
they're kind of like tuples because you can have as many
它们挺像元组的，因为你可以有任意数量

1201
01:02:07,124 --> 01:02:08,990
of them as you want, you specify the type,
的数据，你指定它们的类型

1202
01:02:09,059 --> 01:02:11,093
they have names, they're super simple, and
它们可以有名字，非常简单

1203
01:02:11,161 --> 01:02:14,095
they look very much like tuples. So, anyway,
看起来和元组很像。所以

1204
01:02:14,164 --> 01:02:16,697
so this is what it looks like to declare an enum with
这就是声明带有关联值的枚举

1205
01:02:16,766 --> 01:02:20,334
associated data. Now, how do you assign an enum?
的方法。那你怎么赋值一个枚举呢？

1206
01:02:20,403 --> 01:02:23,071
So here is two variables, one called menu item,
这里有两个变量，一个是 menuItem

1207
01:02:23,140 --> 01:02:25,840
one called other item. They are of type FastFoodMenuItem,
另一个叫 otherItem，都是 FastFoodMenuItem

1208
01:02:25,909 --> 01:02:28,876
that's their type. And so I set them just by saying
这是它们的类型。然后我给它们赋值就用

1209
01:02:28,945 --> 01:02:31,779
FastFoodMenuItem dot the case I want.
FastFoodMenuItem.我想要的 case

1210
01:02:31,848 --> 01:02:37,118
And if it has associated data, I have to provide it.
如果那种情况有关联值，那我也需要相应地提供

1211
01:02:37,187 --> 01:02:42,057
So the only time you can set the associated data of an enum
唯一我能指定枚举的关联值的时候

1212
01:02:42,125 --> 01:02:45,226
is when you assign it. That's the only time. Okay,
就是在赋值的时候，这是唯一一次机会

1213
01:02:45,294 --> 01:02:48,062
you can't go back later and change this to be a triple,
你不能之后又回来然后把双层汉堡改成三层的

1214
01:02:48,131 --> 01:02:51,032
because this is fundamentally a double burger.
因为它已经就是个双层汉堡了

1215
01:02:51,101 --> 01:02:53,634
That's what it is. And it's never, if it changed, it would
它就是它，不会再变了。如果关联值发生了改变

1216
01:02:53,703 --> 01:02:56,871
change into a completely different thing. All right, so
它就会变成一个完全不同的东西。好

1217
01:02:56,940 --> 01:03:01,008
you don't change the patties, got that? All right, so, when
所以你不能更改关联值，知道了吗？好

1218
01:03:01,077 --> 01:03:04,980
you're setting these values by the way of course you can use
当你在设置这些值的时候，当然你可以用

1219
01:03:05,048 --> 01:03:08,683
type inference, but only on one side of that equals. So
类型推导，但只能在等号的某一侧使用

1220
01:03:08,752 --> 01:03:12,354
you could say menuItem equals FastFoodMenuItem.hamburger.
你可以说 menuItem = FastFoodMenuItem.hamburger

1221
01:03:12,422 --> 01:03:15,089
Which was what was on the previous slide, or
也就是和之前那页一样的写法，或者

1222
01:03:15,158 --> 01:03:18,626
you could say otherItem of type FastFoodMenuItem equals
说 FastFoodMenuItem 类型的 otherItem

1223
01:03:18,695 --> 01:03:19,727
.cookie. You see,
是 .cookie。看

1224
01:03:19,796 --> 01:03:21,996
I've just basically moved the type to the other side. But
我基本上就是把类型移到了另一边

1225
01:03:22,065 --> 01:03:25,966
you can't say yet another item equals .cookie. Swift doesn't
但你不能说 otherItem = .cookie，因为 Swift 没有

1226
01:03:26,035 --> 01:03:29,337
know enough there to infer the type on the other side. There
得到足够的信息来推导等号右边是什么类型的

1227
01:03:29,406 --> 01:03:31,505
could be other enums with .cookie in it, for example,
可能有其他的枚举也有 .cookie，比如

1228
01:03:31,574 --> 01:03:33,775
that you might add later. And then all of a sudden your code
你可能之后会添加这么一个，那么立刻你的代码

1229
01:03:33,844 --> 01:03:35,309
won't compile because it doesn't know. So
就肯定编译不了了，因为 Swift 不知道选哪个

1230
01:03:35,378 --> 01:03:38,680
it just says from the start, I don't know what that is.
所以 Swift 决定从一开始就说不知道是什么类型

1231
01:03:39,783 --> 01:03:42,350
Now how do you check what an enum is?
那你要如何判断枚举是哪种情况呢？

1232
01:03:42,419 --> 01:03:44,953
You do not use equals. So you don't say,
你不用 == 判断，你不用写

1233
01:03:45,021 --> 01:03:49,523
if this menu item equals a hamburger then whatever, okay,
if menuItem == .hamburger 那就怎样怎样

1234
01:03:49,592 --> 01:03:53,328
you do not use equals, you use switch. Again, other languages
你不用 == 判断，应该用 switch。同样的，其他语言

1235
01:03:53,397 --> 01:03:56,097
have switch. Switch is more powerful in Swift.
也有 switch，但 Swift 里的 switch 更强大

1236
01:03:56,166 --> 01:03:58,900
This is the basic use of switch right here, where I'm
这里的只是 switch 的基本用法，我只是

1237
01:03:58,968 --> 01:04:02,137
just looking at every possible case that it could be, and
逐一判断了所有可能的情况

1238
01:04:02,205 --> 01:04:03,938
if it's that case, I do a little bit of code.
如果是这种情况，那我就运行这段代码

1239
01:04:04,007 --> 01:04:07,041
So here I'm just printing out what the various cases are so
这里我只是打印出了是什么情况

1240
01:04:07,110 --> 01:04:09,043
if it's hamburgers, for example,
比如如果是汉堡的话

1241
01:04:09,112 --> 01:04:11,379
you can see that I'm printing burger.
你看到我打印的就是汉堡的英文

1242
01:04:11,448 --> 01:04:14,249
Notice that I'm ignoring the associated data here which is
注意我这里忽略了关联值，这是

1243
01:04:14,317 --> 01:04:15,249
perfectly fine.
完全没问题的

1244
01:04:15,318 --> 01:04:17,886
You're allowed to completely ignore the associated data
你可以完全忽略关联值

1245
01:04:17,955 --> 01:04:21,555
when you're checking the state with switch. Now
当你用 switch 语句判断的时候是可以的

1246
01:04:21,624 --> 01:04:25,326
switch requires you to address every single case. You are not
注意 switch 语句要求你穷举所有的情况，你不能

1247
01:04:25,395 --> 01:04:28,463
allowed to look at only two of the cases. But, of course,
只是判断其中的两种，但当然

1248
01:04:28,531 --> 01:04:34,068
it's got something that can help you with that. Oh yes,
Swift 提供了帮你解决这个问题的方法

1249
01:04:34,137 --> 01:04:37,605
by the way, you see I've taken away the FastFoodMenuItem
顺便一提，你看到我把 FastFoodMenuItem 省略了

1250
01:04:37,674 --> 01:04:40,775
in front of hamburger, fries, drink, and coke. Becuase swift
只剩下 .hamburger, .fries, .drink 和 .coke

1251
01:04:40,843 --> 01:04:43,077
can infer that, you're switching on a menu item, so
因为这个 Swift 是可以推导的，你 switch 的是 menuItem

1252
01:04:43,146 --> 01:04:45,280
it knows this is a FastFoodMenuItem, so
Swift 知道那是个 FastFoodMenuItem，所以

1253
01:04:45,348 --> 01:04:49,317
you can take those away. All right, so if you have one of
你可以省略这个。好，如果你这里有个

1254
01:04:49,385 --> 01:04:52,287
the cases, and you don't wanna do anything, you can just
case 决定什么也不做，那你可以

1255
01:04:52,356 --> 01:04:55,890
break. Break means break out of this switch. So
用 break，也就是跳出 switch

1256
01:04:55,958 --> 01:04:58,626
that's a way to do nothing in this case. So, right here,
这就是什么也不做的方法。这里的这个

1257
01:04:58,694 --> 01:05:01,062
this code, we print nothing because the hamburger case,
这段代码不会打印任何内容，因为在是 .hamburger 时

1258
01:05:01,130 --> 01:05:03,698
the menu item is a hamburger with two patties, and
menuItem 是双层的汉堡

1259
01:05:03,767 --> 01:05:04,999
that hamburger case does nothing, so
是汉堡情况下的代码什么也不做

1260
01:05:05,068 --> 01:05:08,636
we'll just break out and do nothing. Similarly,
我们直接 break 跳出 switch。类似的

1261
01:05:08,705 --> 01:05:12,306
if you want to do something for all the rest of the cases,
如果你希望让剩余的情况都做某件事情

1262
01:05:12,375 --> 01:05:13,841
like here I only want to do something for
比如我只想要在是汉堡或是薯条的情况下

1263
01:05:13,910 --> 01:05:16,977
hamburger and fries. Actually I do nothing for hamburger and
做某些事情，更准确的说是汉堡我什么也不做

1264
01:05:17,046 --> 01:05:18,079
I do something for fries.
是薯条我做另外的事情

1265
01:05:18,147 --> 01:05:20,949
In all other cases, I just want to print other, then you
其他所有的情况我都打印说是其他

1266
01:05:21,017 --> 01:05:24,919
can use default instead of case whatever. Now in switch,
那你就可以用 default 来代替其他的情况。switch

1267
01:05:24,987 --> 01:05:29,424
you can switch any type, you can even switch on a string.
可以用来判断任何类型，你甚至可以 switch 字符串

1268
01:05:29,492 --> 01:05:32,426
But if you switch on a string, you'd have to have case A,
但如果你要判断 String 的话，你需要判断 case "A":

1269
01:05:32,495 --> 01:05:35,029
case B, case C, case AA, case AB, you see what I mean?
case "B", "C", "AA", "AB": 等等。知道我什么意思了吗？

1270
01:05:35,098 --> 01:05:37,165
You'd have to have every case in the world.
你需要列举所有可能存在的字符串

1271
01:05:37,234 --> 01:05:40,502
So of course you're going to use default in a string case
所以肯定你需要在 switch 字符串的时候用 default

1272
01:05:40,570 --> 01:05:41,836
switch case the couple
你 switch 里列举一些

1273
01:05:41,904 --> 01:05:45,306
ones you wanna case, then you would default the rest. So
你想要的情况，然后其他的就用 default 处理

1274
01:05:45,375 --> 01:05:50,778
default is a must. Even for enums we use it quite a bit,
所以字符串必须用 default。有的时候枚举我们也会用到

1275
01:05:50,847 --> 01:05:53,948
all right? So that's break an enum. So
听懂了吧？这就是 break 和枚举

1276
01:05:54,017 --> 01:05:58,753
if this were a cookie then it would print other. All right,
这里如果是 .cookie 的话，那就会打印 other

1277
01:05:58,822 --> 01:06:01,455
multiple lines, I just wanted to make clear that, multiple
接着是多行代码。我只是想澄清

1278
01:06:01,524 --> 01:06:03,724
lines of code are allowed, it doesn't have to be one line.
每个 case 里是可以有多行代码的，不一定只有一行

1279
01:06:03,793 --> 01:06:05,025
That was just cuz I'm on slides here,
之前只有一行是因为我在讲幻灯片

1280
01:06:05,094 --> 01:06:06,661
I'm trying to make everything fit, and
我希望能装下所有的内容

1281
01:06:06,730 --> 01:06:10,265
there's no fall through. So in this case, I've got fries,
还有，每个 case 并不会贯穿到下一个，比如这里

1282
01:06:10,333 --> 01:06:12,166
you see up there at the top, fries,
你看上面的 .fries

1283
01:06:12,234 --> 01:06:13,701
large fries there. And
它是 .large，大号的薯条

1284
01:06:13,770 --> 01:06:18,039
so this code would print out yummy fires and that's it. So
所以这段代码会打印 yummy fries，然后就完了

1285
01:06:18,107 --> 01:06:20,007
I have multiple lines of code in there under fries,
我 .fries 的 case 里有多行代码

1286
01:06:20,076 --> 01:06:22,977
two lines of code, and it does not fall through and do drink,
两行代码，而且它也不会贯穿到 .drink 里去

1287
01:06:23,046 --> 01:06:26,080
like in other languages. In C, things fall through, in switch
像 C 这些其他语言就会贯穿到 .drink

1288
01:06:26,149 --> 01:06:28,116
but they don't fall through here. There is a keyword
Swift 里并不会。但有一个关键字

1289
01:06:28,184 --> 01:06:30,585
called fallthrough that would let you fall through, but
叫 fallthrough 可以让你贯穿到下一个 case

1290
01:06:30,653 --> 01:06:36,591
by default it doesn't. By the way, the same way that it inferred
但默认是不会的。顺便一提，就像推导

1291
01:06:36,660 --> 01:06:40,561
the type all along in here, it can for that type as well.
switch 里每个 case 的类型一样，Swift 也推到了它的类型

1292
01:06:40,630 --> 01:06:45,066
I don't have to say size,fries size enum.large,
我并不需要用 size: FryOrderSize.large

1293
01:06:45,135 --> 01:06:47,902
I can just say, .large because it knows that the associated
我可以直接用 .large，因为 Swift 知道薯条的

1294
01:06:47,971 --> 01:06:53,274
data of fries is s fries size enum. Okay,
关联值是 FryOrderSize 这个枚举

1295
01:06:53,342 --> 01:06:57,778
now, what if I want to get the associated data. So I do,
那如果我现在想要得到关联值怎么办呢？

1296
01:06:57,847 --> 01:07:00,815
I am interested in it. We do that with switch as well,
我很感兴趣。这个我们也可以用 switch

1297
01:07:00,883 --> 01:07:05,319
we just do this little let business. See the little lets.
我们只需要加上些 let，看到这里的 let 了吗？

1298
01:07:05,388 --> 01:07:07,789
In all the cases that you want this associated data,
对于所有你想要关联值的 case

1299
01:07:07,858 --> 01:07:09,190
you don't have to do it in all cases, but
你并不需要每个 case 都这样做

1300
01:07:09,258 --> 01:07:11,326
in the ones you want it? You just say, open parentheses,
但对于你想要的，你在括号里面就用

1301
01:07:11,394 --> 01:07:15,229
let and a name of a little local variable for
let 和你给关联值取得作为本地变量的名字

1302
01:07:15,298 --> 01:07:18,265
each of the associated pieces of data. Now,
对于每个关联值都这样做

1303
01:07:18,334 --> 01:07:21,702
that little name that you use, so if this were a coke see it
现在你就可以使用那个名字了。比如这里是可乐的话

1304
01:07:21,771 --> 01:07:25,306
would print whatever ounces coke right there, cuz just
那就会打印出有多少盎司的可乐。因为它把

1305
01:07:25,374 --> 01:07:28,409
getting the Coke into brand. It's getting the ounces into
brand 赋值为 "Coke"，把 ounces 赋值为

1306
01:07:28,477 --> 01:07:31,145
something called ounces, and then it's doing that print.
有多少升，然后执行那条 print 语句

1307
01:07:31,214 --> 01:07:35,716
This naming does not have to be the same names
这里的不一定非要用同样的命名

1308
01:07:35,785 --> 01:07:38,419
as you declared the enum from. In fact,
可以和枚举定义时不一样。事实上

1309
01:07:38,487 --> 01:07:42,723
if we look at this Coke one right here, this let brand,
如果我们看到刚才的可乐，这里用 let brand

1310
01:07:42,792 --> 01:07:45,827
remember in the original enum that didn't even have a name,
但我们原本的枚举是甚至是没有给它名字的

1311
01:07:45,896 --> 01:07:48,929
it was just a string, right? And it had ounces,
只说了它是 String 类型，好吧？但 ounces 是有的

1312
01:07:48,998 --> 01:07:52,399
colon ounces, and up here with hamburger, pattyCount,
ounces: Int。上面 hamburger 的 pattyCount

1313
01:07:52,468 --> 01:07:56,837
that was called patties in the original declaration. So
那个本来的定义里叫 numberOfPatties

1314
01:07:56,906 --> 01:08:00,641
again, does this not look familiar to tuples, right?
你们不觉得这个和元组很像吗？

1315
01:08:00,710 --> 01:08:03,878
You can rename them when you're getting the information
当你从其中获取数据的时候可以重命名

1316
01:08:03,946 --> 01:08:07,549
out of them. So this is how you extract data
所以这就是你怎么获得

1317
01:08:07,617 --> 01:08:11,953
out of the associated types. Very simple, and
关联值里的数据，非常简单

1318
01:08:12,022 --> 01:08:14,756
again it's optional you don't have to have it there.
再次说一下这个不是必须的，你不一定非要有关联值

1319
01:08:15,992 --> 01:08:19,126
Also enums, they're like structs and classes.
然后枚举与类和结构体一样

1320
01:08:19,195 --> 01:08:23,431
They can have methods and they can have vars, but no storage.
它们可以有方法，也可以有变量，但是没有存储空间

1321
01:08:23,500 --> 01:08:26,600
All the storage of an enum is in which case it is and
枚举的存储空间是只包含属于哪个 case

1322
01:08:26,669 --> 01:08:28,035
that case's associated data.
和那个 case 的关联值

1323
01:08:28,104 --> 01:08:30,872
That's it, you can't have many other vars or anything else.
就这些，你不能有其他的变量

1324
01:08:30,940 --> 01:08:34,275
So the only vars you could have are computed vars.
所以你能有的变量都是计算变量

1325
01:08:34,344 --> 01:08:37,245
So see the example I have here where it's calories,
比如你看我这里的例子，卡路里

1326
01:08:37,313 --> 01:08:40,148
where you'd compute the calories of that menu item
你会计算那个菜单项的卡路里

1327
01:08:40,216 --> 01:08:43,618
that would have to be a computed type. Can't store
那必须要是计算属性。枚举不能

1328
01:08:43,686 --> 01:08:47,422
anything in an enum except for the associated data right
存储任何内容，唯一的是可以有像这里的关联值

1329
01:08:47,490 --> 01:08:50,291
there. Now if you're writing a func like this one,
如果你在写一个像这样的方法

1330
01:08:50,360 --> 01:08:53,495
isIncludedInSpecialOrder number one or number two or
isIncludedInSpecialOrder，number 是 1、2 等

1331
01:08:53,563 --> 01:08:56,164
whatever. If you're doing that, then you can
如果你要这样做的话，那你可以

1332
01:08:56,232 --> 01:09:01,336
get your own associated data using switch on self.
通过 switch self 来获取自己的关联值

1333
01:09:01,404 --> 01:09:03,972
Cuz I'm inside the enum implementation here, right?
因为我还在 enum 实现的内部

1334
01:09:04,040 --> 01:09:05,573
So I can switch on self, and then,
所以我可以对 self 进行 switch，然后

1335
01:09:05,642 --> 01:09:07,241
I could get my associated data out so
我能够得到个关联值

1336
01:09:07,310 --> 01:09:08,743
I can calculate my calories. Or
然后我就可以计算卡路里了

1337
01:09:08,811 --> 01:09:11,445
in this case, I'm calculating whether the hamburger with
这里我在判断一个汉堡

1338
01:09:11,514 --> 01:09:14,015
two patties is included in special order number two.
有两个肉饼的话是不是二号套餐

1339
01:09:14,084 --> 01:09:17,285
And my code here says yes because pretty much,
而我的代码会说“是的”，因为这里说

1340
01:09:17,353 --> 01:09:19,120
special order number one is a single burger,
一号套餐是单层汉堡

1341
01:09:19,189 --> 01:09:21,789
and/or number two is a double. Now there's some other
二号套餐就是双层的。现在还有些其他

1342
01:09:21,858 --> 01:09:24,358
interesting things to look at in this code. Notice that
有趣的地方。注意这里的代码

1343
01:09:24,427 --> 01:09:27,629
fries and cookie right there. Right in the middle, fries and
薯条和饼干，中间的 .fries 和 .cookie

1344
01:09:27,697 --> 01:09:31,565
cookie. Those I combine them into one case,
我把这两个合并为了同一个 case

1345
01:09:31,634 --> 01:09:34,468
which that's allowed with commas you can have multiple
这是可以的，你可以用英文逗号分隔多个

1346
01:09:34,537 --> 01:09:38,206
going on there. Also noticing drink, okay, I'm
不同的情况。同时看这个 .drink

1347
01:09:38,274 --> 01:09:41,042
getting the number of ounces in a drink but evidently in
我们知道了饮料有多少盎司。显然

1348
01:09:41,110 --> 01:09:44,145
a special order you can have any drink that's 16 ounces.
套餐里所有的饮料都是 16 盎司的

1349
01:09:44,214 --> 01:09:47,314
So I don't care what kind of drink it is, I don't care for
所以我并不在乎是什么种类的饮料，我不在意

1350
01:09:47,383 --> 01:09:51,152
that brand. So I use the universal i don't care symbol
brand 是什么，所以我就用了通用的“我不关心它”这个符号

1351
01:09:51,221 --> 01:09:54,722
in Swift which is under bar, right? Remember, we used
也就是 Swift 里的英文下划线 _，对吧？记得我们

1352
01:09:54,791 --> 01:09:58,359
underbar when we didn't care what the external name in
在不想要 touchCard 的实参标签时用下划线代替

1353
01:09:58,427 --> 01:10:01,662
touch card was. We used it in a for loop when we didn't
Concentration 在 for 循环里使用下划线

1354
01:10:01,731 --> 01:10:04,065
care what the identifier was anymore in concentration,
表示并不在意那个循环变量是多少

1355
01:10:04,134 --> 01:10:07,535
so we can use it here as well, all right?
所以我们这里也可以用，好吧？

1356
01:10:09,239 --> 01:10:14,074
You can modify self in an enum as long as it's in a var. If
你在枚举里是可以改变 self 的，当然它得是个 var

1357
01:10:14,143 --> 01:10:17,845
it's modifiable, you just say self equals some other case.
如果是可变的，你就说 self = 某个其他的 case

1358
01:10:17,914 --> 01:10:19,847
And if that other case requires associated data,
如果那个其他的 case 有关联值

1359
01:10:19,915 --> 01:10:23,083
you'll have to provide it then, you can say self equals.
你同时把它们也初始化了，这样你就可以用 self = 来改变了

1360
01:10:23,152 --> 01:10:25,720
Now, a very important thing to notice here, if you're going
这里有个要注意的，非常重要的是，如果你要

1361
01:10:25,789 --> 01:10:28,890
to modify yourself in an enum by saying self equals,
通过 self = 来更改枚举的话

1362
01:10:28,959 --> 01:10:30,357
that's the only way to modify yourself,
顺便说这是唯一的方法

1363
01:10:30,426 --> 01:10:34,195
by the way. Then you have to put mutating
你必须要用 mutating

1364
01:10:34,264 --> 01:10:37,197
in front of the function that mutates you,
修饰这个改变你的方法

1365
01:10:37,266 --> 01:10:38,566
that modifies self.
修饰这个更改 self 的方法

1366
01:10:38,634 --> 01:10:43,304
That's because fast enum is a value type and
这是因为枚举是值类型

1367
01:10:43,372 --> 01:10:46,073
remember the value types are passed around by copying but
值类型是通过拷贝传递的

1368
01:10:46,142 --> 01:10:49,810
there is copy on write. Swift does copy on write which
不过我们有写时复制。Swift 的写时复制意味着

1369
01:10:49,879 --> 01:10:52,546
means it doesn't actually make a copy until you write.
它在你改写之前并不会进行拷贝

1370
01:10:52,615 --> 01:10:53,615
Well if it's gonna do that,
为了能实现这个功能

1371
01:10:53,683 --> 01:10:58,519
it needs to know which funcs might write. So
Swift 需要知道哪些函数是会写数据的

1372
01:10:58,588 --> 01:11:01,388
that's what mutating means, it means this func might write,
这就是 mutating 的意思，表示这个函数可能会写数据

1373
01:11:01,457 --> 01:11:05,025
it might change this. You have to do exactly the same thing
可能会更改 self。在结构体里，你也要做同样的事情

1374
01:11:05,094 --> 01:11:08,996
in a struct. If you have a func in a struct, and
如果你的结构体里有个方法

1375
01:11:09,064 --> 01:11:10,965
it modifies any internal state of
它更改了任意一个结构体的内部状态

1376
01:11:11,033 --> 01:11:13,100
the struct, it has to be marked mutating, so
那它就必须被标为 mutating

1377
01:11:13,169 --> 01:11:16,370
the Swift knows to copy and write. And not to worry, Swift
这样 Swift 就能够写时复制了。不用担心，Swift

1378
01:11:16,439 --> 01:11:19,440
is super smart, it'll see your code, it'll see you're saying
很聪明，它会看你的代码，如果发现你说

1379
01:11:19,508 --> 01:11:22,142
self equal, it'll see that you're modifying your var in
self = 的话，它就知道你在更改结构体

1380
01:11:22,211 --> 01:11:26,046
a struct And it will complain and say this is protected you
里的变量，然后就给你抱怨说 self 是被保护的

1381
01:11:26,115 --> 01:11:29,183
can't write to this thing coz this is not a mutating func.
你不能更改这个内容，因为这个函数不是 mutating 的

1382
01:11:29,251 --> 01:11:31,418
And you can fix it by making it mutating and
你只要把它改成 mutating 就可以了

1383
01:11:31,487 --> 01:11:34,555
in fact you can see that concentration demo in a second
其实我们等会儿会用 Concentration 来演示下

1384
01:11:34,624 --> 01:11:37,758
here. All right so that's it for enums, very simple.
好，这就是枚举，很简单

1385
01:11:37,826 --> 01:11:41,562
So an optional then is just an enum, it looks like this,
所以其实可选类型，就是个枚举，看起来是这样的

1386
01:11:41,631 --> 01:11:44,398
kind of, conceptually. It's an optional,
概念上就是这样的。这就是 Optional

1387
01:11:44,467 --> 01:11:47,435
it's a generic type like array is. Array can have anything in
和 Array 一样的泛型。数组可以存储任何类型的元素

1388
01:11:47,504 --> 01:11:49,103
it, an optional can be an optional Int,
Optional 可以是可选的 Int

1389
01:11:49,172 --> 01:11:51,739
an optional string, whatever it's a generic type. And
可选的 String，等等，因为它是个泛型

1390
01:11:51,808 --> 01:11:53,941
it has two cases in the enum,
这个枚举有两种情况

1391
01:11:54,009 --> 01:11:58,713
the case none which is not set, nil, and the other case
case none 就是没有值，nil；另一个是 case some

1392
01:11:58,781 --> 01:12:01,782
some in which it has some associated data of that type.
它会有相应的关联值

1393
01:12:01,851 --> 01:12:04,352
So an optional int that would mean int, so that's it,
比如可选 Int 的关联值就是 Int。就是这样

1394
01:12:04,420 --> 01:12:07,588
that's what an optional is. Now an optional, Why don't,
这就是个可选类型。那我们为什么不能

1395
01:12:07,657 --> 01:12:09,190
why didn't we just leave it in enum?
就让可选作为枚举就行了呢？

1396
01:12:09,259 --> 01:12:10,624
Well, God, can you imagine,
哇哦，天呐，你想像一下

1397
01:12:10,693 --> 01:12:13,360
every time you wanna unwrap an optional, you're having to
每次你要解包可选类型的时候，你都要

1398
01:12:13,429 --> 01:12:16,029
switch on that thing in case some get the associated data?
用 switch 来判断是哪个 case，然后再得到关联值？

1399
01:12:16,098 --> 01:12:18,866
That would be so much typing. So all of these special
那我们得写很多代码。所以所有这些特殊的

1400
01:12:18,935 --> 01:12:21,135
characters we have are optionals, question marks,
字符，在可选类型上使用的问号

1401
01:12:21,204 --> 01:12:23,470
exclamation points, ifs, double question marks.
感叹号，if 的语法，?? 提供默认值等

1402
01:12:23,539 --> 01:12:26,674
All that stuff is just so that we don't have to be constantly
这些都是为了让我们不需要总是

1403
01:12:26,743 --> 01:12:29,877
switching on our optional and doing case this, case that.
用 switch 来判断可选类型然后 case 这个 case 那个的

1404
01:12:29,945 --> 01:12:31,812
But that's all it's doing under the covers,
但这就是它内部的实现

1405
01:12:31,881 --> 01:12:33,781
it's just syntactic sugar that is doing that.
这些都只是完成这些操作的语法糖

1406
01:12:33,850 --> 01:12:35,382
It's not doing anything else,
并没有干其他什么的

1407
01:12:35,451 --> 01:12:39,019
it's not, nothing special. And so I'm gonna show you what all
就是这样，没什么特别的。让我来给你们看看

1408
01:12:39,088 --> 01:12:42,189
these special characters look like in enum land.
用枚举而不是这些特殊字符会是什么样的

1409
01:12:42,258 --> 01:12:44,759
And, and I'm even gonna show you a new enum or
同时我还要给你展示个新的和枚举

1410
01:12:44,827 --> 01:12:47,428
a new optional thing, which is this thing at the bottom
和可选类型相关的东西，就是最底下这个

1411
01:12:47,497 --> 01:12:50,497
called optional chaining. And it's where you use a single
叫做可选链接（optional chaining）的。你可以用一个

1412
01:12:50,566 --> 01:12:52,900
question mark when you're accessing an optional.
问号来访问可选类型

1413
01:12:52,969 --> 01:12:55,436
Which that's the one thing we have not seen, and I'm gonna
这个是我们还没有见到的，这个我也会

1414
01:12:55,505 --> 01:12:57,605
show you how that works by showing you in enum land.
展示给你们看用枚举实现会是什么样的

1415
01:12:57,673 --> 01:13:02,477
All right? So, declaring optionals, obvious, right?
好吧？好，声明一个可选类型，很简单，对吧？

1416
01:13:02,545 --> 01:13:04,412
If I say hello, which is an optional string,
如果是 "hello"，那就是可选的字符串

1417
01:13:04,481 --> 01:13:08,181
that's just optional angle brackets string. And
那就是 Optional<String>

1418
01:13:08,250 --> 01:13:11,485
remember that optionals always start out nil. So, I'm gonna,
然后记住可选类型默认值为 nil，所以我要

1419
01:13:11,554 --> 01:13:15,990
it's gonna start out none. Couldn't be simpler.
让其他的刚开始都是 .none，很简单

1420
01:13:16,059 --> 01:13:18,959
Unwrapping, also very simple, that's just switching
解包，也很简单，我就 switch

1421
01:13:19,028 --> 01:13:22,063
on the thing. So, if I have an optional string hello, and I
这个东西。如果我有个可选的字符串 hello，那我就

1422
01:13:22,131 --> 01:13:25,366
say print(hello!), exclamation point to unwrap it,
print(hello!)，感叹号强制解包

1423
01:13:25,435 --> 01:13:27,834
I'm just switching on hello. And if it's in the none case,
我就用 switch 判断 hello。如果是 .none 的情况的话

1424
01:13:27,903 --> 01:13:30,438
I crash. And if it's in the some case,
我就让程序崩溃。如果是 .some 的情况

1425
01:13:30,506 --> 01:13:33,240
then I print whatever the associated data is. Same thing
我就让它打印这个关联值。同样的

1426
01:13:33,309 --> 01:13:36,577
done with if let at the bottom there. I'm switching on hello.
下面的 if-let 也是这样。我 switch hello

1427
01:13:36,645 --> 01:13:38,445
If it's in the some case, I do it.
如果是 .some 的情况，我就执行它

1428
01:13:38,514 --> 01:13:39,413
If it's in the none case,
如果是 .none 的情况

1429
01:13:39,481 --> 01:13:44,619
I do the else part of the if. Everybody got that?
我就执行 else 里面的代码。大家都还听得懂吧？

1430
01:13:44,687 --> 01:13:47,188
Implicitly unwrapped optionals are exactly the same. It's
隐式解析的可选类型也是这样

1431
01:13:47,256 --> 01:13:49,956
just that when I say print hello over here on this side,
只不过我这边 print(hello) 的时候

1432
01:13:50,025 --> 01:13:53,193
this print hello, I don't have to put the exclamation point.
这个 print(hello) 我不需要加感叹

1433
01:13:53,262 --> 01:13:57,731
And it still switches on hello and crashes if it's none. So
它还是 switch 判断，是 .none 就崩溃

1434
01:13:57,800 --> 01:14:01,168
that's implicitly unwrapped. Those start out as nil too
这就是隐式解析。他们也默认是 nil

1435
01:14:01,236 --> 01:14:04,105
because they're just optionals. The nil-coalescing
毕竟它们也只是可选类型。空值合并（nil-coalescing）

1436
01:14:04,173 --> 01:14:06,340
operator, which is that defaulting thing we used,
运算符，我们使用过这个 ?? 来提供默认值

1437
01:14:06,409 --> 01:14:09,076
if you remember, in our code. We looked in our emoji
如果你还记得我们的代码的话。我们查找 emoji

1438
01:14:09,145 --> 01:14:11,245
dictionary, and if it wasn't there,
字典，如果里面没有的话

1439
01:14:11,313 --> 01:14:14,081
then we returned question mark. That's just
我们就返回个问号，这其实就是

1440
01:14:14,150 --> 01:14:16,918
switching on it. And if it's in the case none, then it uses
switch 判断，如果是 .none 的话，就用

1441
01:14:16,986 --> 01:14:19,386
the default, okay, the thing on the other side. And
默认值，?? 右边的那个

1442
01:14:19,455 --> 01:14:24,125
if it's in the case some, then it uses the thing it found.
如果是 .some 的情况，那就用关联值

1443
01:14:24,193 --> 01:14:27,861
This is optional chaining. So optional chaining, imagine
然后这个是可选链接（optional chaining）

1444
01:14:27,930 --> 01:14:31,065
right here, okay, if you look at this little let x equal,
你看这里，你看这个 let x =

1445
01:14:31,134 --> 01:14:34,635
imagine that x and the method foo and
假设 x 有 foo 这个方法（的返回值）

1446
01:14:34,704 --> 01:14:39,040
the var bar, all three of those, imagine those return
有 bar 这个变量。假设这三个都返回

1447
01:14:39,108 --> 01:14:42,476
an optional string. Okay, so we don't know what they do,
可选类型的字符串。我们不知道具体是干什么的

1448
01:14:42,545 --> 01:14:43,878
but they return an optional string.
但它们都是可选类型的字符串

1449
01:14:43,946 --> 01:14:46,913
They may or may not return nil. Okay, well, what optional
可能会，也可能不会返回 nil。好，其实

1450
01:14:46,982 --> 01:14:49,350
chaining there allows us to do is to call those thing,
可选链接让我们能够调用这些

1451
01:14:49,418 --> 01:14:50,985
things in sequence called one. And
只用一串代码。先调用一个

1452
01:14:51,053 --> 01:14:53,320
then when we get the value, call the next thing on that.
得到了返回值之后，再调用第二个

1453
01:14:53,389 --> 01:14:55,523
And we get the value, call the next thing on that. And
我们得到了之后，再调用下一个

1454
01:14:55,591 --> 01:14:58,525
if at any time any of those things is nil, we just bail
如果其中任何一个环节返回了 nil，我们就马上结束

1455
01:14:58,594 --> 01:15:02,796
out and return nil. So the way that works in optional land is
然后返回 nil。而这用 Optional 枚举写就是

1456
01:15:02,865 --> 01:15:06,634
we switch on that first. If it's none, we return nil.
我们 switch 判断第一个，如果是 .none 就返回 nil

1457
01:15:06,703 --> 01:15:09,637
But if it's not, we get the data and call foo.
如果不是的话，我们就那关联值调用 foo

1458
01:15:09,705 --> 01:15:12,139
If that works, we get the, that data from foo, and
如果可行的话，我们从 foo 得到数据

1459
01:15:12,208 --> 01:15:14,475
we call bar. And then eventually,
我们调用 bar。最终

1460
01:15:14,543 --> 01:15:17,311
we set y equal to z that comes out of that, right?
我们把 y 赋值为结果 z，好吧？

1461
01:15:17,380 --> 01:15:20,581
We're just moving across the chain. If, at any time,
我们只是沿着链条走。如果任何时候

1462
01:15:20,649 --> 01:15:22,883
any of those things is nil, look at all the case nones.
其中任何一个是 nil 的话，你看看这些 case .none

1463
01:15:22,951 --> 01:15:25,486
Case .none, case .none, case .none, y gets to be nil, and
case .none, case .none, case .none，y 都是 nil

1464
01:15:25,554 --> 01:15:28,322
we're done and move along. Okay, so that's optional
然后就完成了，接着执行下一条。好，这就是可选链接

1465
01:15:28,390 --> 01:15:32,493
chaining. I made it optional, no pun intended, for
我让你可选，这并不是双关，你可以

1466
01:15:32,561 --> 01:15:35,462
you to read about that in your current assignment.
选择在现在的作业里阅读这个部分

1467
01:15:35,531 --> 01:15:38,532
I recommend you do because you can make really beautiful code
我建议你读一读，因为你能写出优雅的代码

1468
01:15:38,601 --> 01:15:41,835
using optional chaining. It's really nice.
可选链接非常的好用

1469
01:15:41,904 --> 01:15:46,273
Okay, so we're gonna finish up today with a little review and
好，我们今天最后来复习

1470
01:15:46,342 --> 01:15:49,910
a look forward to the data structures to use to build
然后预习下写 Swift 程序用到的

1471
01:15:49,979 --> 01:15:54,548
an app in Swift. These are the four, class,
数据结构一共有四个，类

1472
01:15:54,616 --> 01:15:57,451
struct, enum, and protocol. Protocol is the new one that
结构体、枚举、和协议（protocol）。协议是个新的内容

1473
01:15:57,519 --> 01:16:01,055
I'm gonna talk about starting on Wednesday. So a class,
这个我周三会讲。所以，一个类

1474
01:16:01,124 --> 01:16:04,458
as we know, supports an object-oriented design.
我们知道，支持面向对象的设计

1475
01:16:04,526 --> 01:16:07,060
It has single inheritance of both functionality and data.
它是单一继承功能和数据

1476
01:16:07,129 --> 01:16:09,563
You inherit the data, your vars.
你继承了所有的数据，变量

1477
01:16:09,632 --> 01:16:13,667
Stored vars get inherited, um, as well as all your methods
继承了存储变量，同时还有方法

1478
01:16:13,736 --> 01:16:17,939
and stuff. It's a reference type, lives in the heap.
这些。它是引用类型，存在堆里

1479
01:16:18,007 --> 01:16:20,073
Now one thing we didn't talk about, though,
但我们又一个没有讲的是

1480
01:16:20,142 --> 01:16:23,510
this class lives in the heap. When does it get cleaned up
这些类都在堆里，但它什么时候被释放

1481
01:16:23,579 --> 01:16:28,048
out of the heap? And how does that happen? Okay, so yeah, so
离开堆呢？那是怎么发生的呢？是的

1482
01:16:28,117 --> 01:16:30,016
if, people who are coming from Java, you're probably like,
学过 Java 的人，多半会想

1483
01:16:30,085 --> 01:16:32,919
oh, garbage collection maybe? Okay, um, but no, okay,
哦，大概就是 Garbage Collection？其实不是

1484
01:16:32,988 --> 01:16:35,722
Swift does not use garbage collection.
Swift 不用垃圾回收

1485
01:16:35,791 --> 01:16:40,528
It uses a very awesome system called reference counting. And
它采用的是个很棒的引用计数系统，更准确的说是

1486
01:16:40,596 --> 01:16:42,329
in fact, it's automatic reference counting,
自动引用计数（Automatic Reference Counting，ARC）

1487
01:16:42,397 --> 01:16:44,965
it's all handled for you. So how does reference counting
它会帮你把一切都处理了。那引用计数是怎么回事呢？

1488
01:16:45,034 --> 01:16:47,434
work? Okay, we need to talk a little bit about that.
这个我们需要讲一讲

1489
01:16:47,503 --> 01:16:51,739
So let's take a little detour here. By the way, examples of
让我们来讲讲这个题外话。顺便一提

1490
01:16:51,807 --> 01:16:54,809
classes that we've seen of course are UI view controller,
我们看到的类的例子是 UIViewController

1491
01:16:54,877 --> 01:16:57,845
view controller, which is our subclass of it, UI button,
我们 ViewController 是继承它的子类，UIButton

1492
01:16:57,914 --> 01:17:00,614
UI label, concentration, we made that a class. Those
UILabel，我们自己写的 Concentration。这些

1493
01:17:00,682 --> 01:17:03,150
are all classes, not structs, right? All right, so let's
都是类，不是结构体，好吧？好，让我们

1494
01:17:03,219 --> 01:17:05,786
talk about how this automatic reference counting thing
来讲讲自动引用计数是怎么工作的

1495
01:17:05,854 --> 01:17:09,389
works. It's really simple, every time, somehow magically,
它其实非常简单。每次，很神奇的

1496
01:17:09,458 --> 01:17:13,227
every time that you create a pointer to a reference type in
每次你创建一个到堆里引用类型的指针

1497
01:17:13,295 --> 01:17:17,665
the heap, Swift adds one to some counter somewhere. And
Swift 就会把某处的计数器加一

1498
01:17:17,733 --> 01:17:22,035
every time that pointer to it goes out of scope or
每当有指针的作用域结束了

1499
01:17:22,104 --> 01:17:24,371
is not pointed to it anymore, like it was an optional,
或者不再指向某个对象的时候，就好像可选类型

1500
01:17:24,440 --> 01:17:26,072
it got set to nil, for example,
变为 nil 了一样，打个比方就是这样

1501
01:17:26,141 --> 01:17:29,676
then it decrements that count. And when that count goes to 0,
Swift 就会把记录减一。当这个数变为 0 之后

1502
01:17:29,745 --> 01:17:32,580
it takes it out of the heap instantly. It's not like
它马上就会离开堆。并不像是

1503
01:17:32,648 --> 01:17:34,614
it's keeping track, and it's doing any marking and
它会去监视，然后做标记

1504
01:17:34,683 --> 01:17:37,250
sweeping, like a garbage collection. It actually
换内存，并不会像 GC 这样做。它其实会

1505
01:17:37,319 --> 01:17:40,453
instantly removes it as soon as no one points to it. So
只要没人指向它就立刻把它移除

1506
01:17:40,522 --> 01:17:42,689
it couldn't be simpler, it's exact way you would think,
不能再简单了，和你预想的一样

1507
01:17:42,758 --> 01:17:44,291
conceptually, to make it work.
概念上它就是这样的

1508
01:17:44,360 --> 01:17:47,861
It's actually quite difficult under the covers to do that.
其实它背后的实现还挺复杂的

1509
01:17:47,930 --> 01:17:50,097
Swift was designed with it in mind from start.
Swift 从一开始设计的时候就考虑到了 ARC

1510
01:17:50,165 --> 01:17:55,069
So it's an awesome system. You can influence
这是个很好的系统。你是可以稍微影响

1511
01:17:55,138 --> 01:17:57,104
this automatic reference counting a little bit.
自动引用计数的过程的

1512
01:17:57,172 --> 01:17:59,807
You can't really control it, but you can influence,
你并不能控制它，但你可以影响它

1513
01:17:59,875 --> 01:18:02,409
with these three key words when you declare a var,
在声明变量的时候用这三个关键字中的一个

1514
01:18:02,477 --> 01:18:04,612
okay, a strong, weak, and unowned.
分别是 strong、weak 和 unowned

1515
01:18:04,680 --> 01:18:08,081
These are the three kind of influencers you can do.
这是你能影响它的三种方式

1516
01:18:08,150 --> 01:18:11,151
The first one, strong, is normal reference counting.
第一个 strong 是普通的引用计数

1517
01:18:11,220 --> 01:18:15,522
So that just means if there's a, this pointer is strong, and
意思就是，这是一个强引用的指针

1518
01:18:15,590 --> 01:18:19,025
so keep that thing in the heap as long as this is around,
只要我这个变量还在就把那个对象留在堆里

1519
01:18:19,094 --> 01:18:20,794
because I need it, I'm pointing to it.
因为我指向了它，我还需要它

1520
01:18:20,863 --> 01:18:21,795
That's the default.
这是默认的行为

1521
01:18:21,864 --> 01:18:24,431
So, we never actually type the keyword strong.
所以我们从来不用 strong（注：也不是关键字）

1522
01:18:24,500 --> 01:18:25,666
It's the default. It's always there.
这是默认的，总是会在那里

1523
01:18:25,735 --> 01:18:27,501
It's kind of like internal with that access control.
就好像 internal 这个访问级别一样

1524
01:18:27,569 --> 01:18:29,736
We don't actually ever type that.
我们从来不把它写出来

1525
01:18:29,805 --> 01:18:33,340
Now weak, you've actually seen before. You all remember weak?
然后是 weak。你其实之前已经见到过了，你们还记得 weak 吗？

1526
01:18:33,409 --> 01:18:35,109
It was on the outlets. Okay,
@IBOutlet 就是弱引用的

1527
01:18:35,178 --> 01:18:37,510
when we made that outlet connection, I said oh,
当我们连接出口的时候，我说过

1528
01:18:37,579 --> 01:18:40,214
that, see that weak? I'm gonna tell you about that next week.
看到那个 weak 了吗？我下周给你讲

1529
01:18:40,282 --> 01:18:43,017
Well, I'm living up to my promise, I'm telling you about
这不，我遵守了我的诺言，我现在给你讲

1530
01:18:43,086 --> 01:18:47,121
weak. What does weak mean? Weak means I'm
weak。weak 是什么意思？弱引用表示我

1531
01:18:47,189 --> 01:18:50,690
pointing to this thing in the heap, but I'm only really
指向堆里的这个对象，但我只会

1532
01:18:50,759 --> 01:18:54,628
interested in it if someone else is interested in it.
在别人也对它感兴趣的时候才感兴趣

1533
01:18:54,697 --> 01:18:57,697
In other words, if someone else has a strong pointer to
换句话说，如果别人有一个到它的强引用

1534
01:18:57,766 --> 01:19:00,534
it, keep it in the heap. But as soon as no one else is
就把它留在堆里。但只要其他人都对它

1535
01:19:00,603 --> 01:19:01,802
interested in this, in other words,
不感兴趣了，也就是

1536
01:19:01,871 --> 01:19:05,505
all other strong pointers go away. Set me to nil and
所有其他的强引用都没了，就把我这个设为 nil

1537
01:19:05,574 --> 01:19:10,243
throw the thing out of the heap. So this is the don't
然后把它从堆中释放。所以这就是

1538
01:19:10,312 --> 01:19:14,414
keep that thing in the heap on my account kind of pointer.
“不要因为我而把它留在堆里”这种指针

1539
01:19:14,483 --> 01:19:17,384
And notice that it gets set to nil if all the other strong
然后注意它会被设为 nil，当其他强引用

1540
01:19:17,453 --> 01:19:20,253
pointers go away. So what kind of type does this have to be?
都没了的话设为 nil。那这个变量的类型必须是什么？

1541
01:19:20,322 --> 01:19:23,457
It has to be an optional.
它必须要是可选类型

1542
01:19:23,525 --> 01:19:28,362
So this weak only works with optional pointers to
所以 weak 来弱引用只适用于可选类型的

1543
01:19:28,430 --> 01:19:31,966
reference types, okay, things that are in the heap,
指向堆里的引用类型对象的指针

1544
01:19:32,034 --> 01:19:34,901
which our outlets are. If you remember our outlets,
就比如我们的出口变量。如果你还记得那些 @IBOutlet

1545
01:19:34,970 --> 01:19:38,839
like flip count label was a UI label exclamation point. That
比如 flipCountLabel 是个 UILabel!

1546
01:19:38,908 --> 01:19:41,875
was an implicitly unwrapped optional. It was an optional,
这是隐式解析的可选类型，它是可选类型的

1547
01:19:41,944 --> 01:19:44,945
right? Same thing card buttons was an implicitly unwrapped
对吧？同样的，cardButtons 是隐式解析的

1548
01:19:45,014 --> 01:19:49,817
optional. So those pointers to things in the UI.
可选类型，所以弱引用的指针指向 UI 里的内容

1549
01:19:49,885 --> 01:19:52,619
If for some reason those things left the UI, okay,
如果这些控件因为某种原因离开了用户界面

1550
01:19:52,688 --> 01:19:55,589
got removed from the UI somehow, which is possible,
被从 UI 上移除了，这确实可能发生

1551
01:19:55,657 --> 01:19:59,660
but rare. Then those things would get set to nil, okay?
虽然很少见，但这时它们就会被设为 nil，好吧？

1552
01:19:59,728 --> 01:20:00,994
And you would no longer be pointing to them,
你也不会再引用它们

1553
01:20:01,063 --> 01:20:01,828
and that's what they want.
这也是他们想要的效果

1554
01:20:01,897 --> 01:20:04,130
Because if there's no flip count label,
因为如果没有 flipCountLabel

1555
01:20:04,199 --> 01:20:07,234
there's no use trying to update it. So
那就不用尝试去更新它

1556
01:20:07,303 --> 01:20:10,170
that's why they make those weak All right, now, weak,
这就是为什么这些 UI 控件都是 weak 引用。总之，weak

1557
01:20:10,239 --> 01:20:12,772
there's only a couple of places that we use weak
我们只有几个地方会常用弱引用

1558
01:20:12,841 --> 01:20:15,842
commonly. One is for outlets, another one is for delegation.
其中之一就是 @IBOutlet 出口，另一个是代理

1559
01:20:15,911 --> 01:20:19,246
Remember back to my MVC talk, I talked about the delegation,
还记得我之前讲 MVC，我谈到了委托代理

1560
01:20:19,314 --> 01:20:21,815
the data source. And we have these pointers from the view
数据源，然后我们这些从视图

1561
01:20:21,883 --> 01:20:23,950
back to the controller where there's that blind and
指回控制器的匿名的

1562
01:20:24,019 --> 01:20:25,552
structure of communication all that,
标准化的通讯这些

1563
01:20:25,621 --> 01:20:27,320
which I'm gonna talk about on Wednesday.
就是我周三讲的

1564
01:20:27,389 --> 01:20:30,090
Those pointers are weak, because the view,
那些指针都是弱引用，因为视图

1565
01:20:30,159 --> 01:20:32,959
if the thing that they're sending will did and
如果它们发送这些 will、did

1566
01:20:33,028 --> 01:20:36,563
should to goes away, well, they're not gonna send those
should 去的目标对象不在了，那视图就不用再发送

1567
01:20:36,632 --> 01:20:40,400
messages anymore, so they want to be nil, okay. There's no
这些消息了，所以它们要是能够为 nil 的。没有

1568
01:20:40,469 --> 01:20:43,970
one to send their messages to then they just want to be nil,
人需要发送消息给它，那我们就希望它是 nil

1569
01:20:44,039 --> 01:20:45,872
okay. They don't want to be pointed to something.
这个变量就不希望指向任何东西

1570
01:20:45,941 --> 01:20:48,475
They certainly don't want a thing it points to,
视图肯定不希望因为它的引用的对象

1571
01:20:48,544 --> 01:20:50,543
to get stuck in the heap because of it.
因为这些引用而被困在堆里

1572
01:20:50,612 --> 01:20:53,179
Because they're happy to just not send the messages if
因为它们很乐意就不发消息

1573
01:20:53,248 --> 01:20:55,882
that thing wants to leave the heap, otherwise we don't
如果它们要离开堆就离开吧。其他时候我们一般

1574
01:20:55,951 --> 01:21:00,754
use weak that much. Okay, last is unowned.
不会怎么使用 weak。最后是 unowned

1575
01:21:00,823 --> 01:21:03,223
Unowned is don't reference count this,
无主引用是就不把它算到引用计数里

1576
01:21:03,292 --> 01:21:06,659
in other words I'm pointing to something in the heap, but
换句话说我引用了堆里的某个对象，但是

1577
01:21:06,728 --> 01:21:10,163
don't count it as a strong pointer. And I promise I'll
不要把它算作强引用。我保证我

1578
01:21:10,232 --> 01:21:14,668
never access this thing when it's gone from the heap. Now,
从来不会在这个对象释放之后再使用它

1579
01:21:14,737 --> 01:21:17,537
this is very dangerous, this is basically trying to
这个是非常危险的，这基本就是尝试

1580
01:21:17,606 --> 01:21:20,474
outsmart the automatic reference counting system.
证明自己比自动引用计数更厉害

1581
01:21:20,542 --> 01:21:23,877
You're saying, you know when it's in the heap or not, and
你在说我清楚的知道这对象是否在堆里

1582
01:21:23,946 --> 01:21:26,113
this is really rare. And the way,
这种情况是很少见的

1583
01:21:26,182 --> 01:21:30,584
the one time we use this is to avoid a memory cycle, okay.
我们唯一一种情况是用来避免引用循环

1584
01:21:30,653 --> 01:21:32,052
Everyone know what a memory cycle is,
大家都知道引用循环是什么？

1585
01:21:32,121 --> 01:21:33,854
that's where you have something in the heap and
那是你有个在堆里的对象

1586
01:21:33,922 --> 01:21:35,522
it points to something else in the heap, and
它引用了堆里的另一个对象

1587
01:21:35,591 --> 01:21:36,657
that thing points back to it.
然后那另一个对象又引用了回来

1588
01:21:36,725 --> 01:21:39,159
So, they're pointing to each other, keeping each other in
这样它们就相互引用，把对方留在

1589
01:21:39,228 --> 01:21:41,728
the heap. But no one else is interested in them. No one
堆里。但其他人对它们都不感兴趣了

1590
01:21:41,797 --> 01:21:44,465
points to either of them. They only just point to each other.
其他人并没有指向它们中的任何一个，只有它们互相引用

1591
01:21:44,533 --> 01:21:46,533
So they're just sitting in the heap for no reason.
它们就这样无缘无故地留在了堆里

1592
01:21:46,601 --> 01:21:49,769
No one's even accessing them, that's a memory cycle. And
其他人都不会访问它们，这就是引用循环

1593
01:21:49,838 --> 01:21:53,540
memory cycles aren't generally created in Swift normally but
Swift 里一般不会有引用循环

1594
01:21:53,609 --> 01:21:56,443
there's one way they're easy to create which is
但是有一种方法我们能够简单地创建一个

1595
01:21:56,511 --> 01:21:57,577
closures, okay.
那就是闭包

1596
01:21:57,646 --> 01:22:00,113
Which is a feature I'm gonna talk about on Wednesday, okay.
这是我周三要讲的特性

1597
01:22:00,182 --> 01:22:05,285
And so we will use unowned with closures. All right,
所以我们会在闭包里使用无主引用。好

1598
01:22:05,353 --> 01:22:07,821
back to our list of data structures here, of course
我们回到这个数据结构列表。当然

1599
01:22:07,889 --> 01:22:10,590
there's struct we know all about that. It's a value type,
我们知道了关于结构体的全部内容，它是值类型

1600
01:22:10,659 --> 01:22:12,893
it's copy on write, there's no inheritance of data.
它会在写时复制，不存在继承

1601
01:22:12,962 --> 01:22:15,495
But you're gonna learn with protocols there is inheritance
但你会学到可以通过 protocol，用协议来继承

1602
01:22:15,564 --> 01:22:16,330
of functionality,
功能

1603
01:22:16,398 --> 01:22:19,432
in fact multiple inheritance of functionality. And you've
更准确的说是功能的多重继承。你也已经

1604
01:22:19,501 --> 01:22:24,905
seen examples of struct cards, dictionary, string, character,
看到过很多结构体的例子了，Card, Dictionary, String, Character

1605
01:22:24,973 --> 01:22:29,476
int, double, UInt32, lots of structs have happened
Int, Double, UInt32 等等这些结构体都在这里

1606
01:22:29,545 --> 01:22:32,378
there. And I have here, let's jump over to concentrations
然后我们这里有，让我们到 Concentration 里

1607
01:22:32,447 --> 01:22:35,315
see what happens when we make concentration of struct.
看看我们把 Concentration 改为 struct 会发生什么

1608
01:22:35,384 --> 01:22:37,017
How about
要不

1609
01:22:37,018 --> 01:22:38,651
I start off the next one with that because we're pretty much
我们下节课开始再讲这个，因为我们已经基本上

1610
01:22:38,721 --> 01:22:41,121
out of time here. Enum, I'm not going to,
没有时间了。枚举，我不准备

1611
01:22:41,189 --> 01:22:44,624
oh yes, this is the demo, which I will do next time. And
哦，这是个演示，我下节课再来展示

1612
01:22:44,693 --> 01:22:47,794
then enum here we already just covered, so I'm not going to
然后枚举我们刚刚才讲完，我不准备

1613
01:22:47,863 --> 01:22:51,497
talk about it, another value type, discrete values. It also
再讲一遍，这就是另外一种值类型，有不同的值。它还

1614
01:22:51,566 --> 01:22:55,702
can have inherit the same kind of functionality inheritance.
可以继承功能

1615
01:22:55,771 --> 01:22:59,172
This functionality inheritance that I keep kind of mentioning
这个我一直在提到的功能的继承

1616
01:22:59,241 --> 01:23:02,342
is done using this last one, which is called protocols.
是通过最后一个 protocol 来实现的

1617
01:23:02,411 --> 01:23:04,845
So I'm gonna start off on Wednesday with a detailed
所以我周三回开始细讲

1618
01:23:04,913 --> 01:23:06,613
explanation of what a protocol is.
协议是什么

1619
01:23:06,682 --> 01:23:10,016
It's fundamental to the design of all of foundation,
它是所有基础的设计模式

1620
01:23:10,085 --> 01:23:12,819
all the array, dictionary, string, int.
所有的 Array, Dictionary, String, Int

1621
01:23:12,888 --> 01:23:15,522
And all of those things fundamentally using protocols
所有这些基础的内容都用到了 protocol

1622
01:23:15,591 --> 01:23:17,758
everywhere, massive number of protocols.
到处都是，大量的协议

1623
01:23:17,826 --> 01:23:20,093
And it's also fundamental with things like delegation and
同时这也是委托代理模式的基础

1624
01:23:20,162 --> 01:23:22,796
stuff like that, so it's very, very important. And to round
就像这样的内容，非常非常重要。这让我们能

1625
01:23:22,865 --> 01:23:26,332
out our full understanding of how to build data structures
完整地了解如何在 Swift 里构建数据结构

1626
01:23:26,401 --> 01:23:30,436
in Swift. Okay, so we'll start off on Wednesday with that and
我们星期三会先讲这些

1627
01:23:30,505 --> 01:23:32,739
I will see you then. >> For more,
到时候再见。>> 更多课程

1628
01:23:32,808 --> 01:23:41,314
please visit us at stanford.edu.
详见 stanford.edu
