1
00:00:00,401 --> 00:00:04,736
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:04,804 --> 00:00:08,840
Stanford University. >> All right,
斯坦福大学

3
00:00:08,909 --> 00:00:11,743
well, welcome to Lecture number four?
欢迎参加第四节课

4
00:00:11,812 --> 00:00:15,180
No. Yes, four of Stanford CS193P, Fall of 2017.
2017 年秋季学期斯坦福 CS193P 的第四节课

5
00:00:15,249 --> 00:00:18,583
Today, we're gonna continue to talk about Swift.
今天我们将继续谈谈关于 Swift 的一些内容

6
00:00:18,652 --> 00:00:21,019
This will be the last we talk about Swift. After this,
这会是最后一节讲 Swift 的课程。在本节课之后

7
00:00:21,088 --> 00:00:23,655
we're pretty much gonna kinda assume you know Swift.
我会默认你们已经掌握 Swift 了

8
00:00:23,724 --> 00:00:26,491
Obviously you'll be learning on the fly as you go, but
显然之后你们也会学到更多 Swift 的内容

9
00:00:26,560 --> 00:00:27,592
starting next week,
但是从下周开始

10
00:00:27,661 --> 00:00:29,861
we're gonna dive right into iOS, UI kit and
我们将会专注于 iOS、UIKit 和其他 iOS 开发

11
00:00:29,930 --> 00:00:33,198
all that. So I'm gonna do the quick demo that I postponed
相关的内容。我先完成周三没演示到的

12
00:00:33,267 --> 00:00:36,968
from Wednesday of this mutating keyword that we have
当我们将一个类改为结构体时必须

13
00:00:37,037 --> 00:00:39,771
to add when we make something a struct versus a class. Then
要使用的 mutating 关键字的例子

14
00:00:39,840 --> 00:00:43,274
we're gonna talk about two very important topics today.
接着我会讲今天两个非常重要的主题

15
00:00:43,343 --> 00:00:45,910
Protocols and closures.
协议和闭包

16
00:00:45,979 --> 00:00:48,647
Functions as types of general those two and in between, I'm
以及简单地讲讲函数。期间

17
00:00:48,715 --> 00:00:52,384
gonna talk about string which is important in a way but
我将会讲字符串，字符串也很重要

18
00:00:52,452 --> 00:00:55,553
it's not like the monstrous important topics like
但它不像超级重要的主题，协议和闭包

19
00:00:55,622 --> 00:01:00,859
prototypes and closures are. So start right into that demo
那样重要。那么现在从我们已经做好的

20
00:01:00,928 --> 00:01:05,096
that I had. And I had remembered, we were talking at the time about
示例程序开始。我记得我们那时正在讲

21
00:01:05,165 --> 00:01:09,400
making things a struct and that it's a little different
如何写一个结构体，结构体与类不一样

22
00:01:09,469 --> 00:01:13,172
then a class because that copy on write. Swift needs to know
因为它是写时复制（copy on write）的

23
00:01:13,240 --> 00:01:15,674
when a function might actually modify the thing so
Swift 需要知道一个函数何时会改变变量的值

24
00:01:15,743 --> 00:01:18,576
that it knows to actually make a real copy. So
它才能知道何时应当真正的去复制这个结构体

25
00:01:18,645 --> 00:01:22,147
let's go back here to our app, Concentration, where we were.
那么让我们回到我们的的翻牌游戏

26
00:01:22,216 --> 00:01:26,751
Let's go to Concentration, which if you recall,
来到我们的 Concentration，如果你还记得

27
00:01:26,820 --> 00:01:30,422
we made be a class. A class Concentration. And
我们写了一个类，叫做 Concentration

28
00:01:30,491 --> 00:01:32,857
this could have just as easily been a struct.
并且我们可以很轻松地将它改为一个结构体

29
00:01:32,926 --> 00:01:35,326
I really made it a class just so when we're doing
我将它写做类只是为了当我们在

30
00:01:35,395 --> 00:01:37,428
the initialize and stuff, you could see the difference
做初始化之类的操作时，你可以看出

31
00:01:37,497 --> 00:01:40,331
between Concentration and card because card was a struct and
Concentration 和 Card 的不同，因为 Card 是结构体

32
00:01:40,400 --> 00:01:42,267
Concentration was a class. But there's
而 Concentration 是一个类，但也没有什么

33
00:01:42,336 --> 00:01:44,136
no reason Concentration wouldn't have been a struct.
理由不让 Concentration 成为一个结构体

34
00:01:44,204 --> 00:01:47,572
It's probably, it might even be better as a struct here.
也许这里它是一个结构体的话还会更好一些

35
00:01:47,641 --> 00:01:51,376
Now we don't pass Concentration games around and
我们不会将翻牌游戏到处传递

36
00:01:51,445 --> 00:01:55,113
all that, it just kinda sits in our controller.
它差不多就是一直待在我们的控制器中

37
00:01:55,182 --> 00:01:58,716
Not really a pointer to our model but this would embed
并不是指向模型的指针，但它会将模型

38
00:01:58,785 --> 00:02:01,320
the model there. So it doesn't really matter too much.
嵌入在这里。所以其实没有什么太大影响

39
00:02:01,388 --> 00:02:06,124
But when I change this from class to struct, notice here
但当我将它改为结构体后，注意在这里我

40
00:02:06,193 --> 00:02:09,194
that I get an error. And let's scroll down and here they are,
得到了一个错误。让我们翻下去，这些错误在这里


41
00:02:09,263 --> 00:02:11,363
here's the error and this error is saying,
这些是错误，它说：

42
00:02:11,431 --> 00:02:15,533
cannot assign to property, self is immutable. Why is this
不能给属性赋值，self 是不可改变的。 为什么

43
00:02:15,602 --> 00:02:18,970
saying self is immutable? I'm trying to change the card here
它说 self 是不可改变的？我在尝试改变 card 的值

44
00:02:19,039 --> 00:02:21,273
to say that they've match, for example.
来表示它们是一样的

45
00:02:21,342 --> 00:02:24,442
Well, self is immutable because this function right
self 之所以是不可改变的，是因为这个函数

46
00:02:24,511 --> 00:02:29,514
is not marked mutable, and so it is assumed to not mutate,
没有被标记为可改变的，所提它被默认为是不可改变的

47
00:02:29,583 --> 00:02:34,152
not change this Concentration object. So
不会改变这个 Concentration 对象

48
00:02:34,220 --> 00:02:37,722
of course we need chooseCard to change the Concentration
当然我们需要这个函数改变 Concentration 对象

49
00:02:37,791 --> 00:02:40,325
object cuz it's the main thing. The change of the game,
因为这就是这个函数的主要功能，改变游戏中的值

50
00:02:40,394 --> 00:02:43,795
so all we need to do is add mutable right here, that
所以我们只需要在这里加上 mutable

51
00:02:43,864 --> 00:02:47,932
marks, sorry, mutating, not mutable, you add that here and
抱歉，不是 mutable，应该是 mutating，将它加在这里

52
00:02:48,001 --> 00:02:51,470
that says that this is a mutating function,
表示这是一个可变（mutating）函数

53
00:02:51,538 --> 00:02:54,372
all the errors go away, and we're all good to go.
所以错误都没有了，我们可以继续

54
00:02:54,441 --> 00:02:59,544
Question? >> [INAUDIBLE]
有问题吗? >>[学生提问]

55
00:02:59,613 --> 00:03:00,479
>> Okay, the question is why
>> 好的，他问的问题是为什么

56
00:03:00,547 --> 00:03:01,680
does this not need it?
这个不需要添加 mutating

57
00:03:01,749 --> 00:03:05,784
This is a var. And this var is get and set, so
因为它是一个变量，并且它可以被获取和赋值，所以

58
00:03:05,852 --> 00:03:10,121
Swift already knows this is mutating, cuz it's settable.
Swift 已经知道它是可变的了，因为它是可以被赋值的

59
00:03:10,190 --> 00:03:12,357
If this was get only, then it wouldn't be mutating and
如果它是只能被获取的，那么他就不是可变的，并且

60
00:03:12,426 --> 00:03:16,028
Swift would know that. So for vars, Swift knows. And
Swift 知道它不是可变的。所以对于变量，Swift 是知道的

61
00:03:16,096 --> 00:03:19,264
if it's not a computed var, like look at this var,
如果它不是一个演算型变量（computed var），像这个变量

62
00:03:19,332 --> 00:03:22,701
how does this one know? That's because, well, this one is
它是如何判断是否为可变的呢？这个变量是外部只读的

63
00:03:22,770 --> 00:03:26,871
read only externally but for us it's writable. Here,
但对我们来说它是可以被改变的

64
00:03:26,940 --> 00:03:29,641
anything that's a var it assumed it's writable. If it
在这里所有的变量都是默认可以被改变的

65
00:03:29,709 --> 00:03:34,846
were a let, a let, then it would think it's not writable.
如果它是一个常量（let），它会被认为是不可改变的

66
00:03:34,914 --> 00:03:39,450
So that's how you do mutating, or mutable. If for vars is
所以这就是你们如何处理可变类型，对于变量

67
00:03:39,519 --> 00:03:42,620
whether they're vars or let, or for computer property,
关注它是可变的（var）还是不可变的（let），对于演算属性

68
00:03:42,689 --> 00:03:47,192
whether it has both get and set.Everybody got all that? So
关注它是否可以获取和赋值。大家都听懂了吗

69
00:03:47,260 --> 00:03:49,060
it's only funcs that we have to put that on.
所以只需要将 mutating 放在函数的前面

70
00:03:49,129 --> 00:03:52,297
Yeah, question. >> [INAUDIBLE]
>> [学生提问]

71
00:03:52,366 --> 00:03:52,931
>> Yes, so the question is,
>> 好的，那位同学的问题是

72
00:03:52,999 --> 00:03:55,733
why is this you need to a struct and not a class, why do
为什么你需要一个结构体而不是类，为什么

73
00:03:55,802 --> 00:03:58,002
I need to struct? And that's very important to understand,
我需要一个结构体，理解这个是很重要的

74
00:03:58,071 --> 00:04:02,974
very good question. Structs are value types, not reference
非常好的问题。结构体是值类型而不是引用类型

75
00:04:03,043 --> 00:04:05,844
types. So structs don't live in the heap. As we pass
所以结构体并不是被存储在堆中。当我们传递

76
00:04:05,913 --> 00:04:09,013
the struct around since it's a value type, it gets copied.
结构体的时候，因为它是值类型，它会被复制

77
00:04:09,082 --> 00:04:11,649
Constantly copied everywhere. Pass through a function,
它会不断地复制到很多地方，传递给一个函数

78
00:04:11,718 --> 00:04:14,486
a copy is made. Put in a var, a copy is made. Well,
它被复制了一次，放到一个变量中，它又被复制了一次

79
00:04:14,554 --> 00:04:17,222
soon, that would be incredibly inefficient if it actually
那么，如果每次复制时，它的每一个位（bit）都被复制

80
00:04:17,291 --> 00:04:21,159
copy the bits of this entire thing every time. So instead,
程序就会变得非常低效。 所以 Swift 不那样做

81
00:04:21,228 --> 00:04:24,028
Swift is smart. It only actually copies the bits when
Swift 很聪明。它只复制你设置为可变的

82
00:04:24,097 --> 00:04:27,799
you mutate it. That's called copy-on-write semantics.
那一部分，这就叫做写时复制（copy on write）

83
00:04:27,867 --> 00:04:29,434
This is why structs are different,
这就是结构体不同的原因

84
00:04:29,503 --> 00:04:31,903
because they have that copy-on-write semantics.
因为他们是写时复制的

85
00:04:31,972 --> 00:04:35,106
A class doesn't have that, cuz when you pass a class around,
类不是那样的，因为当你传递一个类时

86
00:04:35,175 --> 00:04:37,075
the class just lives once in the heap,
那个类只在堆中存在一次

87
00:04:37,144 --> 00:04:38,810
and you're passing pointers to it around.
而你是在传递指向它的指针

88
00:04:38,878 --> 00:04:41,213
And there could be 20 pointers to the same object.
那么可能就会有 20 个指针指向同一个对象

89
00:04:41,281 --> 00:04:44,683
Totally different kinda model for memory. So that's why,
这是完全不同的两种内存模型。这就是原因

90
00:04:44,751 --> 00:04:48,719
it's because it's a value type that copy on writes stuff,
是因为结构体是值类型，值类型是写时复制的

91
00:04:48,788 --> 00:04:51,523
that's why we care that it's mutating.
这就是我们关注它是可变的的原因

92
00:04:51,592 --> 00:04:56,828
Let's go back to our slides and talk about the first very,
让我们回到我们的幻灯片，并且开始第一个非常

93
00:04:56,897 --> 00:05:01,900
very important topic today which is protocols.
非常重要的主题，协议（protocol）

94
00:05:01,968 --> 00:05:05,737
It's the fourth pillar of building data structures
那是在 Swift 中建立数据结构的第四支柱

95
00:05:05,805 --> 00:05:09,307
inside of Swift. You already know a lot now about class,
你们已经学到很多关于类、结构体和枚举的知识了

96
00:05:09,375 --> 00:05:14,679
struct and enum. And a protocol is something where
而一个协议就是一个非常简单的

97
00:05:14,748 --> 00:05:18,382
its a very simple concept. A protocol is basically just
概念，它基本上就是一个

98
00:05:18,451 --> 00:05:21,453
a list of methods and vars with no implementation. But
方法和变量的清单，而不包含任何实现

99
00:05:21,522 --> 00:05:23,722
it's the use of having protocols. It's so
但是协议的使用，它在 Swift 语言与运行时

100
00:05:23,790 --> 00:05:27,025
pervasively used throughout the Swift language and
中被普遍的应用

101
00:05:27,093 --> 00:05:30,529
the runtime that makes it so powerful. So first I'm just
让它变得十分强大。那么首先我会

102
00:05:30,597 --> 00:05:32,664
gonna go through a little bit of why we have protocols.
简单讲一下为什么我们要用协议

103
00:05:32,733 --> 00:05:35,133
Then I'll show you the syntax of protocols.
接着我会向你们展示协议的语法

104
00:05:35,201 --> 00:05:37,635
What it looks like to type in a protocol and define one.
协议是什么样子的与如何定义一个协议

105
00:05:37,704 --> 00:05:40,005
Then we'll start talking about the use of protocols.
接下来我会讲如何协议的用法

106
00:05:40,073 --> 00:05:43,674
Where do we use them? Why are they so valuable? So
我们会在哪里用到协议，为何它们这么重要？

107
00:05:43,743 --> 00:05:47,178
let's start with, what protocols are all about?
那么我们现在开始将，协议到底是什么

108
00:05:47,247 --> 00:05:51,616
Protocols are essentially a way for
协议本质是是就是让调用者用任何它想的

109
00:05:51,685 --> 00:05:55,219
callers to call an API with anything they want.
东西调用一个应用程序接口（API）的方法

110
00:05:55,288 --> 00:05:57,122
Any struct, enum, class,
任何结构体，枚举类型，类

111
00:05:57,190 --> 00:06:00,391
it can pass anything they want in. And at the same time
它可以传递任何它想的的参数。并且同时

112
00:06:00,460 --> 00:06:04,596
the receiving method can specify what it really wants.
接收这些参数的方法可以判别它到底是想要什么

113
00:06:04,665 --> 00:06:08,132
So both sides get to do what they want. The receiving thing
这样两边都可以做它们想做的。接收者

114
00:06:08,201 --> 00:06:10,868
gets to say what it wants the thing you're pass in
来决定它应该用你传递给它的参数做什么

115
00:06:10,937 --> 00:06:13,772
to do and the thing passing in can pass whatever it wants as
而传递者可以向它传任何它想传的参数，只要

116
00:06:13,840 --> 00:06:17,409
long as it does that thing. And to do all this all
接受者可以处理被传的参数。而要做到这样

117
00:06:17,478 --> 00:06:22,380
a protocol is, is a list of vars and functions.
协议实际上就是一个变量和函数的清单

118
00:06:22,449 --> 00:06:24,649
That's all a protocol is. It's just a list of them.
这就是协议。就是一个变量和函数的清单

119
00:06:24,718 --> 00:06:27,251
Not an implementation or anything, just a list of them.
不是实现或者其它什么，只是一个清单

120
00:06:27,320 --> 00:06:30,622
And it's how we use them in the API that let's us get this
而是我们如何在应用程序接口中使用它们，让我们得到

121
00:06:30,691 --> 00:06:33,558
behavior of having the callers and the callees.
调用者和被调用者能表达他们想表达

122
00:06:33,626 --> 00:06:37,028
Get to express things the way they want. Now, what
的行为。那么

123
00:06:37,096 --> 00:06:40,532
are protocols good for? They make APIs very flexible and
用协议有什么好处呢？它们让应用程序接口变得非常灵活

124
00:06:40,600 --> 00:06:42,500
expressive, as you're going to see.
并且非常易于表达，你们接着就会感受到

125
00:06:42,569 --> 00:06:45,870
They're super good for blind structured communication.
它们对标准化匿名通讯机制是非常有好处的

126
00:06:45,939 --> 00:06:48,439
Like, remember back to my MVC talk.
就像，还记得我们曾经讲过的 MVC 间的通信吗

127
00:06:48,508 --> 00:06:50,542
The communication between the view and the controller.
视图和控制器之间的通信

128
00:06:50,611 --> 00:06:54,011
All those will, did, shoulds. And the data at count,
那些will, did, should, data, at, count 方法

129
00:06:54,080 --> 00:06:56,982
those kind of communications between a view controller.
那些视图与控制器之间通信的方式

130
00:06:57,050 --> 00:06:59,784
That all had to be blind, because the views are generic
那些都应该是匿名的，因为视图是泛型的

131
00:06:59,853 --> 00:07:03,721
and the controllers are very specific, and protocols is how
而控制器是非常具体的。而协议就是我们如何让

132
00:07:03,790 --> 00:07:07,792
we make that work. It's also great for mandating behavior,
他们工作的。协议也对控制行为有很大用处

133
00:07:07,861 --> 00:07:11,529
for example, in a dictionary, a dictionary's a hash table,
举个例子，在一个字典类型中，一个字典是哈希表（hash table）

134
00:07:11,597 --> 00:07:15,032
raise your hand if you know what a hash table is when I
如果你知道什么事哈希表，请举手

135
00:07:15,101 --> 00:07:19,037
say that. Okay, everybody. Good. So it's a hash table.
好的，所有人都知道。那么它是一个哈希表

136
00:07:19,105 --> 00:07:22,407
So the keys of a dictionary clearly have to be hashable.
所以字典的键（key）应该具有哈希性（hashable）

137
00:07:22,476 --> 00:07:25,509
You have to be able to get a hash value otherwise you can't
你必须要有一个哈希值否则

138
00:07:25,578 --> 00:07:28,580
hash them and put them in as keys of this hash table.
你不能哈希它们，并且将它们放在这个哈希表的键中

139
00:07:28,649 --> 00:07:31,983
Well, protocols let us define dictionary in a way so
协议让我们这样定义字典

140
00:07:32,052 --> 00:07:35,319
that we don't use any keys that aren't hashable.
我们就不能用任何不具哈希性的键

141
00:07:35,388 --> 00:07:38,056
So mandating behavior hashbility, for example,
那么协议在限制键的

142
00:07:38,125 --> 00:07:40,992
of the key it's great for that. It's also great for
可哈希性方面很好用。协议还可以用于

143
00:07:41,061 --> 00:07:43,994
sharing functionality between very disparate types,
在非常不同的类型间共享相同的功能

144
00:07:44,063 --> 00:07:47,064
types that you would never use object oriented inheritance to
这些类型你可能从来不会用面向对象的继承让他们

145
00:07:47,133 --> 00:07:50,501
make them share a base class, but they are very similar, for
共同继承一个基础的类，但它们非常的相像，举个例子

146
00:07:50,570 --> 00:07:54,472
example, string, array, countable range. They are all
字符串，数组，可数区间（countable range）它们都是

147
00:07:54,540 --> 00:07:57,475
collections of things. Now they're completely different.
一些东西的集合。虽然它们完全不同

148
00:07:57,544 --> 00:07:58,943
Come one, a countable range and
一个可数区间和

149
00:07:59,012 --> 00:08:01,446
a string are completely different. But they are both
字符串当然是完全不同的。但是它们都

150
00:08:01,515 --> 00:08:04,182
collections, a string is a collection of characters,
是一个集合。一个字符串是字符的集合

151
00:08:04,251 --> 00:08:06,584
accountable range is a collection of integers if it's
当可数区间是整数的可数区间时

152
00:08:06,653 --> 00:08:09,487
an accountable range of int. So they do share some and
它是一个整数的集合。那么它们的确都有一些共性

153
00:08:09,555 --> 00:08:12,624
protocols has a mechanism to allow you to share that kind
而协议是一种途径让你可以共享那些共性

154
00:08:12,693 --> 00:08:15,426
of similarity without having to have all those thing
而不用让这些东西都

155
00:08:15,495 --> 00:08:18,763
inherit from some kind common base class that knows about
继承一个公共的关于集合的

156
00:08:18,832 --> 00:08:21,666
collections of things. You see what I'm saying? And so
基础类。你能理解我在说什么吗？那么

157
00:08:21,735 --> 00:08:25,536
in a way, protocols provide multiple inheritance. Now,
从一方面来讲，协议提供了多重继承

158
00:08:25,605 --> 00:08:28,873
since protocols are only doing the declaration of the vars
既然协议只是做了变量和函数的声明

159
00:08:28,942 --> 00:08:32,277
and functions, there's no storage of, of those things,
它不负责储存那些东西

160
00:08:32,345 --> 00:08:34,378
so there's no inheritance of data,
所以它不是数据的继承

161
00:08:34,447 --> 00:08:36,447
it's purely just inheritance of,
单纯的只是

162
00:08:36,516 --> 00:08:41,152
inheritance of functionality. All right, as I go
功能的继承。好的，正如我刚刚解释的

163
00:08:41,221 --> 00:08:43,688
through this explanation, it's super important to understand
理解协议只不过是一种类型是非常重要的

164
00:08:43,757 --> 00:08:47,258
that protocols are just a type. Just like a class is
就像类是一种类型

165
00:08:47,327 --> 00:08:50,194
a type, a struct, an enum, a protocol is a type.
结构体，枚举类型，协议是一种类型

166
00:08:50,263 --> 00:08:52,730
A first-class type, just like all the rest of these types,
协议就像其他这些类型一样，是头等类型（first-class type）

167
00:08:52,799 --> 00:08:54,398
that's very important to understand.
理解这是非常重要的

168
00:08:54,467 --> 00:08:58,103
All right, so let's dive into what a protocol is.
好了，我们开始讲协议是什么

169
00:08:58,171 --> 00:08:59,804
There's three parts to a protocol.
一个协议有三个部分

170
00:08:59,873 --> 00:09:02,974
One, there's the declaration of the protocol, just like you
第一部分是协议的声明，就像

171
00:09:03,043 --> 00:09:05,443
have a declaration of a class or an enum or a struct. For
你的类、枚举类型、结构体有各自的声明一样

172
00:09:05,511 --> 00:09:07,245
a protocol, that's just a list of
对于协议来说，那就是一个方法

173
00:09:07,313 --> 00:09:09,781
methods with their arguments and return values and
和它的参数和返回值的清单，和

174
00:09:09,850 --> 00:09:13,284
a list of vars. That's it, that's what a protocol is,
一个变量的清单。就是这样，这就是一个协议

175
00:09:13,353 --> 00:09:16,620
it's a declaration. Second part of a protocol though
它是一个声明。一个协议的第二部分

176
00:09:16,689 --> 00:09:21,259
is a class or a struct or an enum raises its hand and
是一个类、结构体或枚举类型举起手来并且

177
00:09:21,327 --> 00:09:24,628
claims to implement those methods in vars in that
声明要来实现协议中的那些对变量的处理方法

178
00:09:24,697 --> 00:09:27,832
protocol. So there's the claim to implement a protocol,
那么这里有要实现这个协议的声明

179
00:09:27,901 --> 00:09:30,701
that's the second part. Cuz somebody has to actually
这是第二部分。因为有人要真正的去

180
00:09:30,770 --> 00:09:33,437
implement those methods that the protocol is a list of, and
实现协议中列出的那些方法

181
00:09:33,506 --> 00:09:36,274
that's classes, structs and enums, so they have to claim.
而这可以是类、结构体、和枚举类型。所以他们要去声明

182
00:09:36,343 --> 00:09:39,377
And then the third part is the code in those classes,
接着第三部分是是在那些类、结构体和枚举类型中

183
00:09:39,446 --> 00:09:42,246
structs and in in enums that actually implements
的代码，这些代码真正地实现了

184
00:09:42,315 --> 00:09:45,115
the protocol methods in vars. Okay, so
协议中对变量的处理的方法

185
00:09:45,184 --> 00:09:47,852
notice I'm mentioning vars. The vars,
注意到我提到了变量。那些变量

186
00:09:47,921 --> 00:09:51,289
the storage of the vars, if they're not computed vars,
如果他们不是演算变量的话

187
00:09:51,358 --> 00:09:54,592
has to be in some struct, enum or a class. Because,
必须要存储在结构体、枚举类型或或一个类中。因为

188
00:09:54,661 --> 00:09:58,596
that's the only places you can have any storage, all right?
那些是唯一可以有存储空间的地方，对吧

189
00:09:58,665 --> 00:10:00,364
Okay, so that's it, those are the three parts of a protocol.
好的，这就是协议的三个部分了

190
00:10:00,433 --> 00:10:03,401
Now I'm gonna take a little aside, and
现在我先要讲一点别的

191
00:10:03,470 --> 00:10:07,037
not even gonna spend too much time on this, but
并且不会在这上面花费太多时间

192
00:10:07,106 --> 00:10:11,209
all the methods and vars in a protocol are mandatory.
一个协议中的所有方法和变量都是具有强制性的

193
00:10:11,278 --> 00:10:12,810
If you're wanna raise your hand and
如果你要举起手来并

194
00:10:12,879 --> 00:10:14,378
say, I implement this protocol.
说，我要实现这个协议

195
00:10:14,447 --> 00:10:18,015
If you're a struct or enum or a class, you have to implement
如果你是一个结构体、枚举类型、或类，你必须要实现所有的

196
00:10:18,084 --> 00:10:22,187
all of the methods and all the vars in Swift. However,
方法和所有的变量，在 Swift 中是这样的，但是

197
00:10:22,255 --> 00:10:27,024
in Objective-C, that was not true. In Objective-C,
在 Objective-C 中，并不是这样的。 在 Objective-C 中

198
00:10:27,093 --> 00:10:31,762
protocols could have optional methods. Methods or
协议可以有可选方法。协议中的

199
00:10:31,831 --> 00:10:34,432
vars in the protocol that you could choose to implement or
方法或变量你可以选择去实现或者不去实现

200
00:10:34,500 --> 00:10:38,970
not. Now, that's quite a big difference and the way Swift
那么这是与 Swift 的很大的不同，而 Swift 处理它的方式

201
00:10:39,039 --> 00:10:42,306
deals with that is it allows you to put @objc, in front of
是它允许你将 @ojbc 放在

202
00:10:42,375 --> 00:10:45,276
you declaration of a protocol to make it so that this
你的协议的声明的前面，以表示这是一个

203
00:10:45,344 --> 00:10:48,746
is an Objective-C protocol instead of a switch protocol.
Objective-C 协议而不是一个 Swift 协议

204
00:10:48,815 --> 00:10:51,216
And the only difference is that now,
而唯一区别是，现在

205
00:10:51,284 --> 00:10:54,252
methods inside of your protocol can be marked
你协议中的方法可以被标记为

206
00:10:54,321 --> 00:10:57,088
optional. Not optional like you know question mark,
可选的。不是像问号、感叹号那样的可选类型

207
00:10:57,157 --> 00:10:59,057
exclamation point, that kind of optional enum.
那是一种可选的枚举类型

208
00:10:59,125 --> 00:11:01,292
I'm talking about optional like you can optionally
我正讲的是像你可以选择去实现但你不一定要实现

209
00:11:01,361 --> 00:11:03,728
implement the method but you don't have to implement if you
这个方法，如果你

210
00:11:03,797 --> 00:11:07,498
don't want to. Okay, so that's a special kind of backwards
不想去实现的话。好的那么这就是一种特殊的对

211
00:11:07,567 --> 00:11:09,533
compatibility mode to Objective-C, but
Objective-C 的向后兼容

212
00:11:09,602 --> 00:11:12,470
in Swift, we don't do that. So the only time we're ever gonna
但是在 Swift 中，我们不会那样做。所以在这们课中

213
00:11:12,538 --> 00:11:15,673
have this going on in this class is when we're using iOS
我们只有在我们用到了在 Objective-C 中

214
00:11:15,742 --> 00:11:18,642
API that was designed back in the Objective-C world.
设计的 iOS 应用程序接口的时候才会这样做

215
00:11:18,711 --> 00:11:21,111
Specifically, delegation,
具体来讲，是代理（delegation）

216
00:11:21,180 --> 00:11:24,348
which is that blind view to controller communication.
它是那个匿名的视图和控制器的通信

217
00:11:24,417 --> 00:11:29,086
That is all Objective-C style protocols and so
那些都是 Objective-C 风格的协议

218
00:11:29,155 --> 00:11:32,423
when you start using that down the road in the coming weeks,
所以在接下来几周，当你开始去那些东西的时候

219
00:11:32,492 --> 00:11:34,191
you're gonna see these protocols that are marked
你会看到那些协议被标记为

220
00:11:34,260 --> 00:11:36,694
Objective-C and some of them are marked optional
Objective-C 并且有一些被标记为可选的

221
00:11:36,763 --> 00:11:38,429
that you don't have to implement a method.
可选的方法你不必须要去实现

222
00:11:38,497 --> 00:11:42,366
That's not Swift. That's Objective-C compatibility.
那不是 Swift，那是 Objective-C 的兼容性

223
00:11:42,435 --> 00:11:44,502
So just put that in the back of your brain so
所以先把这些记下来

224
00:11:44,571 --> 00:11:46,570
that when you see it, you're like, whoa. I thought I had to
当你看到它时，你就会，哇，我本以为我必须要

225
00:11:46,639 --> 00:11:48,973
implement all the methods in your protocol. Yes, you do in
实现你协议中的所有方法。是的，在 Swift 中你是要的

226
00:11:49,042 --> 00:11:54,211
Swift. Only this exception, all right, back to protocols.
除了这个例外。好的，回到协议

227
00:11:54,280 --> 00:11:57,682
Okay, so how do we declare a protocol? What does the syntax
那么我们应当如何声明一个协议呢？那个语法是什么样的

228
00:11:57,750 --> 00:12:00,851
look like? Well, it looks a lot like declaring a class.
它跟声明一个类很像

229
00:12:00,920 --> 00:12:05,022
Protocol, SomeProtocol, SomeProtocol is the name
protocol SomeProtocol，SomeProtocol 是协议的

230
00:12:05,091 --> 00:12:07,858
of that protocol just like if you say at class whatever
名字，就像 class whatever 中

231
00:12:07,927 --> 00:12:09,627
that would be the name of the class.
whatever 是类的名字

232
00:12:09,695 --> 00:12:12,897
Notice that there's also colon, InheritedProtocol1,
注意这里还有 :InheritedProtocol1, InheritedProtocol2

233
00:12:12,966 --> 00:12:16,667
InheritedProtocol2 actually it can be any number of these.
事实上这里可以有任意数量的这些东西

234
00:12:16,736 --> 00:12:22,273
These are the other protocols that SomeProtocol inherits.
这些是 SomeProtocol 继承的那些协议

235
00:12:22,342 --> 00:12:25,276
Okay, so there is inheritance in protocols. It means
所以说，协议中也是有继承的，这

236
00:12:25,344 --> 00:12:28,346
a little bit different thing then in a class.
与类中的继承有一点不同

237
00:12:28,415 --> 00:12:30,782
Okay, inheritance in the protocol world means,
在协议中的继承的意思是

238
00:12:30,850 --> 00:12:34,219
if you wanna claim to implement SomeProtocol. You
如果你声明要实现 SomeProtocol，你

239
00:12:34,287 --> 00:12:37,355
also have have to implement InheritedProtocol1 and
同时要实现 InheritedProtocol1 和

240
00:12:37,423 --> 00:12:41,759
InheritedProtocol2. So it's almost like it's a mandatory
InheritedProtocol2。所以那差不多就是一些必须的

241
00:12:41,827 --> 00:12:44,629
additional protocols you must implement if you wanna say
额外的协议，你必须要去实现，当你声明要

242
00:12:44,697 --> 00:12:47,398
you implement this protocol. We call that protocol
实现这个协议时。我们称这为协议继承

243
00:12:47,467 --> 00:12:52,270
inheritance. We call it that because some protocol inherits
我们这样叫它是因为一些协议继承了

244
00:12:52,338 --> 00:12:57,842
the requirement to implement these other protocols. Now,
要实现它所继承的那些协议的要求

245
00:12:57,911 --> 00:13:01,712
once you go inside the definition of protocol,
当你进入一个协议的声明

246
00:13:01,781 --> 00:13:05,483
you can see there's no code. Protocols have no code,
你会发现这里没有代码。协议不包含代码

247
00:13:05,552 --> 00:13:06,884
they are not implementations,
它们不是实现

248
00:13:06,953 --> 00:13:10,854
they are purely declarations. And, in fact, when you declare
它们单纯的只是声明。并且事实上当你声明

249
00:13:10,923 --> 00:13:13,925
that you're gonna have a var be part of your protocol,
一个变量将会作为这个协议中的一部分时

250
00:13:13,994 --> 00:13:16,894
all you get to say is whether it's a read-only var,
你只能决定它是一个只读变量

251
00:13:16,962 --> 00:13:18,296
which would be get or
也就是 get ，或者是

252
00:13:18,364 --> 00:13:20,865
a read-and-write var with get set like this.
一个可读可写的变量，也就是 get 和 set，像这个

253
00:13:20,934 --> 00:13:24,435
So this one right here some property would be get and set.
那么这里的东西表示它是这是一个可获取与赋值的属性

254
00:13:24,504 --> 00:13:27,104
So if you wanna implement this protocol, your class or
如果你希望实现这个协议，你的类

255
00:13:27,173 --> 00:13:29,640
struct and you wanna implement this, you would have to have
或者结构体和你想要实现这个，你必须要有一个

256
00:13:29,709 --> 00:13:36,013
a var that can be get and set. Okay, that's what that means.
可以获取与赋值的变量。这就是它的意思

257
00:13:36,082 --> 00:13:39,283
Any methods that you have in your protocol
你协议中的所有可能被结构体实现

258
00:13:39,352 --> 00:13:43,321
that might be implemented by a struct and modified the thing
的方法，如果它会改变那个东西的话

259
00:13:43,389 --> 00:13:46,791
have to be marked mutating of course, right?
当然必须要被标记为可变的（mutating）

260
00:13:46,860 --> 00:13:50,361
Because again Swift needs to know oh
因为 Swift 需要知道，喔

261
00:13:50,430 --> 00:13:53,264
this method might change the thing that implements it.
这个方法可能会改变实现它的那个东西

262
00:13:53,332 --> 00:13:56,534
Now there's a little trick if you want, if you know
如果你想知道的话，这有一个技巧。如果你确定

263
00:13:56,602 --> 00:13:59,436
this protocol's never gonna be implemented by a struct,
这个协议绝不会被一个结构体实现

264
00:13:59,505 --> 00:14:02,339
then you don't need the mutating. But you have to mark
那么你就不需要 mutating。但你必须要去标记

265
00:14:02,408 --> 00:14:06,143
the protocol to say this is a class only protocol. You do
这个协议来表示这是一个只会被类实现的协议

266
00:14:06,212 --> 00:14:09,914
that by saying colon class as the first thing right after
你可以通过将 : class 放在协议声明的后的第一位

267
00:14:09,982 --> 00:14:13,251
the protocol declaration. You see how I put that yellow
你看到我将那个黄色的

268
00:14:13,319 --> 00:14:16,253
colon class up there? Okay, so then if you did that then
: class 放在那了吗？好的如果你这样做了

269
00:14:16,322 --> 00:14:18,456
you would not have to put the mutating because of course,
你自然就不需要放 mutating 在那里了

270
00:14:18,525 --> 00:14:20,224
you never have to put mutating in a class, but
你在类中从不需要 mutating

271
00:14:20,292 --> 00:14:22,426
then this protocol could not be implemented by a struct.
但之后这个协议就不能被结构体实现了

272
00:14:22,495 --> 00:14:25,829
It could only be implemented by a class, we rarely do this.
它只能被类实现，我们很少这样做

273
00:14:25,898 --> 00:14:28,732
Okay we don't usually make a protocol, be restricted to
我们不通常不将一个协议限制为只能

274
00:14:28,801 --> 00:14:31,435
a class and in fact 99% of all the protocols you're gonna see
由类实现，并且实际上 iOS 中 99% 的协议

275
00:14:31,504 --> 00:14:36,207
in iOS could be implemented by anybody. Okay,
可以被任何东西实现

276
00:14:36,276 --> 00:14:40,544
what else we got here. Yes,
这里还有什么，对了

277
00:14:40,613 --> 00:14:44,748
you can an even add an init to your protocol. And that means
你甚至可以在你的协议中加上初始化（init），这意味着

278
00:14:44,817 --> 00:14:47,551
if you're a class or a struct that implements this protocol,
如果一个类或者结构体要来实现这个协议

279
00:14:47,620 --> 00:14:49,086
you have to implement this init.
它必须要实现这个初始化

280
00:14:49,155 --> 00:14:53,056
So, I have to be able to initialize you. So, that
我必须能够初始化这个它

281
00:14:53,125 --> 00:14:57,194
was how we declare a protocol, now let's look how a class or
那就是我们声明一个协议的方法，现在让我们来看看一个类

282
00:14:57,263 --> 00:15:00,965
a struct says, raises his hand and says yes, I will
或者结构体要如何举起手来，说好，我将

283
00:15:01,033 --> 00:15:03,968
implement this protocol. All it does is in a class after
实现这个协议。一个类需要做的只是

284
00:15:04,036 --> 00:15:07,505
the superclass, you just say comma all the protocols you
在它的父类后面，加上逗号和所以他

285
00:15:07,574 --> 00:15:12,243
claim to implement. It's as simple as that, of course, for
声明要实现的协议。就是这样简单，当然

286
00:15:12,312 --> 00:15:15,279
a struct there is no superclass, so
对于结构体来说，它没有父类

287
00:15:15,347 --> 00:15:19,717
you would just say enum or struct, whatever, colon
所以你只用 enum 或 struct whatever（名字）:

288
00:15:19,786 --> 00:15:24,055
the protocols you implement. Okay, so that's how you claim.
再加所以你要实现的协议。好的，那就是你如何声明实现

289
00:15:24,123 --> 00:15:26,657
This is you raising your hand and say I implement that.
这就是你举起手来并说你要实现那协议

290
00:15:26,726 --> 00:15:28,759
As soon as you say that the Swift compiler is gonna check
你一这样说，Swift 的编译器就会去确定

291
00:15:28,828 --> 00:15:30,961
to make sure you actually implement those methods and
你真的实现了在那个协议中的方法和

292
00:15:31,030 --> 00:15:33,397
vars in that protocol. And if you don't, you're going to get
变量。如果你没有，你会得到

293
00:15:33,466 --> 00:15:36,734
errors. It's gonna say you do not implement this on protocol
错误。它会说你没有实现这个协议中的

294
00:15:36,803 --> 00:15:41,338
method whatever. And you're have to go do that, all right?
某个方法什么的。而你必须要去实现它们，对吧

295
00:15:41,407 --> 00:15:43,240
You can do any number of protocols that you want.
你可以实现任意你想要的数量的协议

296
00:15:43,309 --> 00:15:46,310
That's sometimes why we say that protocols can provide
那就是有时我们说协议可以提供

297
00:15:46,379 --> 00:15:48,546
multiple inheritance because you can have as many of these
多重继承，因为你可以放

298
00:15:48,615 --> 00:15:51,616
ah, as you want going on there. Ah, by the way,
任何你想要的数量的协议在那里，还有

299
00:15:51,685 --> 00:15:53,551
if there is an init in the protocol and
如果在协议中有初始化

300
00:15:53,620 --> 00:15:56,487
you're a class and you say, implement that protocol,
而一个类要实现这个这个协议

301
00:15:56,555 --> 00:15:59,623
you have to mark there, your init required.
你必须要在那里标注 required

302
00:15:59,692 --> 00:16:01,859
That's because you wouldn't want a subclass to come along.
那是因为你不想让一个子类跑出来

303
00:16:01,927 --> 00:16:05,696
Subclass you, subclass that init away which is possible.
继承你，并且将那个初始化继承了，这是可能的

304
00:16:05,765 --> 00:16:07,131
It's possible to subclass and make it so
子类可能这样做

305
00:16:07,199 --> 00:16:09,867
an init doesn't work anymore from your superclass.
那么这个继承自父类的初始化就不再有效

306
00:16:09,936 --> 00:16:11,935
You don't want to allow subclasses to do that because
你不希望允许你的子类这样做

307
00:16:12,004 --> 00:16:14,972
then a subclass would no longer implement this protocol
因为如果这样做了，子类不会再实现这个协议

308
00:16:15,041 --> 00:16:17,374
and yet people might think it does because it inherits from
但人们可能会认为它依然实现了协议，因为它继承

309
00:16:17,443 --> 00:16:21,445
something that does. So, once a class implements protocol,
的父类实现了。因此每当一个类实现了协议

310
00:16:21,514 --> 00:16:24,248
all it's subclasses have to as well, so all init would have
它的所有子类必须也要能实现，所以所有的初始化

311
00:16:24,317 --> 00:16:26,684
to be required. Cuz init kind of special,
都要被标为 required，因为初始化有些特殊

312
00:16:26,753 --> 00:16:28,719
in that it's possible in your subclass, to make it so
在你的子类中，是有可能让某些来自父类的初始化

313
00:16:28,788 --> 00:16:30,921
you no longer implement a certain init with certain
不被实现的

314
00:16:30,990 --> 00:16:35,393
arguments. By the way, in your reading, there's a whole bunch
顺带，在你们的阅读作业中，有许多关于

315
00:16:35,461 --> 00:16:39,229
about making inits in classes. It's probably
在类中做初始化的东西，这可能是

316
00:16:39,298 --> 00:16:42,266
the most complicated long part of your reading for this week.
你们这周最复杂的，最长的阅读部分

317
00:16:42,334 --> 00:16:46,303
You gonna have to fight through it cuz it's pretty
你们要坚持下来，因为

318
00:16:46,372 --> 00:16:49,607
complicated. Inheritance makes initialization really
这是挺复杂的，继承让初始化变得非常

319
00:16:49,676 --> 00:16:51,809
difficult because you've got your own vars, you've got your
难，因为你有自己的变量，你有你的

320
00:16:51,877 --> 00:16:54,511
superclasses vars. You've got to get things initialized
父类变量，你要让初始化以

321
00:16:54,580 --> 00:16:57,882
in the right order, all that, it's quite complicated.
正确的顺序进行，之类的东西，那是挺复杂的

322
00:16:57,950 --> 00:17:00,584
So, unfortunately one of the things that you subclass
而很不幸的是，这其中的一件你子类可以做

323
00:17:00,653 --> 00:17:03,086
can make it so you don't implement an init anymore.
的事情就是不去实现一个初始化

324
00:17:03,155 --> 00:17:09,060
So that's why you have to mark it required. One thing
那就是你必须将它标记为 required 的原因

325
00:17:09,128 --> 00:17:13,097
is you don't have to add your conformance to a protocol.
还有就是你不一定要将实现协议的部分

326
00:17:13,166 --> 00:17:14,865
You don't have to add all the methods, and
不一定要将一个协议的方法和

327
00:17:14,934 --> 00:17:17,968
vars in that protocol. In your actual class declaration, or
变量放在你的类声明中

328
00:17:18,037 --> 00:17:20,671
your struct declaration you can add it with an extension,
或者你的结构体的声明中，你可以将他们放在扩展（extension）中

329
00:17:20,740 --> 00:17:23,073
you know how we can extend Int to add arc4random.
你知道我们扩展 Int 并且添加 arc4random 的方法

330
00:17:23,142 --> 00:17:27,144
Well we could extend Int to conform to some protocol.
我们也可以扩展 Int，让他来实现某些协议

331
00:17:27,212 --> 00:17:29,013
Okay, that would be perfectly fine.
这是非常好的

332
00:17:29,081 --> 00:17:31,682
We would just say extension Int :,
我们只用写 extension Int:

333
00:17:31,751 --> 00:17:35,653
the protocol we wanted int to implement and then in there,
加上我们希望 Int 实现的协议

334
00:17:35,721 --> 00:17:39,556
and the extension we would put all the implementations of
并且在扩展中，我们会将所有变量与方法

335
00:17:39,625 --> 00:17:42,926
the vars and methods in that protocol. And
的实现放在那里

336
00:17:42,995 --> 00:17:46,163
this is actually quite common to use an extension just for
这样用扩展是相当普遍的方法

337
00:17:46,232 --> 00:17:49,700
code book keeping. Well sometimes use an extension to implement
为了让代码更有序，用扩展来实现

338
00:17:49,769 --> 00:17:53,304
a whole protocol. It's just nice groups it all nicely.
整个协议。这样可以很好的将它们聚集在一起

339
00:17:54,740 --> 00:17:57,441
Okay, let's see an example of using protocols like
好的，我们来看一个例子，将协议看做

340
00:17:57,510 --> 00:18:01,045
the type they are. Okay, protocols are types. So
类型来使用。协议是类型

341
00:18:01,113 --> 00:18:04,114
let's see, here I have a protocol called Moveable.
看，我这里有一个协议，叫做 Moveable

342
00:18:04,183 --> 00:18:08,018
It has one method in it called, move to, all right?
它其中有一个方法叫做 move(to:)

343
00:18:08,087 --> 00:18:11,188
And I've created a class called Car, which can be moved
并且我创建了一个叫做 Car 的类，车可以被移动

344
00:18:11,257 --> 00:18:14,024
and another class called Shape, like triangle or
和另一个叫做 Shape 的类，像三角形或

345
00:18:14,093 --> 00:18:16,694
square, which can also be moved. Now a Car and
正方形，它也可以被移动。现在一个车

346
00:18:16,763 --> 00:18:20,263
a Shape, incredibly different things and one is class and
和一个形状，完全不同的两个东西，一个是类

347
00:18:20,332 --> 00:18:24,335
one is struct but both of them implement this same protocol.
一个是结构体，但它们都实现了同一个协议

348
00:18:24,404 --> 00:18:26,070
Okay, we're gonna see what it looks like in the code,
我们将会看到在这种情况下

349
00:18:26,139 --> 00:18:27,738
when you have this kind of situation,
的代码看起来是什么样的

350
00:18:27,806 --> 00:18:29,940
which it's perfectly legal to do this. And so
这样做是完全合法的。并且

351
00:18:30,008 --> 00:18:31,842
I've created a couple of vars down at the bottom there,
我在这下面创建了一些变量

352
00:18:31,910 --> 00:18:36,980
a prius, which is a Car, and a square, which is a Shape.
prius 是一个 Car 和一个 square 是一个 Shape

353
00:18:37,049 --> 00:18:39,249
All right, now I'm going to declare a var, thingToMove.
好的，那么我现在要声明一个变量， thingToMove

354
00:18:39,318 --> 00:18:44,288
It's gonna be of type Moveable. Remember I said,
它的类型应该是 Movable，还记得我说过

355
00:18:44,356 --> 00:18:47,391
protocols are types. So I made thingToMove be of type
协议是类型，我将 thingToMove 声明为

356
00:18:47,459 --> 00:18:50,862
Moveable and assigned it to prius, is this allowed?
Moveable 类型，并且将 prius 赋值给它，这样是合法吗

357
00:18:52,198 --> 00:18:54,898
Can I assign prius to the thingToMove? Sure,
我能将 prius 赋值给 thingToMove 吗？当然可以

358
00:18:54,967 --> 00:18:58,168
because a prius implements the Moveable protocol.
因为 prius 实现了 Moveable 协议

359
00:18:58,237 --> 00:19:00,304
It implements that move to over there and it and
它实现了那个 move(to:) 方法并且

360
00:19:00,372 --> 00:19:02,273
it also claims to implement the Moveable. So
它声明实现了 Movable

361
00:19:02,342 --> 00:19:05,075
this is a perfectly legal statement right here, but
所以这个是一个合法的语句

362
00:19:05,144 --> 00:19:09,847
this has made a variable that is not of type Car, or
但这一个不是 Car 类型或类似类型的变量

363
00:19:09,916 --> 00:19:13,851
something like that, it's of type Moveable. So, I can send
它是 Moveable 类型的变量，所以我可以给它

364
00:19:13,920 --> 00:19:18,655
messages like thingToMove.move that's perfectly legal, but
发消息，像 thingToMove.move() 这是完全合法的

365
00:19:18,724 --> 00:19:21,625
I can not say thingToMove.changeOil,
但我不能写 thingToMove.changeOil()

366
00:19:21,694 --> 00:19:25,930
even though a prius is a Car and Car implements changeOil.
尽管 prius 是一个 Car，并且实现了 changeOil()

367
00:19:25,998 --> 00:19:29,200
You see why I can't send that to thingToMove?
你能理解为什么不能向 thingToMove 传递那个信息吗

368
00:19:29,268 --> 00:19:33,937
Because thingToMove is a Moveable. It's not a Car,
因为 thingToMove 是 Moveable 类型，不是 Car 类型

369
00:19:34,006 --> 00:19:36,673
it's a Moveable. So even though the car that happens to
它是一个 Moveable 类型。所以尽管 Car 是

370
00:19:36,742 --> 00:19:40,311
be in that variable, it can do changeOil, I can't send it.
这个变量的一部分，Car 可以 changeOil()，我不能传递它

371
00:19:40,380 --> 00:19:42,947
Swift will not allow me to send that message because
Swift 不允许我传递这个信息，因为

372
00:19:43,015 --> 00:19:44,282
thingToMove in Swift's
在 Swift 的认知中 thingToMove

373
00:19:44,350 --> 00:19:47,751
mind is just a Moveable. The only thing Swift knows
是一个 Moveable 类型，Swift 只知道这一点

374
00:19:47,820 --> 00:19:50,421
that it can do is move to, right?
知道它只能做到 move(to:)

375
00:19:50,490 --> 00:19:53,056
So this is the most important thing on this entire slide,
这是这页幻灯片中最重要的东西

376
00:19:53,125 --> 00:19:57,394
is that red thing. You cannot do changeOil if you have a var
这红色的部分，你不能让 thingToMove 类型变量去

377
00:19:57,463 --> 00:20:02,033
which is of type thingToMove. But what are some things you
changeOil()。但是你能做什么呢

378
00:20:02,101 --> 00:20:05,169
can do? Well, I can say thingToMove equals square.
我可以写 thingToMove = square

379
00:20:05,237 --> 00:20:08,272
Cuz a square is a Shape, and a Shape implements Moveable.
因为 square 是 Shape 型，而 Shape 实现了 Moveable

380
00:20:08,341 --> 00:20:11,375
I could even have an array of Moveable and put a prius and
我甚至可以有一个 Moveable 类型的数组，并将 prius

381
00:20:11,443 --> 00:20:14,311
a square inside of it. Cuz even though a prius and
和 square 放进去。因为尽管 prius 和

382
00:20:14,380 --> 00:20:15,579
square are completely different,
square 是完全不同的

383
00:20:15,648 --> 00:20:17,882
one's a struct, one's a class, one's a Car, one's a Shape.
一个是结构体，另一个是类，一个是 Car，另一个是 Shape

384
00:20:17,951 --> 00:20:20,150
They're completely not really different,
它们不是完全不同的

385
00:20:20,219 --> 00:20:23,320
they can be in the same array, because they're both Moveable,
它们都可以放进同一个数组中，因为他们都是 Moveable 的

386
00:20:23,389 --> 00:20:26,957
you see that? And of course I can have functions that take
能理解吗？当然我也可以有接收 Moveable

387
00:20:27,026 --> 00:20:29,226
Moveables as an argument. Here's slide,
作为参数的函数，这是 slide(slider: Moveable)

388
00:20:29,295 --> 00:20:32,029
which takes a slider, which is a type of Moveable. And
它接收一个 slider，类型是 Moveable

389
00:20:32,097 --> 00:20:35,132
inside I can say slider.move(to: positionToSlideTo),
而在里面我可以写 slider.move(to: positionToSlideTo)

390
00:20:35,201 --> 00:20:37,501
and then I can call slide the prius,
而我可以调用 slide(prius)

391
00:20:37,570 --> 00:20:40,637
slide the square. Perfectly legal to say because those
slide(square)，这是完全合法的，因为

392
00:20:40,706 --> 00:20:43,473
are Moveables. Yeah, question? >> Does that mean that move
它们都是 Moveable 的，请问。 >> 这是否意味着

393
00:20:43,542 --> 00:20:44,842
to function where Car and
在 Car 中的 move(to:)

394
00:20:44,911 --> 00:20:47,044
Shape have to do the exact same thing, or
和在 Shape 中的 move(to:) 必须要做同样的事吗

395
00:20:47,113 --> 00:20:48,479
do they just- >> You mean,
或者.. >>你是问

396
00:20:48,548 --> 00:20:51,482
do the exact same thing like perform the same action? Okay,
像完成同样的行为的那样的同样的事吗？好的

397
00:20:51,551 --> 00:20:55,452
so the question is, does this mean that move to in Car and
那么他的问题是，在 Car 中的 move(to:) 和 Shape

398
00:20:55,521 --> 00:20:58,321
move to in Shape, do they have to do exact same thing?
中的 move(to:) 它们是不是要做同样的事

399
00:20:58,390 --> 00:21:00,824
And the answer is, no. They can do anything they want.
答案是，不是，它们可以做任何它们想的事

400
00:21:00,893 --> 00:21:03,760
They can do whatever move to makes sense for a Car or
它们可以做任何对车看起来有道理的 move(to:)

401
00:21:03,829 --> 00:21:05,162
whatever move to makes sense for
和对形状看起来有道理的 move(to:)

402
00:21:05,231 --> 00:21:07,898
a Shape. >> If you assign it to
>>[学生提问]

403
00:21:07,967 --> 00:21:10,434
squares. And you call move to,
[学生提问]

404
00:21:10,503 --> 00:21:13,404
how does it decide which move to to use?
[学生提问]

405
00:21:13,473 --> 00:21:14,237
>> Okay, so
>>好的

406
00:21:14,306 --> 00:21:17,340
the question is if I declare this Movable protocol and
>>他的问题是，如果我声明了这个 Moveable 协议

407
00:21:17,409 --> 00:21:19,142
then I say something are movable.
并且我说某物是 Moveable 的

408
00:21:19,211 --> 00:21:21,311
They are called move to, how does it know which one to use?
并且以它们调用 move(to:)，它怎么知道要使用哪个 move(to:) 方法

409
00:21:21,380 --> 00:21:25,883
Well, because Swift underneath knows which type it is, okay.
那是因为 Swift 知道它是什么类型的

410
00:21:25,951 --> 00:21:28,919
When we say thingToMove.something
当我们写 thingToMove.something

411
00:21:28,988 --> 00:21:30,587
at that level we're the programmer and
在这个层面我们是程序员

412
00:21:30,656 --> 00:21:33,023
Swift is enforcing that it has to be a movable.
并且 Swift 要求这必须是一个 Moveable 类型的

413
00:21:33,092 --> 00:21:36,393
But when it comes to actually executing the code now Swift
但当代码真正在执行的时候 Swift 看了并说

414
00:21:36,462 --> 00:21:40,030
looks and says, oh it's a Car, so I'm gonna use Car's moveTo.
喔，这是一个 Car 类型，那我将用 Car 的 move(to:)

415
00:21:40,099 --> 00:21:42,232
So Swift behind the scenes is doing it.
所以 Swift 在背后是这样做的

416
00:21:42,301 --> 00:21:44,801
But the whole reason that we're typing thingToMove
但我们写 thingToMove 是

417
00:21:44,870 --> 00:21:47,538
to be of type thing to move is cuz we're telling everyone
Moveable 类型，是因为我们希望告诉所有读

418
00:21:47,607 --> 00:21:50,207
who's reading our code, I'm just using this thing as
这段代码的人，我正用这东西作为一个

419
00:21:50,276 --> 00:21:53,611
a Moveable thing. I don't care that it's a car.
Moveable 类型的。我不管他是不是 Car

420
00:21:53,679 --> 00:21:56,480
My code works on anything that's Movable. So
我的代码对所有 Moveable 类型都适用

421
00:21:56,549 --> 00:22:00,183
I'm just communicating to people reading my code and
所以我正与阅读我的代码的人和我自己交流

422
00:22:00,252 --> 00:22:03,387
to myself in all that but Swift under the covers
但 Swift 是

423
00:22:03,455 --> 00:22:07,090
of course knows which move to execute. It is possible by
知道要去执行哪个 move(to:) 的。同时

424
00:22:07,159 --> 00:22:10,561
the way to have functions that take an argument that has to
一个函数可以接受一个实现了

425
00:22:10,630 --> 00:22:13,964
implement multiple protocols. So here the slipAndSlide is
多个协议的参数。那么这里 slipAndSlide

426
00:22:14,033 --> 00:22:17,968
it's function it's argument x. Those things have to implement
是一个函数并且接受参数 x，x 必须要实现

427
00:22:18,036 --> 00:22:20,503
Movable and they have to implement something called
Moveable 并且它也必须要实现另一个叫做

428
00:22:20,572 --> 00:22:23,574
slippery which is not shown on the slide. So now I cannot say
slippery 的协议，这个协议不在我们幻灯片里

429
00:22:23,643 --> 00:22:26,543
slipAndSlide(prius) because while prius is Movable,
所以我现在不能写 slipAndSlide(prius)，尽管 prius

430
00:22:26,612 --> 00:22:29,512
it's not slippery. And so this would not be allowed,
是 Moveable 但它不是 slippery，所以这样是不被允许的

431
00:22:29,581 --> 00:22:34,518
Swift would complain here. But that's how this &. That's how
Swift 在这里会报错。这就是 & 的意思

432
00:22:34,586 --> 00:22:40,123
you make it so it requires multiple protocol conformists.
用它来表示参数需要能实现多个协议

433
00:22:40,192 --> 00:22:43,561
So you're getting a feel for how we use a protocol init by
所以你能理解我们如何使用协议

434
00:22:43,629 --> 00:22:46,897
declaring vars and arguments to functions. So
以声明变量，作为函数的参数等形式

435
00:22:46,966 --> 00:22:49,633
it's only scratching the surface of protocols.
这只是协议的表面的东西

436
00:22:49,702 --> 00:22:51,301
Yeah, question. >> [INAUDIBLE]
请问 >>[学生提问]

437
00:22:51,370 --> 00:22:54,004
The thing to move [INAUDIBLE]
[学生提问]

438
00:22:54,073 --> 00:22:55,405
square. >> Yeah.
[学生提问]

439
00:22:55,474 --> 00:22:56,240
>> So when you
[学生提问]

440
00:22:56,309 --> 00:22:58,876
call function [INAUDIBLE] >> Here let me back up to
[学生提问] >> 让我翻回这里

441
00:23:05,618 --> 00:23:06,816
Okay, so what was that?
好你的问题是什么

442
00:23:06,885 --> 00:23:09,019
>> [INAUDIBLE] >> Yeah.
>>[学生提问]

443
00:23:09,088 --> 00:23:09,686
>> [INAUDIBLE]
[学生提问]

444
00:23:09,755 --> 00:23:11,321
>> Yeah, up there.
>>对，在这里

445
00:23:11,390 --> 00:23:13,790
>> So when you call method on
>>[学生提问]

446
00:23:13,859 --> 00:23:18,328
thingToMove. [INAUDIBLE] >> Okay, so he's saying,
[学生提问] >>好的，他是问

447
00:23:18,397 --> 00:23:23,500
look, I set thingToMove to be a prius. Then I call move to,
看，我将 thingToMove 赋值为 prius，接着我调用 move(to:)

448
00:23:23,569 --> 00:23:24,334
which one did it do?
它执行了哪个

449
00:23:24,403 --> 00:23:28,038
Obviously the prius. Then I set thingToMove to be square.
很明显是 prius 的那个，接着我将 thingToMove 赋值为 square

450
00:23:28,107 --> 00:23:31,307
Now if I called move to, it would use the square's one.
现在我再调用 move(to:)，它会执行 square 的那个

451
00:23:31,376 --> 00:23:34,211
So whatever the last thing it was set to, that's what it'll
所以就是他最后被赋值为什么，就会用哪个的

452
00:23:34,279 --> 00:23:37,848
use. Question? >> [INAUDIBLE]
请问 >>[学生提问]

453
00:23:37,917 --> 00:23:38,515
have to take it up here,
[学生提问]

454
00:23:38,584 --> 00:23:40,284
doesn't have to be mutating actually?
[学生提问]

455
00:23:40,352 --> 00:23:42,886
Are you allowed to just drop that whenever valid-
[学生提问]

456
00:23:42,955 --> 00:23:44,120
>> Great question,
>> 很好的问题

457
00:23:44,189 --> 00:23:48,025
he's saying up here look in Car, move to, no mutating.
他是问，看这里 Car 的 move(to:)，没有 mutating

458
00:23:48,094 --> 00:23:50,627
See, down here in Shape, we've got mutating. Up here,
再看到 Shape 中的 move(to:)，有 mutating 这上面

459
00:23:50,696 --> 00:23:55,131
we've got no mutating, that's because Car is a class.
我们没有放 mutating，那是因为 Car 是一个类

460
00:23:55,200 --> 00:23:58,101
Class is a reference type, they don't need mutating, so
类是引用类型，它们不需要 mutatitng

461
00:23:58,170 --> 00:24:03,407
it's perfectly fine. Any other questions about this? Okay,
所以这是没问题的。大家还有什么问题吗？好的

462
00:24:03,475 --> 00:24:07,244
excellent. So now let's talk about the uses of protocol.
很棒。那么我们来讲协议的用法

463
00:24:07,313 --> 00:24:09,646
Now we kinda know what protocols are and
现在我们知道协议是什么

464
00:24:09,715 --> 00:24:12,782
how we can put them in our API, how do we use it? Well,
也知道我们如何将它放到我们的应用程序接口，我们要如何使用它

465
00:24:12,851 --> 00:24:16,086
of super important to use is this MVC delegation thing,
这个 MVC 代理是很重要的

466
00:24:16,155 --> 00:24:18,656
right? We've got these generic view things,
我们有泛型视图

467
00:24:18,724 --> 00:24:21,324
like scroll views and table views and things like that.
像滚动视图（scroll view）和表格视图（table view）

468
00:24:21,393 --> 00:24:24,227
And then we've got these very specific controller things,
然后我们还有这些非常具体的控制器

469
00:24:24,296 --> 00:24:26,897
how does a generic thing talk to a specific thing without
在不知到对方是什么时，一个泛型如何

470
00:24:26,966 --> 00:24:29,132
knowing anything about that specific thing?
与一个具体类型通信呢

471
00:24:29,201 --> 00:24:31,902
Because obviously, when scroll view shifts from Apple,
因为，很显然的，滚动视图是由苹果发布的

472
00:24:31,971 --> 00:24:34,704
it knows nothing about Concentration games. So
它对我们的翻牌游戏完全不了解

473
00:24:34,773 --> 00:24:36,673
how do we do that? Well, we use protocols, okay,
所以我们如何做到这一点呢？我们使用协议

474
00:24:36,742 --> 00:24:40,044
so like simple, so this is the will, did, should
这很简单。这就是 will、did、should

475
00:24:40,112 --> 00:24:41,378
and the data at.
和 data at 方法

476
00:24:41,379 --> 00:24:42,645
So let's take a look how we do this, all right? So
那么我们来看看该怎么做

477
00:24:42,715 --> 00:24:46,050
kinda six steps. First a view, like a scroll view or
这有差不多六步。第一，视图，像滚动视图或

478
00:24:46,118 --> 00:24:49,285
table view, it declares it's delegation protocol.
表格视图，它声明它的代理协议

479
00:24:49,354 --> 00:24:51,721
That's just a protocol with a list of all the will, dids and
那就是一个有一系列 will, did, should

480
00:24:51,790 --> 00:24:55,225
shoulds that it wants to send. Remember protocols just a list
那些它希望传递的东西的协议，记得协议只是一个

481
00:24:55,294 --> 00:24:58,161
of methods, right? So it creates that protocol. Then
方法的清单，对吧。那么它创建了这个协议，接着

482
00:24:58,230 --> 00:25:01,465
the view, the scroll view, it creates a var in itself,
视图，像滚动视图，它在自己内部创建一个变量

483
00:25:01,534 --> 00:25:05,669
a public var, it's weak, turns out. And so
一个公开变量，是 weak 型的。所以

484
00:25:05,737 --> 00:25:10,573
it's an optional and that is of type that protocol. Okay,
它是可选类型的，并且这个变量的类型是那个协议

485
00:25:10,642 --> 00:25:13,711
now that's great because now the view whenever it wants
这样很棒，因为现在每当视图想要传递

486
00:25:13,779 --> 00:25:16,980
to send will, did, should, it just sends it to that var.
will, did, should，它只需要传递给那个变量就可以了

487
00:25:17,049 --> 00:25:19,083
And that works because that var is of type that protocol,
因这个变量的类型是那个协议，这是可行的

488
00:25:19,151 --> 00:25:20,918
so of course it can understand all the will, did,
所以当然它可以理解那些 will, did, should

489
00:25:20,986 --> 00:25:24,855
should. Then the controller comes along says, raises its
然后控制器过来并说，举起它的手来

490
00:25:24,924 --> 00:25:27,824
hand and says, I implement that scroll view delegate
说，我实现了滚动视图代理协议

491
00:25:27,893 --> 00:25:31,395
protocol by putting it on this little class line right there.
通过将它放在这个 class 的那一行

492
00:25:31,464 --> 00:25:35,765
And the controller sets itself as that delegate var,
接着控制器将那个代理的变量赋值为自己

493
00:25:35,834 --> 00:25:38,802
it literally says that delegate var equals self.
它实际上就是让那个代理变量等于自己

494
00:25:38,870 --> 00:25:41,939
So it's setting itself as the delegate and that's legal.
所以它让自己成为了那个代理变量，这是合法的

495
00:25:42,008 --> 00:25:43,940
Because the controller has claimed, hey,
因为那个控制器已经声明

496
00:25:44,009 --> 00:25:47,844
I implement that delegate and so, and that delegate is of
我将实现这个代理，并且这个代理的类型是

497
00:25:47,913 --> 00:25:51,715
type that protocol, all is good, okay. And then,
那个协议，一切都很好。接着

498
00:25:51,784 --> 00:25:54,384
of course, the controller has to implement all the methods
控制器当然要去实现这个协议中的

499
00:25:54,453 --> 00:25:56,886
in the protocol. But since this is an Objective-C
所有方法，但因为这是一个 Objective-C 协议

500
00:25:56,955 --> 00:25:59,790
protocol, it actually only has to implement the none optional
它只需要去实现那些非可选的方法

501
00:25:59,858 --> 00:26:02,659
ones. Okay and actually in delegation in iOS,
并且事实上，iOS 中的代理中

502
00:26:02,728 --> 00:26:05,261
almost all the methods are optional. So usually,
几乎所有的方法都是可选的，所以通常来说

503
00:26:05,330 --> 00:26:08,699
you only have to implement the one you really want. But
你只需要实现那些你需要的方法

504
00:26:08,767 --> 00:26:11,135
the controller implements the methods so they did
控制器实现了那些方法

505
00:26:11,203 --> 00:26:14,004
successfully fills out its claim to have implemented it.
因此它成功的完成了声明要去实现协议的任务

506
00:26:14,073 --> 00:26:17,808
And that's it. Now the view is hooked up to the controller.
就是这样。现在视图已与控制器建立了连接

507
00:26:17,877 --> 00:26:19,943
The view can send will, did, and should all it wants.
视图可以任意传递 will, did, should

508
00:26:20,012 --> 00:26:22,980
It has no idea what kind of class is doing it.
它不知道是什么样的类正在处理它

509
00:26:23,048 --> 00:26:25,015
All it knows about, it doesn't even know if it's a class,
它只知道，它甚至都不知道那是不是一个类

510
00:26:25,083 --> 00:26:26,884
could be a struct, it knows nothing about it.
可能是一个结构体，它对此一无所知

511
00:26:26,952 --> 00:26:29,219
All it knows is that that thing implements its protocol,
它只知道那个东西实现了它的协议

512
00:26:29,287 --> 00:26:30,955
so it knows that it can send will, did, and
因此它可以向它传递 will, did, should

513
00:26:31,023 --> 00:26:33,790
should to it through that delegate var. Okay,
通过那个代理变量

514
00:26:33,859 --> 00:26:37,761
make sense? So let's look at the code for
好的，能理解吗？那么让我们以滚动视图为例子来看看

515
00:26:37,830 --> 00:26:41,098
this with the example of a scroll view, okay. Oh, yeah,
实现这个的代码。噢

516
00:26:41,166 --> 00:26:45,368
sorry. Yeah, you find this delegation everywhere in iOS,
抱歉，还有，你会在 iOS 中经常遇到这样的代理

517
00:26:45,437 --> 00:26:49,840
it was designed in Objective-C world. In Swift, we have
它是在 Objective-C 的世界中设计的。在 Swift 中，我们有

518
00:26:49,909 --> 00:26:52,375
closure, which I'm gonna talk about later in this lecture.
闭包，这个我等一下就会讲到

519
00:26:52,444 --> 00:26:56,846
And you could use closures for some of this stuff. But
而你可以用闭包来做这一些事情

520
00:26:56,915 --> 00:27:00,451
even with closures, delegation is pretty cool way to do this,
但是就算是用闭包，代理也是一个完成这件事的很好的方法

521
00:27:00,519 --> 00:27:03,653
have this blind communication. All right, so
通过这样的匿名通信。好的

522
00:27:03,722 --> 00:27:06,824
let's look at the example of UIScrollView. So this is what
让我们来看看 UIScrollView 这个例子，那么这个就是

523
00:27:06,892 --> 00:27:10,527
the var that the scroll view would have in itself.
那个在滚动视图内部的变量

524
00:27:10,595 --> 00:27:13,363
Okay, this is a scroll view var. It's a weak,
这是一个滚动视图中的变量，它是 weak 型的

525
00:27:13,431 --> 00:27:17,034
why is it weak, by the way? Because here the view
为什么它是 weak 型的？因为在这里，这个视图

526
00:27:17,103 --> 00:27:19,236
is gonna have a pointers to the controller, and
会有指向控制器的指针

527
00:27:19,305 --> 00:27:21,838
we know that the controller has a lot of pointers to
并且我们知道控制器有许多指向视图的指针

528
00:27:21,907 --> 00:27:25,141
the view. They'd be keeping themselves in the heap. Okay,
它们被存储在堆中

529
00:27:25,210 --> 00:27:28,478
so what this view is saying here is, I wanna point to
这个视图在这里是说，我想要指向

530
00:27:28,547 --> 00:27:32,483
whoever receives my will, did, and shoulds. But if that will,
接收我的 will, did, should 的东西，但如果

531
00:27:32,551 --> 00:27:34,684
did, and should guy wants to leave the heap,
它想离开堆

532
00:27:34,753 --> 00:27:36,787
that's fine by me, just set this to nil and
我没有意见，只要将这个设为 nil 就好了

533
00:27:36,856 --> 00:27:40,190
I'll stop sending messages to it. Okay, so that way,
而我会停止向它传递信息。好的，通过这样的方式

534
00:27:40,259 --> 00:27:42,759
the view won't keep the controller in the heap.
视图不会导致控制器一直被留在堆里

535
00:27:42,828 --> 00:27:45,495
So anyway, notice this is optional because it's weak.
那么，留心这是一个可选类型因为它是 weak 的

536
00:27:45,564 --> 00:27:47,430
This is the delegate, it's of type UIScrollView delegate.
这是代理，它的类型是 UIScrollViewDelegate

537
00:27:47,499 --> 00:27:49,332
This is what that protocol looks like,
这就是那个协议的样子

538
00:27:49,401 --> 00:27:52,769
it's an Objective-C protocol. It's called UIScrollDelegate,
它是一个 Objective-C 协议，叫做 UIScrollDelegate

539
00:27:52,838 --> 00:27:54,338
and it's got all those funcs in there.
而它有那些函数

540
00:27:54,406 --> 00:27:57,207
ScrollView did scroll to here. Give me the view for
ScrollView 刚刚滚到了这里，给我在这里

541
00:27:57,276 --> 00:28:00,010
zooming over here. It's got about 15 of them in there,
缩放的视图。这大概有15个这样的函数

542
00:28:00,079 --> 00:28:02,212
if you go look at the documentation. So
如果你去看一下文档的话

543
00:28:02,281 --> 00:28:05,148
now the controller comes along, MyViewController,
那么现在控制器过来，MyViewController

544
00:28:05,217 --> 00:28:09,920
and it puts comma, UIViewCont, UIScrollViewDelegate on
并且它的最后有 ,UIScrollViewDelegate

545
00:28:09,989 --> 00:28:13,157
the end and claiming I implement that protocol.
这表示它要实现这个协议

546
00:28:13,225 --> 00:28:15,893
Then, in its probably in its outlet setter,
接着，应该是在它的出口（outlet）设置器

547
00:28:15,961 --> 00:28:19,530
we'll see an example of this today. When that scrollView
我们今天会看这样的例子。当这个滚动视图

548
00:28:19,598 --> 00:28:22,499
gets hooked up on iOS, in the didSet of that,
与 iOS 建立连接后，在它的 didSet 中

549
00:28:22,568 --> 00:28:26,036
it probably says, scrollView.delegate = self.
应该会有这样一段: scrollView.delegate = self

550
00:28:26,105 --> 00:28:29,706
This is a legal statement to say because delegate, which is
这是一个合法的语句，因为代理

551
00:28:29,774 --> 00:28:34,111
this thing up here, is of type UIScrollViewDelegate. And
也就是这个东西，它的类型是 UIScrollViewDelegate 而

552
00:28:34,179 --> 00:28:38,315
MyViewController says over here that it implemented that.
MyViewController 声明它实现了这个协议

553
00:28:38,384 --> 00:28:42,252
So it's legal for it to set itself as the delegate. Okay,
所以它将自己赋值给代理是合法的

554
00:28:42,321 --> 00:28:44,655
and once it does this, they are hooked up, and
它这样做之后，它们就建立了连接

555
00:28:44,723 --> 00:28:47,524
now the view can send will, did, said to the controller
现在视图就可以传递 will, did, should

556
00:28:47,593 --> 00:28:50,894
all at once. Okay, so that's delegation,
给控制器了。好的，这就是代理

557
00:28:50,962 --> 00:28:54,765
probably one of the most obvious uses of protocols.
大概是最明显的协议的用处之一

558
00:28:54,833 --> 00:28:57,066
What's another one? Okay, remember, I talked about that
另一个是什么？还记得我讲过的

559
00:28:57,135 --> 00:28:59,803
key in the dictionary in the hashable business, right?
在字典类型中的键和它的可哈希性吗

560
00:28:59,872 --> 00:29:02,406
So of course, the key in the dictionary has to be hashable.
当然，字典中的键必须是可哈希的

561
00:29:02,475 --> 00:29:05,442
How do we enforce this in our API? Well,
我们如何在我们的应用程序结构中强制做到这点呢

562
00:29:05,511 --> 00:29:08,211
there is a protocol called Hashable.
有一个协议的名字叫做 Hashable

563
00:29:08,280 --> 00:29:10,781
It inherits from another protocol called Equatable, and
它继承了另一个叫做 Equatable 的协议

564
00:29:10,849 --> 00:29:13,149
that's because you know anything about Hashtables.
那是因为，你知道关于哈希表的那些

565
00:29:13,218 --> 00:29:16,319
When you hash something, it's likely to be a unique hash but
当你哈希什么东西是，它很有可能是一个唯一哈希值

566
00:29:16,388 --> 00:29:17,888
it's not gonna guaranteed.
但这不是一定的

567
00:29:17,956 --> 00:29:21,324
You have to follow it up by actually using equals to see
你必须要接着用等于去比较一下

568
00:29:21,393 --> 00:29:25,529
if the two things are actually equal, so we hash in works.
来看是不是有两个东西确实是相等的，这就是哈希的做法

569
00:29:25,598 --> 00:29:28,332
So that's why Hashable inherits from Equatable.
因此 Hashable 是继承 Equatable 的

570
00:29:28,400 --> 00:29:30,333
So if you wanna be Hashable, you also have to be able to
如果你是可哈希的，那么你一定也是可以

571
00:29:30,402 --> 00:29:32,702
check if you're equal to something else. Now this is of
被确定是否与什么相等

572
00:29:32,771 --> 00:29:35,606
super simple protocol, it only has one var in it.
这是一个非常简单的协议，它其中只有一个变量

573
00:29:35,674 --> 00:29:40,176
It's a get only var, which is the hash value.
那是一个只能被获取的变量，这个变量就是哈希值

574
00:29:40,245 --> 00:29:44,314
Some integer, that hopefully, uniquely represents you,
一个整数，幸运的话，能唯一表示你

575
00:29:44,382 --> 00:29:47,918
that's what this is. Now, let's look at Equatable, okay,
这就是它的意思。那么现在我们来看看 Equatable

576
00:29:47,986 --> 00:29:50,453
which, cuz that's another protocol that is inherited and
因为这是另一被继承的协议

577
00:29:50,522 --> 00:29:53,022
thus, required here. What does that look like?
因此它也是需要被实现的，那么看看它是怎样的

578
00:29:53,091 --> 00:29:55,258
That's a very simple protocol as well.
这也是一个非常简单的协议

579
00:29:55,327 --> 00:29:57,861
It has one function in it, one method,
它其中只有一个函数，一个方法

580
00:29:57,930 --> 00:30:01,431
which is static. Meaning it's on the type, like get unique
这是一个静态（static）方法，意味着这是定义在这个类型上的

581
00:30:01,500 --> 00:30:05,401
identifier was in card, remember that? And its name is
就像 card 中的 getUniqueIdentifier，还记得吗

582
00:30:05,470 --> 00:30:09,506
==. In Swift, remember, names of methods can be like emoji.
它的名字是 ==。在 Swift 中，记得名字甚至可以是表情（emoji）

583
00:30:09,575 --> 00:30:12,709
It's not required to be alpha numeric characters, so
它不一定要是字母和数字

584
00:30:12,777 --> 00:30:17,080
they chooses to be called ==, which is kind of cool. And
它被叫做 == 这挺酷的

585
00:30:17,149 --> 00:30:20,283
the arguments are a left-hand side and a right-hand side,
它的参数是 lhs（等号左边）和 rhs（等号右边）

586
00:30:20,352 --> 00:30:24,454
notice that the type is Self, this is a type method, so self
留心它们的类型是 Self，这是一个定义在类型上的函数，因此 Self

587
00:30:24,523 --> 00:30:27,824
is the type. So if this were implemented by int, if int
就是那个类型。因此如果这个协议被 Int 实现，如果 Int

588
00:30:27,893 --> 00:30:32,262
were implementing equitable, self would be int. Okay,
要实现 Equatable，Self 就是 Int

589
00:30:32,331 --> 00:30:34,498
cuz it would be a type function on int, and so
因为这就是一个在 Int 类型上定义的函数

590
00:30:34,566 --> 00:30:35,231
the left-hand side and
所以 lhs 和

591
00:30:35,300 --> 00:30:37,233
the right-hand side would be ints of course. So
rhs 自然就是 Int 类型了

592
00:30:37,302 --> 00:30:40,503
this is basically saying, that your type has to have an ==
所以这就是再说，你的类型中必须有一个 == 方法

593
00:30:40,572 --> 00:30:44,173
method that compares two ints, or whatever you are. And sees
这个方法可以比较两个整数或者其它什么

594
00:30:44,242 --> 00:30:48,111
if they're equal, and returns a bool, yes or no. Okay, now,
并看看它们是否相等，并且返回一个布尔类型，真或者假

595
00:30:48,180 --> 00:30:51,047
this is, that's so that's what you have to do to be Hashable.
这就是如果你想成为可哈希的类型需要满足的条件

596
00:30:51,116 --> 00:30:55,485
But what's really cool, that the == operator in Swift,
但还有一点很酷，在 Swift 中，== 这个操作符

597
00:30:55,553 --> 00:30:59,389
okay, when you say like x == y, that's actually not like
当你使用 x == y 是，那并不是像

598
00:30:59,457 --> 00:31:02,125
built into Swift or anything. All that does is look for
在 Swift 中内置好的，Swift 只是去找

599
00:31:02,194 --> 00:31:06,162
this method, okay. So any two, any class can use,
这个方法。所以任何类都可以使用

600
00:31:06,231 --> 00:31:10,200
can do == as long as you implements this protocol. So
==，只要你实现了这个协议

601
00:31:10,268 --> 00:31:13,069
this protocol is required to make the Hashable work, but
这个协议是 Hashable 的条件，但

602
00:31:13,138 --> 00:31:16,506
it also makes the == operator work. And we're gonna see this
它也可以让 == 这个运算符工作。我们将看到这样的例子

603
00:31:16,575 --> 00:31:20,977
in our concentration demo when I go to implement this. So,
当我在我们的翻牌游戏中去实现它的时候

604
00:31:21,046 --> 00:31:25,048
now that we know that Hashable means you can be a key
现在我们知道可哈希意味着你可以作为一个键

605
00:31:25,116 --> 00:31:27,750
in a dictionary, how is this expressed? Well,
传给字典，但这是如何表达的呢

606
00:31:27,819 --> 00:31:31,054
dictionary which is a generic type, right? It's got these
字典是个泛型（generic type），对吧

607
00:31:31,122 --> 00:31:33,256
two types, the type of the key and the type of the value.
它其中有这两个类型，键的类型和值的类型

608
00:31:33,325 --> 00:31:37,693
It declares itself as Dictionary<Key: Hashable,
字典是这样被声明的 Dictionary<Key: Hashable, Value>

609
00:31:37,762 --> 00:31:42,031
Value>, and that means that key can only work there if
这就说明一个键必须是 Hashable 的

610
00:31:42,100 --> 00:31:47,237
it's Hashable. So this is how we use protocols to constrain
才能被放在那里，这就是我们用协议来限制

611
00:31:47,305 --> 00:31:50,874
these generic types, right? Now Value, right there
这些泛型的。同时 Value

612
00:31:50,943 --> 00:31:53,343
in the dictionary, it doesn't have any colon anything, so
在字典中，它没有 :Anything

613
00:31:53,412 --> 00:31:54,645
Value could be any type.
因此 Value 可以是任何类型

614
00:31:54,713 --> 00:31:57,147
You can put any type whatsoever as the value
你可以吧任何类型放在那当做值

615
00:31:57,216 --> 00:32:01,918
in a dictionary. But the key has to implement hashable. So
但键必须要实现了 Hashable 这个协议

616
00:32:01,987 --> 00:32:07,324
let's go into concentration and do this very thing.
那么我们回到我们的翻牌游戏并实现这个

617
00:32:07,392 --> 00:32:09,992
What do we have in a dictionary? Well, we have one
我们字典中有什么？我们有一个

618
00:32:10,061 --> 00:32:13,530
dictionary, it's that emoji thing. It's, keys are int,
字典，就是表情的那个，它的键是 Int 型

619
00:32:13,599 --> 00:32:16,366
ints are hashable so we're good, and the values
Int 是可哈希的，这是可以的，而值是

620
00:32:16,434 --> 00:32:19,802
are the emoji. And the int is our card.identifier.
那些表情，而 Int 就是我们的 card.identifier

621
00:32:19,871 --> 00:32:22,839
Remember that card identifier? So, I don't want to do that.
还记得我们的 card.identifier 吗，我不想这么做

622
00:32:22,907 --> 00:32:27,210
I want my keys in my emoji dictionary to be cards.
我想在我的表情字典中，键就是牌

623
00:32:27,279 --> 00:32:29,046
I want to look up the cards directly,
我想直接去查找那些牌

624
00:32:29,114 --> 00:32:30,980
I don't want any of that looking at the int thing,
我不想再去找那个整型

625
00:32:31,049 --> 00:32:34,183
that's ridiculous. So, if I go over here to ViewController.
这很没有逻辑，因此我们来到我的 ViewController

626
00:32:34,252 --> 00:32:35,518
Here it is right here, actually.
它在这里

627
00:32:35,587 --> 00:32:39,489
See, here is my emoji thing, int to string, int keys,
看，这就我们的表情的那东西，从 Int 到 String，Int 型的键

628
00:32:39,557 --> 00:32:43,627
string values, this has to be hashable, it is right now.
String 型的值。这里的类型必须要是可哈希的，它现在是的

629
00:32:43,695 --> 00:32:44,594
But I don't want that,
但我不想要它

630
00:32:44,663 --> 00:32:46,329
i just want to look up the cards directly.
我想直接在 cards 中查找

631
00:32:46,398 --> 00:32:47,531
I don't want to use the identifier,
我不想再用这个识别符

632
00:32:47,599 --> 00:32:51,134
I am just going to take this identifier right off of here
我要直接就把这里的 identifier 删去

633
00:32:51,203 --> 00:32:54,036
and when I do this, I'm gonna get errors.
并且当我这样做了之后，我会得到错误

634
00:32:54,105 --> 00:32:58,508
And why am I gonna get errors? Because card, see right here?
而我为什么会得到错误呢？因为 card，看到这了吗

635
00:32:58,577 --> 00:33:01,811
Let's see if we can make this a little wider so
让我看看能不能把它变宽点

636
00:33:01,880 --> 00:33:06,683
you can see it a little better down here.
你可以看得更清楚

637
00:33:06,752 --> 00:33:11,421
It says right here that we cannot subscript,
这里它说我不能...

638
00:33:11,490 --> 00:33:14,691
oh, sorry. Okay, it says cannot subscript a value of
啊抱歉，它说在 [Int:String] 类型变量中

639
00:33:14,760 --> 00:33:16,993
int string with a card. Of course okay,
我们不能用 card 作为下标。当然

640
00:33:17,062 --> 00:33:20,530
I said that the keys were int, and here I'm trying to do it
我这里写的是键的类型应该是 Int，而在这里我正

641
00:33:20,599 --> 00:33:22,031
by card. So I'm just gonna say okay,
试图将 card 型作为键，那么我就说

642
00:33:22,100 --> 00:33:25,001
that I'm gonna have them be cards instead. So I'm just
好啊，那我就把这里改成 Card， 那么

643
00:33:25,070 --> 00:33:28,772
gonna have my dictionary, have keys of card,values of string.
我就让我的字典以 Card 为键，以 String 为值

644
00:33:30,175 --> 00:33:36,979
So now, what do we got here? It says type card
那么现在这个错误是什么呢？它说 Card 这个类型

645
00:33:37,048 --> 00:33:40,449
does not conform to protocol hashable, it worked, okay.
没有遵从 Hashable 这个协议，这生效了！

646
00:33:40,518 --> 00:33:44,221
I tried to make a card be the key of my dictionary and
我尝试让我的 Card 作为我的字典的键

647
00:33:44,289 --> 00:33:47,290
it says, no, card does not conform the protocol hashable.
而它说，不行，Card 没有遵从 Hashable 这个协议

648
00:33:47,359 --> 00:33:50,293
So the declaration dictionary which you can go look up in
字典的声明

649
00:33:50,362 --> 00:33:52,028
the documentation,
你们可以去文档中看

650
00:33:52,097 --> 00:33:55,465
it says card, the key has to be hashable and it wasn't. So
它会说键必须要是可哈希的，而这里的不是

651
00:33:55,533 --> 00:33:58,368
let's go make card be hashable, so
那么我们现在来让我们 Card 成为可哈希的

652
00:33:58,437 --> 00:34:00,303
we won't have this error any more, so
我们就不会再有这个错误了

653
00:34:00,371 --> 00:34:03,740
I'm gonna go over to card, here it is. And here is card,
我们来到 Card，它在这，这是 Card

654
00:34:03,808 --> 00:34:09,912
I'm just gonna say, okay, card is hashable.
我只用写 Card : Hashable

655
00:34:09,981 --> 00:34:12,983
So I just made card hashable, now of course Swift is gonna
我就让 Card 成为可哈希的，当然现在 Swift 会

656
00:34:13,051 --> 00:34:16,486
look at this and say whoa wait a second errors here, card
发现这个然后说，等等，有错误

657
00:34:16,555 --> 00:34:19,222
does not conform to hashable. Card does not conform
Card 没有遵从协议 Hashable。Card 没有遵从协议

658
00:34:19,290 --> 00:34:22,058
to equatable which it doesn't because I don't implement
Equatable，它确实没有，因为我还没有实现

659
00:34:22,127 --> 00:34:25,528
those methods the hash value or the equals equal thing.
那个哈希值和 == 的方法

660
00:34:25,596 --> 00:34:28,264
What's really cool in Swift, look at the fix button here.
Swift 中很酷的东西，看到了这个 Fix 按钮了吗

661
00:34:28,333 --> 00:34:32,669
Do you wanna add protocol stubs? Oh, yes please. And
你想要添加协议的默认实现吗？哦，好的

662
00:34:32,737 --> 00:34:35,538
look what it did. It added a stub for hashable, and
来看看它做了什么，它将 Hashable 和 Equatable 的

663
00:34:35,607 --> 00:34:38,808
a stub for equitables. Now I just have to implement these.
桩代码添加了进来。现在我只需要实现这个

664
00:34:38,877 --> 00:34:41,611
So, making hash value, which has to be get only,
那么，得到 hashValue，这是只能被获取的

665
00:34:41,679 --> 00:34:46,149
that's easy. I'm just gonna return my identifier. That's
这很容易，我只需要返回我的 identifier 那是一个

666
00:34:46,217 --> 00:34:50,987
an extremely good hash for a card because it's unique for
对一张牌来说非常好的哈希值，因为它是唯一确定那张牌的

667
00:34:51,056 --> 00:34:54,291
that card. And the equals equals is also really easy
而那 == 也是非常简单的

668
00:34:54,359 --> 00:34:56,526
too. I just have to compare these two cards.
我只需要比较这两张牌

669
00:34:56,594 --> 00:34:59,462
I'm gonna return if the left hand side's identifier
我只用返回 lhs.identifer == rhs.identifier

670
00:34:59,530 --> 00:35:03,433
equals the right hand side's identifier. So there we go.
就可以了

671
00:35:03,501 --> 00:35:06,069
I've implemented hashable and equatable. So
我已经实现了 Hashable 和 Equatable

672
00:35:06,138 --> 00:35:08,538
now if I go back to my ViewController,
现在如果回到我们的 ViewController

673
00:35:08,607 --> 00:35:11,507
will that error be gone? Here's the error over here.
那个错误会消失吗，那个错误在这里

674
00:35:11,576 --> 00:35:15,611
So let's make Xcode recompile, and sure enough look,
现在我们来让 Xcode 重新编译，看

675
00:35:15,680 --> 00:35:19,015
no problems. It's completely fine with that, okay, and
没有问题。它是完全能接受这个的

676
00:35:19,084 --> 00:35:23,053
that's because I made this hashable. Now,
那是因为，我让这个成为可哈希的了

677
00:35:23,121 --> 00:35:24,787
we can get another benefit of this.
这么做还有一个好处

678
00:35:24,856 --> 00:35:28,291
Let me go back to card. And I told you before, I didn't like
让我们回到 Card，我曾讲过，我不希望

679
00:35:28,360 --> 00:35:30,861
that this identifier was public. I see no reason for
这个 identifier 是公开的，我找不到任何理由

680
00:35:30,929 --> 00:35:32,495
it to be public. And we know we don't need it
让它成为公开的，我们现在在我们的

681
00:35:32,564 --> 00:35:35,064
now to look in our emoji thing, so I'm just gonna make
表情那里也不需要访问它了，所以我将让它成为

682
00:35:35,133 --> 00:35:38,534
it private. And let's see if that's gonna work.
私有的，让我们来看看这能不能生效

683
00:35:38,603 --> 00:35:40,069
So is private gonna work?
它是私有的能生效吗

684
00:35:40,138 --> 00:35:43,139
Let's build and see. Oh, no, we have some errors over here.
让我们组建然后看看，哦不好，我们这有一些错误

685
00:35:43,207 --> 00:35:45,942
So let's go look at them. Here's an error here, it says,
让我们去看看它们，错误在这里，它说

686
00:35:46,011 --> 00:35:49,512
identifier is inaccessible due to private protection level.
identifier 是不可访问的，因为它是私有的

687
00:35:49,581 --> 00:35:51,714
That's right, I made identifier private.
是的，我将它变为了私有的

688
00:35:51,783 --> 00:35:56,086
What's it trying to do here? Oh, here I'm trying to see if
我们这里在尝试做什么？哦，这里我正在尝试去看

689
00:35:56,154 --> 00:36:01,390
two cards match, oh, well cards implement equatable now.
这两张牌是否能配对上，现在 Card 已经实现了 Equatable

690
00:36:01,459 --> 00:36:05,328
So I can just go like this card matchIndex
那么我就只用这样写

691
00:36:05,397 --> 00:36:10,033
=cards[index] because I can compare cards directly,
cards[matchIndex] == cards[index]，因为我现在可以

692
00:36:10,102 --> 00:36:12,268
now. They implement equatable, right?
直接比较牌了，它们实现了 Equatable

693
00:36:12,337 --> 00:36:15,305
Now if we build, that's gone away. So
如果现在我们组建，错误就消失了

694
00:36:15,373 --> 00:36:17,440
we had a huge benefit by making that equatable and
所以让它成为 Equatable 和 Hashable

695
00:36:17,508 --> 00:36:20,943
hashable. We got to use it directly in our emoji thing to
是有很大好处的。我们可以直接在我们的表情里使用它

696
00:36:21,012 --> 00:36:24,147
make that code look nice and look how nice this code looks.
让代码看起来非常的好，看这代码多棒

697
00:36:24,216 --> 00:36:26,549
Compared to how it used to look with that identifier,
相比我们之前用那 identifier

698
00:36:26,618 --> 00:36:30,020
right, so we cleaned up our code on the use side and
所以我们在调用的地方简洁了我们的代码

699
00:36:30,088 --> 00:36:31,354
we were able to go back to card and
并且我们在 Card 中

700
00:36:31,423 --> 00:36:33,789
make something that really didn't need to be public,
让不需要公开的东西私有了

701
00:36:33,858 --> 00:36:38,194
completely private. Pretty cool with that? Okay,
这样挺酷的吧

702
00:36:38,263 --> 00:36:41,164
so you're starting to see the power of protocols a building
你们会渐渐感受到协议在这里是多么的强大

703
00:36:41,233 --> 00:36:45,402
here. So let's go back and look at even more protocol
那么让我们回到这里来看更多酷的

704
00:36:45,470 --> 00:36:50,139
stuff that's cool. All right, there
协议的那些东西。好的，这是

705
00:36:50,208 --> 00:36:54,610
is the demo, okay, let's talk a little about this multiple
那个示例。让我们来讲讲这个多重

706
00:36:54,679 --> 00:36:59,782
inheritance kind of trick. Consider countable range,
继承的技巧，想想可数区间

707
00:36:59,851 --> 00:37:02,652
remember countable range zero dot dot less than something
还记得可数区间就是 0..<Something 这样就会

708
00:37:02,720 --> 00:37:06,055
creates this countable range of ints from zero that thing
创建一个从 0 到 Something - 1 的可数区间

709
00:37:06,123 --> 00:37:10,293
minus one. Countable range implements a lot of protocols.
可数区间实现了非常多的协议

710
00:37:10,362 --> 00:37:14,063
If you go look at countable range, it may have 12 or
如果你去看看可数区间的代码，它大概会有 12

711
00:37:14,132 --> 00:37:16,866
15 different protocols. Well, two of the most interesting
还是 15 个不同的协议。那么其中两个最有趣的的

712
00:37:16,935 --> 00:37:19,135
ones it implements are sequence.
一个是序列（Sequence）

713
00:37:20,772 --> 00:37:22,088
Which makes sense,
这是有道理的

714
00:37:22,089 --> 00:37:23,405
right? A countable range is a sequence of numbers from zero
对吧，一个可数区间一个从 0 开始

715
00:37:23,474 --> 00:37:26,643
to something else. And also collection,
到某个数字的数字序列。还有集合（Collection）

716
00:37:26,711 --> 00:37:29,345
because accountable range is also a collection of things.
因为可数区间是是一个一些东西的集合

717
00:37:29,413 --> 00:37:30,713
If it's accountable range of int,
如果它是一个 Int 型的可数区间

718
00:37:30,782 --> 00:37:32,815
it's a collection of int or whatever. And
那么它就是 Int 型的集合，其他同理

719
00:37:32,884 --> 00:37:36,819
so these two protocols define a lot of fun things like
而这两个协议定义了许多好玩的东西

720
00:37:36,888 --> 00:37:41,057
sequence defines really only one method,
像 Sequence 只定义了一个方法

721
00:37:41,125 --> 00:37:44,127
next, which goes to the next thing in the sequence.
next，到一个序列中的下一个元素的位置

722
00:37:44,196 --> 00:37:46,862
But that let you do for in, anything that implements
但它允许你做 for in，任何实现了

723
00:37:46,931 --> 00:37:49,799
the sequence protocol could do for in, okay, just like
Sequence 这个协议的东西都可以做 for in

724
00:37:49,867 --> 00:37:53,269
anything that's hashable can be a key in the dictionary.
就像任何可哈希的东西可以作为字典的键

725
00:37:53,338 --> 00:37:55,571
And then, collection has even more methods,
接着， Collection 有更多的方法

726
00:37:55,640 --> 00:37:59,509
all the indexing, sub-scripts, all that stuff is all
那些索引，下标，那些东西

727
00:37:59,578 --> 00:38:03,345
in the collection protocol. Now, why do we do this?
都在 Collection 这个协议中，那么为什么我们要这样做？

728
00:38:03,414 --> 00:38:06,216
Why do we have countable range implement all these protocols?
为什么我们有可数区间来实现这些协议

729
00:38:06,284 --> 00:38:09,652
Well, because array implements all those as well, and so
因为数组也实现了它们，同样

730
00:38:09,721 --> 00:38:13,990
does dictionary and set and string. All these classes
字典、集合（Set）和字符串也实现了它们。所以这些类

731
00:38:14,059 --> 00:38:17,593
that are sequences of things or collections of things
它们是一些东西的序列，或者一些东西的集合

732
00:38:17,662 --> 00:38:20,129
implement all these exact same things. And
它们实现了同样的东西

733
00:38:20,198 --> 00:38:23,799
so I as a programmer only have to learn these things once.
所以我作为一个程序员只用学一次这些东西

734
00:38:23,868 --> 00:38:26,902
Okay, I only have to learn learn for in once. And
我只用学 for in 一次

735
00:38:26,971 --> 00:38:29,672
all I need to know is that the thing I wanna for
并且我只需要知道我想对其进行 for in 操作

736
00:38:29,741 --> 00:38:32,641
in over has to be a sequence. So I can just look to see does
的东西，必须是一个序列。所以我可以只去看看

737
00:38:32,710 --> 00:38:34,243
this thing implement that protocol? Or
这东西是否实现了那个协议

738
00:38:34,312 --> 00:38:37,947
I can even invent my own things that I can for in over.
或者我甚至可以创造我自己的类型，我能for in 它

739
00:38:38,016 --> 00:38:40,750
All I have to do is implement the sequencing, the sequence
所有我需要做的只是实现这个 Sequence 协议

740
00:38:40,819 --> 00:38:43,820
protocol which really only has one method in it ultimately.
Sequence 这个协议中只有一个方法

741
00:38:45,423 --> 00:38:49,392
So that's one good reason why because I learned indexing,
这很好的解释了为什么我学了索引

742
00:38:49,461 --> 00:38:52,662
indexOf to get things and I can now do indexOf
indexOf 来获得一些东西，那么现在就可以 indexOf

743
00:38:52,731 --> 00:38:54,630
on a string and find a character on a string or
一个字符串并找到一个字符，或

744
00:38:54,699 --> 00:38:57,667
I can do indexOf in an array and find in there.
我可以 indexOf 一个数组并在其中查找

745
00:38:57,736 --> 00:39:01,070
I can even do indexOf on accountable range not super
我甚至可以 indexOf 一个可数区间

746
00:39:01,139 --> 00:39:04,273
valuable but if the count of a range wasn't of int,
这不是很有用，但如果这个可数区间不是 Int 型的

747
00:39:04,342 --> 00:39:06,976
then it might be interesting to do index of to try and
这可能也会很有趣，去 indexOf

748
00:39:07,044 --> 00:39:10,847
find something where it is in the range, okay. But
并在这个区间中找到某物在哪

749
00:39:10,915 --> 00:39:13,816
there's a bigger and better reason why we do this.
但我们这么做还有个更重要的原因

750
00:39:13,885 --> 00:39:17,854
And that's because there's a little bit of magic in, or not
那是因为在 Swift 中，有一点小魔法，或者说

751
00:39:17,923 --> 00:39:21,590
magic but really good design implementation in Swift.
不是魔法，但是非常好的设计实现

752
00:39:21,659 --> 00:39:25,061
Which is that for protocols it is possible to provide default
对于协议来说，协议是可以提供默认

753
00:39:25,130 --> 00:39:31,868
implementations of methods. Default implementations
的方法的实现的。默认的方法

754
00:39:31,937 --> 00:39:37,006
of methods. So this makes it possible for
实现，这让我们有可能

755
00:39:37,075 --> 00:39:39,709
us to implement indexOf for
来为这些所有的类实现

756
00:39:39,777 --> 00:39:45,014
all of these classes in one place. So that's why,
indexOf，在一个地方，这就是为什么

757
00:39:45,082 --> 00:39:47,617
again, we think it's like multiple inheritance cuz
我们认为它像多重继承

758
00:39:47,686 --> 00:39:51,120
they're actually gonna inherit implementation. So where do
因为它们实际上是会继承实现的。那么我们将

759
00:39:51,188 --> 00:39:53,623
you put this implementation? Cuz we know protocol is just
这样的实现放在哪里呢？因为我们知道协议只是

760
00:39:53,691 --> 00:39:56,525
a declaration method with no implementation. Well,
方法的声明，而不包含实现

761
00:39:56,594 --> 00:39:59,962
the answer is you put them in an extension to your protocol.
答案是，将它们放在你的协议的扩展中

762
00:40:00,031 --> 00:40:03,066
You know how we can have extension int? You can also do
你知道我们是如何为 Int 添加扩展的。你也可以

763
00:40:03,134 --> 00:40:07,336
extension protocol. And in that extension you can
为协议添加扩展。并在这个扩展中，你可以

764
00:40:07,405 --> 00:40:10,206
implement as many other protocol methods as you want.
实现任意数量的协议中的方法

765
00:40:10,275 --> 00:40:12,709
Now you're little bit restricted there because
不过你在这里有些受限，因为

766
00:40:12,777 --> 00:40:14,877
extensions can't have any storage.
扩展不能有任何的存储

767
00:40:14,946 --> 00:40:17,713
We know that, right? No vars, so that's certainly
我们知道这点，没有变量，那肯定是一个限制

768
00:40:17,782 --> 00:40:21,117
a restriction. Also in the extension, really the only
并且，在扩展中

769
00:40:21,186 --> 00:40:24,119
method you could use to implement it are the methods
你能用的方法只能是

770
00:40:24,188 --> 00:40:26,990
in the protocol or in the protocols you inherit.
在这个协议中的方法，或者是这个协议继承的协议中的方法

771
00:40:27,058 --> 00:40:30,126
So, like collection, happens to inherit from sequence so
就像 Collection，它是继承了 Sequence 的

772
00:40:30,194 --> 00:40:32,729
a lot of the collection methods can be implemented
因此很多的 Collection 的方法，都可以用

773
00:40:32,797 --> 00:40:35,364
using the sequence by just going through the whole
Sequence 实现，通过遍历整个

774
00:40:35,433 --> 00:40:39,301
sequence of the collection and finding things, or whatever.
集合的序列，找到一些东西，或其他什么

775
00:40:39,370 --> 00:40:44,173
So if you look here, sequence has that one important method
如果你看看这里，Sequence 有那个重要的方法

776
00:40:44,242 --> 00:40:46,609
next goes to the next thing in the sequence. But
next，它可以去到这个序列中的下一个元素，但

777
00:40:46,678 --> 00:40:48,711
sequence also has all these other methods,
序列也有其他的这些方法

778
00:40:48,779 --> 00:40:51,414
contains which finds whether somethings in the sequence,
contains 用来确认序列中是否包含某个元素

779
00:40:51,483 --> 00:40:54,783
forEach which kind of does what for n does. Joined by
forEach 差不多就是 for in 的功能。 joined by

780
00:40:54,852 --> 00:40:57,586
separator, which takes all the things in the sequence,
separator 用来获取序列中的所有元素，并

781
00:40:57,655 --> 00:41:00,356
converts it to a string and creates a big string
转换成一个字符串，它会创建一个大字符串

782
00:41:00,425 --> 00:41:04,293
joined by a separator like comma or space. It has min,
这个字符串被 separator 分割，像逗号或者空格

783
00:41:04,362 --> 00:41:06,729
find me the minimum thing in this sequence, max,
它还有 min 用来找到序列中的最小元素

784
00:41:06,798 --> 00:41:10,133
the maximum thing. Even has functions that take closures,
max 找到最大元素。甚至还有函数接收闭包为参数

785
00:41:10,201 --> 00:41:12,001
which I'm going to talk about soon like filter and
闭包我等一下就会讲到，像 filter 和 map

786
00:41:12,070 --> 00:41:15,171
map, that do major operations on the sequence.
它们可以对序列做一些主要操作

787
00:41:15,240 --> 00:41:17,740
Well, all the implementation of all those things contains,
所有的这些东西的实现，contains

788
00:41:17,808 --> 00:41:19,909
forEach, joined, min, max all those things.
forEach, joined, min, max 所有这些东西

789
00:41:19,978 --> 00:41:23,512
Those are all implemented in an extension to sequence that
它们都在 Sequence 这个协议的扩展中被实现了

790
00:41:23,581 --> 00:41:27,583
Apple provides so that if you want to have a sequence,
这是苹果提供的扩展。因此如果你想要有一个序列

791
00:41:27,652 --> 00:41:30,586
as long as you implement that next thing to go to the next
你只需要实现那个 next 方法，它可以去到

792
00:41:30,655 --> 00:41:33,222
thing in the sequence you get implementations of all those
序列中下个元素，实现了它，你就可以得到整个

793
00:41:33,291 --> 00:41:36,892
other things for free. That also means that array, and set
Sequence 协议的实现，这也意味着数组，集合

794
00:41:36,961 --> 00:41:39,595
and dictionary, and countable range are all sharing
字典和可数区间都在共享 min, max 这些

795
00:41:39,663 --> 00:41:42,398
the implementations of min and max and all these things.
方法的实现

796
00:41:42,466 --> 00:41:45,134
Now, these are only default implementations.
这些只是默认实现

797
00:41:45,203 --> 00:41:48,337
If an array you actually implement min or max or
如果一个数组真的去实现了 min 或者 max

798
00:41:48,405 --> 00:41:50,740
something like that. Maybe you can do it more efficiently
或者其他的方法，也许你可以比默认实现

799
00:41:50,808 --> 00:41:51,941
than the default implementation or
做得更有效率或者

800
00:41:52,010 --> 00:41:55,978
whatever. You can do it. But it's replace the default
其他什么，你可以这样去做，但这样会替代扩展中的

801
00:41:56,047 --> 00:41:58,915
implementation that's in the extension.
默认实现

802
00:41:58,983 --> 00:42:00,983
Okay, but are you getting the feel for what I'm saying?
你能理解我在讲的是什么吗

803
00:42:01,052 --> 00:42:03,385
Why this is valuable to have these default implementations.
为什么默认实现很有价值

804
00:42:03,454 --> 00:42:05,921
You can have these really powerful protocols and
你可以有这些非常强大的协议

805
00:42:05,990 --> 00:42:07,690
you'll only have to implement one of the methods and
而你只要实现其中一个方法

806
00:42:07,759 --> 00:42:08,690
you'll get implementations for
你就可以得到整个的实现

807
00:42:08,759 --> 00:42:11,293
all of them. And then they're shared across all these weird
而它们被这些奇怪的

808
00:42:11,362 --> 00:42:13,061
different classes like array, string,
不同的类共享，像数组，字符串

809
00:42:13,130 --> 00:42:16,765
countable range. They all get all these implementations they
可数区间，它们的可以获得这些实现

810
00:42:16,834 --> 00:42:18,801
don't have to implement any of that and they get it for free.
而自己本身不用去实现什么，免费地获得了这些实现

811
00:42:20,971 --> 00:42:23,739
Now all of these that I'm talking about generics,
那么所以这些我讲的，泛型

812
00:42:23,808 --> 00:42:28,678
value typing, var versus let immutability
数值类型，变量与常量控制

813
00:42:28,746 --> 00:42:33,750
control, constraining things by protocols, extensions or
通过协议来限制，扩展

814
00:42:33,818 --> 00:42:36,685
protocols. All these things add up to support a kind of
还有协议，所有的这些东西共同支撑着一种编程模式

815
00:42:36,754 --> 00:42:39,322
programming called functional programming. How many people
叫做函数式编程，这有多少人听说过

816
00:42:39,391 --> 00:42:42,591
here have heard about functional programming?
函数式编程

817
00:42:42,660 --> 00:42:43,993
About half of you, see? So
大概一半左右

818
00:42:44,062 --> 00:42:46,062
I encourage you at your Stanford careers,
我推荐你在你斯坦福大学的学习中

819
00:42:46,130 --> 00:42:48,765
go take a class and learn about functional programming.
去上节关于函数式编程的课程

820
00:42:48,833 --> 00:42:51,467
It's really kind of the evolution, some would say,
有人会是它是面向对象编程的

821
00:42:51,535 --> 00:42:54,270
of object-oriented programming. It's a little
一个进化

822
00:42:54,339 --> 00:42:56,538
different way of thinking about dividing things up.
它在如何将事物分开有不同的想法

823
00:42:56,607 --> 00:42:58,774
It allows you to get things like multiple inheritance
它允许你使用多重继承

824
00:42:58,843 --> 00:43:00,977
without things getting completely out of control.
而不会让事情变得完全超出掌控

825
00:43:01,046 --> 00:43:02,744
Since things aren't living in the heap,
因为那些东西不是在堆中

826
00:43:02,813 --> 00:43:05,414
you don't have 20 pointers to something and you're not sure
你不会有像20个指针指向某个东西

827
00:43:05,483 --> 00:43:07,950
who's gonna modify things, so your programs are much more
而你不确定哪个指针会改变这东西，所以你的程序会变得更加

828
00:43:08,018 --> 00:43:10,552
provable, right? You can prove that they do what they do.
可证明，你可以证明它们会做它们应该做的事情

829
00:43:10,621 --> 00:43:13,322
You don't have to worry about what pointers are messing this
你不需要担心哪个指针会把堆中

830
00:43:13,390 --> 00:43:15,758
thing up in the heap lot of advantages of it. Now,
的哪一个东西搞砸。这有很大的优势

831
00:43:15,827 --> 00:43:17,560
what's really cool about Swift,
而 Swift 很酷的一点是

832
00:43:17,629 --> 00:43:20,329
it supports both these programming models.
这两个编程方法它都支持

833
00:43:20,397 --> 00:43:22,898
Object oriented programming, which is all I'm gonna
面向对象编程，这个我将会在

834
00:43:22,967 --> 00:43:24,967
use in this class because that's the prerequisite for
这整门课中讲到，因为这是参加这门课的前提

835
00:43:25,036 --> 00:43:27,203
this class, and functional programming,
还有函数式编程

836
00:43:27,271 --> 00:43:31,373
which is what pretty much all of the foundation of
这差不多就是那些基础框架框架，像字典、数组

837
00:43:31,442 --> 00:43:35,545
foundation framework like dictionary, array, string,
字符串这些东西的基础

838
00:43:35,613 --> 00:43:38,380
all those things. Those are all built with a functional
它们都是以函数式编程

839
00:43:38,449 --> 00:43:42,117
programming model. Swift supports them both equally,
模型建立的，Swift 两个都支持

840
00:43:42,186 --> 00:43:44,219
which is really great. So it's kind of your best,
这很好。这是可以说是最好的

841
00:43:44,288 --> 00:43:46,088
it's a mix between languages like Haskell,
它可以说是 Haskell 和 Java 的结合

842
00:43:46,156 --> 00:43:48,457
how many of you have ever heard of the language Haskell?
有多少人听说过 Haskell 这门语言

843
00:43:48,525 --> 00:43:51,160
Okay, same people who know about functional programming,
好的，同样是听说过函数式编程的那些人

844
00:43:51,229 --> 00:43:53,863
right, so Haskell which is a purely functional programming
Haskell 是纯粹的函数式编程语言

845
00:43:53,932 --> 00:43:56,532
language, and you know, like Java which is a purely object
而 Java 是纯粹的面向对象

846
00:43:56,600 --> 00:44:01,137
oriented language. It's a good mix of two. That's all I'm
编程语言，而 Swift 是它们两的结合

847
00:44:01,205 --> 00:44:03,773
going to say about functional programming, just so
这是我关于函数式编程所有要讲的部分

848
00:44:03,841 --> 00:44:07,509
that you know it's there. That's it for protocols.
只是为了让你们知道有这个东西，协议我们就讲到这里

849
00:44:07,578 --> 00:44:11,113
When you see it all in action it will make a lot more sense.
当你在实战中遇到它，你就能理解了

850
00:44:11,181 --> 00:44:12,114
Hopefully it makes a lot of sense.
希望你就能理解了

851
00:44:12,183 --> 00:44:14,016
Now it's really, protocols are very simple.
协议非常的简单

852
00:44:14,085 --> 00:44:16,485
Just those lists but we can use them in powerful ways,
就是那些清单，但我们可以将它用作非常强大的途径

853
00:44:16,553 --> 00:44:20,522
all right. Now let's go talk for briefly about something
好的，那么现在我们来简要的讲讲

854
00:44:20,591 --> 00:44:23,459
that's not super important, but strings are in almost
一个不是那么重要的东西，字符串，字符串在每个

855
00:44:23,528 --> 00:44:26,028
every app. And I just wanna talk a little bit about how we
应用程序都存在，而我只想讲讲关于

856
00:44:26,097 --> 00:44:28,531
index in to strings, cuz it is not what you would
我们如何索引字符串，因为这不会像你们第一眼

857
00:44:28,599 --> 00:44:33,035
think it is at first glance. In addition to string,
看到所想的那样，除了字符串

858
00:44:33,104 --> 00:44:36,572
the struct string, there's another struct in foundation
结构体字符串，在 Foundation 中有另外一个

859
00:44:36,641 --> 00:44:40,543
called character. Now, a character is what we humans
叫做 Character 的结构体，一个 Character 就是

860
00:44:40,611 --> 00:44:44,580
would perceive of as a character. On the screen or
我们所看到的一个字符，在屏幕上

861
00:44:44,649 --> 00:44:49,519
whatever. However, a string is not a sequence. A string is
或是其他什么东西上。但是，一个字符串并不是一个序列

862
00:44:49,587 --> 00:44:52,355
an underlying built with character, it's built with
字符串是以字符为基础建立的

863
00:44:52,423 --> 00:44:56,659
unicodes. Okay, unicodes are just little bite size chunks
它是以 Unicode 为基础建立的，Unicode 就是那几个字节

864
00:44:56,728 --> 00:45:00,162
that can represent pretty much any language on earth. Okay,
的数据，而它可以表示基本上地球上的所有语言

865
00:45:00,231 --> 00:45:02,631
it's international. You know, like ASCII.
它是国际化的，像 ASCII

866
00:45:02,700 --> 00:45:05,501
We used to have ASCII, you can only really do English.
我们以前用 ASCII，它只能表达英语

867
00:45:05,569 --> 00:45:07,870
Unicodes do all All the languages on Earth.
Unicode 可以表示地球上的所有语言

868
00:45:07,939 --> 00:45:10,773
So that's what's in a string. So we have a little bit
这就是字符串中的东西，我们就好像正在

869
00:45:10,841 --> 00:45:13,976
of trying to bridge the world between Unicodes and
尝试在Unicode 的世界与 Character 的世界

870
00:45:14,045 --> 00:45:17,212
characters. So let me show you by example here,
搭建桥梁，让我为你们展示一个例子

871
00:45:17,281 --> 00:45:22,351
if we have the word cafe, C-A-F-E, right?
如果我们有 cafe 对吧

872
00:45:22,419 --> 00:45:25,054
That we perceive to have four characters, the C, the A,
那么我认为它由 4 个字符组成，c、a

873
00:45:25,122 --> 00:45:27,290
the F, and the E with the accent on it. But
f、e 其中 e 的上方有重音符号

874
00:45:27,358 --> 00:45:30,526
it might be represented by five Unicodes, because there's
但是它可能是被 5 个 Unicode 字符表示的

875
00:45:30,595 --> 00:45:33,162
a Unicode which is put an accent on the previous
以为有一个 Unicode 的字符是在前一个字符上加上重音符号

876
00:45:33,231 --> 00:45:38,434
character, okay, so, it could have five Unicodes. Well, So
所以它可能会有 5 个 Unicode 字符

877
00:45:38,503 --> 00:45:41,704
how do we deal with this? Well, the main problem or
那么我们如何处理这个呢？那么现在

878
00:45:41,772 --> 00:45:46,175
the main ramification of this is that string
的主要问题是，字符串

879
00:45:46,243 --> 00:45:50,980
cannot indexed by int. Because if we had a phrase,
不可以通过 Int 类型来索引，因为如果我们有一个词组

880
00:45:51,049 --> 00:45:54,449
cafe pesto, right there. One of my favorite pizza joints in
cafe pesto，我喜欢的一个比萨店

881
00:45:54,518 --> 00:45:58,020
Hawaii, Cafe Pesto. The p is that in index 5 or
cafe pesto，p 这个字母的索引应该是 5

882
00:45:58,088 --> 00:46:02,925
is that in index 6? It depends on whether that e is
还是 6，这取决于 e

883
00:46:02,993 --> 00:46:07,029
an e with an accent or two Unicode here there's the e and
是 e 和重音符号组成的一个字符，还是两个字符，分别是

884
00:46:07,097 --> 00:46:11,634
the accent. So ugh, what are we gonna do here? So
e 和那个重音符号。那么我们这里该怎么做呢

885
00:46:11,702 --> 00:46:16,138
what we do is we don't index strings by int.
我们做法是，不允许使用 Int 来索引字符串

886
00:46:16,207 --> 00:46:19,708
Instead strings are indexed by their own special type,
字符串是用一个特殊的类型来索引的

887
00:46:19,777 --> 00:46:23,979
String.Index. And that's the only way
String.Index 并且这是对字符串使用

888
00:46:24,048 --> 00:46:26,215
to use subscripting on a String,
下标的唯一方法

889
00:46:26,283 --> 00:46:30,285
you need a String.Index, not an Int. So this makes this,
你需要一个 String.Index，而不是 Int。那么这就会

890
00:46:30,354 --> 00:46:33,022
people don't like this. They wanna index Strings by Int and
让人们不太喜欢这样。人们喜欢用 Int 来索引字符串

891
00:46:33,090 --> 00:46:36,358
I understand why, but you can't do that. So
我也能理解原因，但你不能这么做

892
00:46:36,427 --> 00:46:39,362
what does that mean? Well, we have to get an index, so
那么这意味着什么呢，这意味着我们必须要获得一个索引

893
00:46:39,430 --> 00:46:42,565
how do we get an index? Well, you can get the startIndex
我们如何获得一个索引呢？你可以得到你个字符串的

894
00:46:42,633 --> 00:46:45,834
of a string, you can get the endIndex of a string.
startIndex（开始索引） 和它的 endIndex（结束索引）

895
00:46:45,903 --> 00:46:49,438
You can also use index(of:) a character to find the first
你可以用 index(of:) 一个字符来找到这个字符

896
00:46:49,506 --> 00:46:52,241
index of that character. So there's a bunch of different
的第一个索引。所以这样许多不同的方法

897
00:46:52,309 --> 00:46:55,144
methods and vars on strings to get an index.
和变量来让我们获得一个索引

898
00:46:55,212 --> 00:46:58,814
Once you have an index in your hand, now you can offset
一旦你手头有了一个索引，你就可以用 Int 移动（offset）

899
00:46:58,883 --> 00:47:02,951
that index by an Int. So if you want to get the fourth
那个索引。所以如果你想要的到这个字符串的第四个

900
00:47:03,020 --> 00:47:05,454
character in the string you have to get the startIndex and
字符，你必须要得到它的 startIndex

901
00:47:05,522 --> 00:47:08,323
then offset it by three to get to the fourth index, from
并用 3 offset 它这样就能获得第四个下标

902
00:47:08,392 --> 00:47:11,960
the first to the fourth. So it was let's get to the code that
从第一个到第四个，然我们来看看这样的代码

903
00:47:12,029 --> 00:47:14,597
makes that work. So here's my pizzaJoint cafe pesto here,
这是我的 pizzaJoint = "cafe pesto"

904
00:47:14,665 --> 00:47:17,733
I'm gonna get the index of the first character by saying
我将通过使用 pizzaJoint.startIndex

905
00:47:17,802 --> 00:47:20,769
pizzaJoint.startIndex that's not an Int.
的方式来得到第一个索引，而它不是 Int 型

906
00:47:20,838 --> 00:47:23,438
It's of type String.Index.
它是 String.Index

907
00:47:23,507 --> 00:47:25,374
Now I'm gonna get the fourth character by taking
而我通过得到第一个字符的索引

908
00:47:25,443 --> 00:47:28,010
the first character and offsetting it by three.
并 offset 它 3 就可以得到第四个字符的索引

909
00:47:28,079 --> 00:47:29,444
Now I've got the index of the fourth character.
那么现在我有了第四个字符的索引

910
00:47:29,513 --> 00:47:32,881
Now I'm gonna get the actual fourth character by using
那么我就可以通过下标的方式

911
00:47:32,950 --> 00:47:36,952
subscripting. PizzaJoint, subscript, fourth character,
pizzaJoint[fourthCharacterIndex] 这样

912
00:47:37,021 --> 00:47:40,222
index, fourth character index of subtype String.index,
fourthCharacterIndex 的类型是 String.Index

913
00:47:40,290 --> 00:47:43,525
not of type int. And I can also do index (of:), so
而不是 Int。而我也可以用 index(of:)

914
00:47:43,594 --> 00:47:46,695
here I'm gonna say The firstSpace character in
那么我这里要得到第一个空格的位置可以这样写：

915
00:47:46,764 --> 00:47:50,032
cafe pesto is pizzaJoint.index(of: " ").
firstSpace = pizzaJoint.index(of:" ")

916
00:47:50,101 --> 00:47:51,767
Now the reason I have to say if let there is,
我之所以要使用 if let

917
00:47:51,836 --> 00:47:53,836
of course, index(of: " ") could return nil.
是因为，index(of:" ") 当然可能返回 nil

918
00:47:53,904 --> 00:47:56,672
There might not be any spaces in pizzaJoint.
pizzaJoint 中可能根本没有空格

919
00:47:56,740 --> 00:47:58,507
There happens to be but there might not be.
这里碰巧有，但是可能没有的

920
00:47:58,575 --> 00:48:01,410
So it would return nil then. And so I'm doing if let Now,
所以它可能返回 nil 也因此我在这里用了 if let

921
00:48:01,479 --> 00:48:03,412
I've got the index of that space.
现在我有了那个空格的索引

922
00:48:03,480 --> 00:48:06,181
Now I'm going to get the index to the start of the second
现在我想得到第二个单词的开始的索引

923
00:48:06,250 --> 00:48:08,417
word, the word pesto there. And
也就是 pesto 这个单词

924
00:48:08,485 --> 00:48:12,054
we do it by indexing that first space over by one.
我们通过 index（注：这里应该是 offset） firstSpace 1

925
00:48:12,123 --> 00:48:15,390
And I am gonna assume there is one space in between words,
为了能找到下一个单词，我在这里

926
00:48:15,459 --> 00:48:18,593
go to the next one. And now, I am going to get the whole word
假定了单词之间是有空格的。而现在我将要得到整个 pesto

927
00:48:18,662 --> 00:48:25,201
pesto by indexing string with a range, okay. The index
这个单词，通过用区间的方法来所以这个字符串

928
00:48:25,269 --> 00:48:27,903
of a string doesn't have to be an individual index.
字符串的所以不一定要是一个独立的索引

929
00:48:27,972 --> 00:48:31,040
It could be a range of indexes. Now you notice to
他可以是一个由索引构成的区间

930
00:48:31,109 --> 00:48:35,511
make a range, I'm using exactly the same dot,
注意到这里要创建一个区间，我是用的是之前

931
00:48:35,580 --> 00:48:38,247
dot, less than thing that I did when I made that countable
在我们创建 Int 型的可数区间用过的 ..< 的方法

932
00:48:38,315 --> 00:48:42,585
range of INTs. Ranges are generic types. They don't have
区间是泛型，它们不一定要是

933
00:48:42,653 --> 00:48:45,787
to be of INTs. They can be a range of string.index.
Int， 它可以是一个由 String.Index 构成的区间

934
00:48:45,856 --> 00:48:50,325
Perfectly legal. As though we saw before, we had a range,
这是完全合法的，就像我们曾经见过的

935
00:48:50,394 --> 00:48:52,727
countable range, of double precision floating points.
我们有一个由双精度浮点型组成的可数区间

936
00:48:52,796 --> 00:48:55,196
Remember that at the beginning of the last lecture? So
记得在我们上节课的开始讲的那样吗

937
00:48:55,265 --> 00:48:58,767
range is generic type. So
区间是泛型

938
00:48:58,836 --> 00:49:02,738
it is perfectly legal to use a range inside subscripting, and
在下标中使用区间是完全合法的

939
00:49:02,806 --> 00:49:05,441
that's true anywhere there's subscripting of collections.
并且在任何下标是集合的地方都是正确的

940
00:49:07,011 --> 00:49:08,844
These methods, by the way, these index,
这些方法，index()

941
00:49:08,913 --> 00:49:11,646
offsetBy, those are not methods in string,
offsetBy() 这些不是字符串中的方法

942
00:49:11,715 --> 00:49:13,582
those are methods in collection. Okay,
这些是集合中的方法

943
00:49:13,651 --> 00:49:15,284
the collection protocol, string may or
在 Collection 这个协议中的方法，String 可以

944
00:49:15,352 --> 00:49:18,087
may not implement it itself, it's up to the string.
选择去实现或不实现它，这由 String 来决定

945
00:49:18,155 --> 00:49:21,156
The collection protocol is also generic, and so the index
Collection 这个协议也是泛型的，因此在

946
00:49:21,225 --> 00:49:25,160
you use in the collection is configurable. For
Collection 中使用的索引是可配置的

947
00:49:25,229 --> 00:49:28,664
a string it's a string.index. By the way, another way
对字符串来说那是 String.Index。另外一种

948
00:49:28,733 --> 00:49:31,634
to get the second word, and probably what we would use, is
获得第二个单词的方式，我们也可能这样做，是

949
00:49:31,702 --> 00:49:35,570
a more complicated method like component separated by. So
一个更复杂的方法， components(separatedBy:)

950
00:49:35,639 --> 00:49:39,508
components separated by, is a collection method. You give it
它是一个集合中的方法，你像它传递一个

951
00:49:39,577 --> 00:49:42,979
an element that would be in that collection and
会在这个集合中的元素

952
00:49:43,047 --> 00:49:46,282
it will create an array with all the things,
而它会创建一个数组来装所有东西

953
00:49:46,351 --> 00:49:48,751
all the elements in an array grouped and
数组中的所有元素都会被那个东西

954
00:49:48,819 --> 00:49:52,588
separated by that thing. So this would give you an array
分割，这样做就会得到一个由空格分割的

955
00:49:52,656 --> 00:49:55,857
of all the words separated by a space. Then I would grab
单词组成的数组

956
00:49:55,926 --> 00:49:59,294
index one, which would be the second word. Okay,
接着我使用 [1]，这就是第二个单词了

957
00:49:59,363 --> 00:50:02,031
so I'm showing you how to do the indexing directly, but
我给你们讲了如何直接使用索引

958
00:50:02,100 --> 00:50:04,000
a lot of times we use much higher level
但更多时候我们都会用更加高级的

959
00:50:05,302 --> 00:50:09,871
things in string. Okay, so string,
字符串中的东西，那么一个字符串

960
00:50:09,940 --> 00:50:14,109
like I say, is a collection of character. Just like an array
就像我说的，是一些字符的集合，就像数组是一个

961
00:50:14,178 --> 00:50:15,978
is a collection of arbitrary things,
随意某些东西的集合

962
00:50:16,046 --> 00:50:19,214
accountable range of int is a collection of ints, and so
Int 类型的可数区间是 Int 类型的集合

963
00:50:19,283 --> 00:50:22,017
all that stuff is coming from collection. And collection is
那些东西都是来自 Collection 这个协议

964
00:50:22,086 --> 00:50:24,686
a sequence we know, so of course you can do for
而正如我们知道的，Collection 又是一个序列

965
00:50:24,755 --> 00:50:28,657
c and if s is a string c will be a tight character and you
所以你当然可以用 for c in s，当 s 是字符串时，c 是字符

966
00:50:28,725 --> 00:50:31,460
can iterate with a four loop through all the characters.
那你就可以用一个 for 循环来遍历所有的字符

967
00:50:31,529 --> 00:50:34,930
There's also really cool initializer for array
同时数组也有一个非常酷的初始化方法

968
00:50:34,998 --> 00:50:39,067
that takes a sequence, as the argument. So you can say,
它接收一个序列作为参数，那么你就可以写 Array(s)

969
00:50:39,136 --> 00:50:42,638
array of any sequence and what it will do is go through that
s 是序列，这样就会遍历这整个

970
00:50:42,706 --> 00:50:45,774
sequence and take each element and put it into the array.
序列，并将它的每个元素放入这个字符串中

971
00:50:45,842 --> 00:50:47,209
So it creates a big array for you,
这将为你创建一个大数组

972
00:50:47,277 --> 00:50:48,978
cuz it's an array initializer. And
因为这是一个数组初始化方法

973
00:50:49,046 --> 00:50:52,214
in the array will be all the elements of the sequence. So
并且在这个数组是由这个序列的所有的元素组成

974
00:50:52,283 --> 00:50:54,883
since a string is a sequence of characters, if you say
既然字符串是字符的序列

975
00:50:54,952 --> 00:50:59,321
array of string, you'll get an array of its characters. And
如果你使用 Array(SomeString) 你就会得到由它所有字符组成的数组

976
00:50:59,390 --> 00:51:03,592
now you can use int to index them if you want. So sometimes
现在如果你想要，你就可以使用 Int 来索引这个数组了

977
00:51:03,661 --> 00:51:06,194
people, they get tired of all this string index stuff.
有时人们被这个 String.Index 弄得很烦

978
00:51:06,263 --> 00:51:08,229
They just create an array of the characters. And
他们就创建一个由字符组成的数组

979
00:51:08,298 --> 00:51:11,967
then now they can use ints to get at the various characters.
这样他们就可以使用 Int 来索引这个数组并获得许多字符

980
00:51:13,204 --> 00:51:16,071
That's kind of a trick as well.
这也能算是一个技巧

981
00:51:16,140 --> 00:51:19,374
Ah, remember that a string is a value type, it's a struct,
记得 String 是数值类型，它是一个类

982
00:51:19,443 --> 00:51:22,177
we almost always use immutable strings like let s equal
我们几乎一只会用不可改变的字符串像 let s = something

983
00:51:22,246 --> 00:51:24,213
something, we're working with it immutably,
我们就在不可改变地处理它

984
00:51:24,281 --> 00:51:26,781
but of course there are mutable versions, mutable
但当然也有可改变的版本，可改变的

985
00:51:26,850 --> 00:51:30,519
methods. There's another kind of protocol called range
方法，这有另一个叫做 RangeReplaceableCollection

986
00:51:30,587 --> 00:51:33,121
replaceable collection. That's kind of a collections that
的协议，它就是一些可变的东西的集合

987
00:51:33,190 --> 00:51:37,793
can be mutated. Ranges of the things can be replaced. And so
那些可以被替代的东西的区间

988
00:51:37,862 --> 00:51:40,862
here's a method in that insert the contents of
那么这里就有一个方法，可以插入 contentsOf

989
00:51:40,931 --> 00:51:45,233
a collection of characters, which string is, at an index,
一个字符的集合，比如说 String，at 一个索引

990
00:51:45,302 --> 00:51:47,336
so in this case it's index of space,
在这里是 index(of:" ")

991
00:51:47,404 --> 00:51:49,871
that's gotta be a string.index right there.
这里必须是一个 String.Index 类型

992
00:51:49,940 --> 00:51:54,477
And so I can insert the word foo into Cafe Pesto. So
那么我就可以将 foo 这个单词插入 cafe pesto

993
00:51:54,545 --> 00:51:56,111
you can do this, we don't do this that much.
你可以这么做，但我们不经常这么做

994
00:51:56,180 --> 00:51:58,814
We tend to just use them immutably, and we use plus to
我们倾向于就不可变地使用它们，而我们用 + 来将他们

995
00:51:58,882 --> 00:52:04,052
add them together and stuff like that. So that's string,
合并，和其他类似的操作。这就是字符串

996
00:52:04,121 --> 00:52:06,088
it's that little weirdness about the indexing.
它在索引的方面有一点奇怪

997
00:52:06,156 --> 00:52:09,858
Now, There are lots of other methods in string, I want to
字符串中有许多其他的方法

998
00:52:09,927 --> 00:52:11,427
show you an interesting thing about one of them.
我想想你展示其中一个有趣的

999
00:52:11,495 --> 00:52:16,265
So here is replace range, which, my pointer doesn't work
这是 replaceSubrange。啊我的控制器用不了了

1000
00:52:16,333 --> 00:52:18,133
any more, but if you look at replace range,
但你看一下 replaceSubrange 那里

1001
00:52:18,201 --> 00:52:21,069
do you see where it's red, right there? That's that dot,
看到红色的这个吗？那个

1002
00:52:21,138 --> 00:52:23,905
dot less than thing, look, I forgot to put something on
点点小于富豪，我是不是忘了放点东西

1003
00:52:23,974 --> 00:52:28,076
the left. So what does that range go from? Okay,
在左边？那这个区间是从哪里开始的呢？

1004
00:52:28,145 --> 00:52:31,613
we know it goes to s.endIndex. Well, Swift is smart enough to
但我们知道它是在 s.endIndex 结束。其实 Swift 很聪明

1005
00:52:31,682 --> 00:52:35,150
know that that is a range of str-, the strings indexes,
知道这是这个字符串的索引

1006
00:52:35,219 --> 00:52:38,854
so it will automatically put start index at the beginning.
所以它会自动认为开始的索引是在字符串的开头

1007
00:52:38,923 --> 00:52:40,155
And if you left off the other side,
如果你是只省略右边的话

1008
00:52:40,224 --> 00:52:43,659
it will automatically put ending index at the end. So
它会自动把字符串的结尾当作结束的索引

1009
00:52:43,728 --> 00:52:46,228
you can oh, leave those arranged things open ended.
也就是，你可以省略其中一个的边界

1010
00:52:46,297 --> 00:52:48,764
But Swift has to be able to infer the type of whats going
但 Swift 得先要能够判断发生了什么

1011
00:52:48,833 --> 00:52:50,065
on there. So you can't always do it,
所以你并不总是这样做

1012
00:52:50,134 --> 00:52:53,702
but in that case you could. Okay, so
但这里你是可以的。好

1013
00:52:53,771 --> 00:52:58,274
that's string. I guess we'll go like this. So, to
这就是字符串，就讲到这里

1014
00:52:58,342 --> 00:53:02,611
make this all understandable let's go back to our,
为了让这个更容易理解，我们回到我们的

1015
00:53:02,679 --> 00:53:08,249
um, concentration. And we're gonna make this
Concentration 里，我们要把这个

1016
00:53:08,318 --> 00:53:12,421
thing right here, this emoji choices,
这里这个 emojiChoices

1017
00:53:12,489 --> 00:53:15,424
which is currently an array of emoji strings.
它现在是一个表情字符串的数组

1018
00:53:15,492 --> 00:53:17,759
I'm gonna change that. I'm gonna copy and paste it here.
我要把它改掉，我复制粘贴一下

1019
00:53:17,828 --> 00:53:21,730
I'm gonna change it from being an array, to being a string.
我把它从数组改为字符串

1020
00:53:21,799 --> 00:53:24,433
So I'm gonna take off the array things.
所以我把数组的这些先去掉

1021
00:53:24,501 --> 00:53:29,304
And I'm gonna get rid of all of these little commas. And
我去掉这些逗号

1022
00:53:29,373 --> 00:53:32,707
now emojiChoices is gonna be a string.
现在 emojiChoices 就是个字符串了

1023
00:53:32,776 --> 00:53:35,577
And I'm gonna have my code be the same,
我就保持代码不变

1024
00:53:35,646 --> 00:53:38,179
but instead of grab it out of the array, it's gonna grab it
但不从数组里取值了。我获得这些值

1025
00:53:38,248 --> 00:53:41,250
out of the string. Now as soon as I change that to a string,
改成从字符串里。现在我把它改成字符串之后

1026
00:53:41,319 --> 00:53:44,853
look what happens. Cannot convert value of type
你看会发生什么？不能转换类型为 Int 的值

1027
00:53:44,921 --> 00:53:49,625
int to expected argument, string.index. Okay, remove at,
为期待的参数类型 String.Index。好吧，remove(at:)

1028
00:53:49,694 --> 00:53:52,027
right here, which we moved to remove the thing,
就这个，我们用来移除表情的

1029
00:53:52,095 --> 00:53:57,365
where do you think that's declared? Anyone wanna guess?
你认为这个方法是在哪里定义的？有谁想猜一下吗？

1030
00:53:57,434 --> 00:54:02,437
Is that an array thing? A string? No,
那是 Array 类的吗？还是 String 的？不

1031
00:54:02,506 --> 00:54:04,973
that's in collection, range replaceable collection, right?
它是 RangeReplaceableCollection 实现的

1032
00:54:05,042 --> 00:54:07,142
So it's in a protocol somewhere that both string and
是在这个 protocol 里某个地方，而且 String

1033
00:54:07,211 --> 00:54:07,976
array implement. So
和 Array 的遵守了这个协议。所以

1034
00:54:08,045 --> 00:54:10,178
you would think it should just work here,
你会认为这个应该可以直接行得通

1035
00:54:10,247 --> 00:54:13,315
because emoji choices, yeah, now it's a string, but remove
因为 emojiChoices 只不过现在变成了字符串，即使

1036
00:54:13,384 --> 00:54:15,884
at is in range replaceable collection, they're range
remove(at:) 是 RangeReplaceableCollection 里定义的

1037
00:54:15,952 --> 00:54:18,454
replaceable collection. Why does this work? Well,
但它们也都遵守这个协议，为什么这个行不通？

1038
00:54:18,522 --> 00:54:21,823
because strings are not indexed by ints. And
因为字符串不是靠 Int 索引的

1039
00:54:21,892 --> 00:54:25,494
so this doesn't work. So we have to create a string.index,
所以这个不能用。我们必须构造一个 String.Index

1040
00:54:25,562 --> 00:54:29,465
I'm gonna do that. I'm gonna create a random string index
那我就这样做，创建一个随机的字符串索引

1041
00:54:29,533 --> 00:54:34,002
and I'm gonna do it by using that index offset by things.

1042
00:54:34,070 --> 00:54:38,172
I'm gonna say, emojiChoices give me an index, I'm gonna

1043
00:54:38,241 --> 00:54:41,276
use this first one right here, index offsetBy, which let's us

1044
00:54:41,344 --> 00:54:44,446
take a known index and offset it by something else.

1045
00:54:44,515 --> 00:54:47,716
The known index I'm going to start with is the start index

1046
00:54:47,785 --> 00:54:51,219
of this thing, so, emojiChoices.startIndex, and

1047
00:54:51,288 --> 00:54:54,989
I'm gonna offset by a random int. So that offset,

1048
00:54:55,058 --> 00:54:58,627
that can be by an int. That happens to be because

1049
00:54:58,696 --> 00:55:01,797
this particular collections strides, or the distance

1050
00:55:01,865 --> 00:55:05,434
between indexes is an int. Even though the indexes

1051
00:55:05,503 --> 00:55:08,503
themselves are string dot index. So I do that.

1052
00:55:08,572 --> 00:55:11,273
So now I'm gonna put random string index in here and

1053
00:55:11,341 --> 00:55:14,476
all should be well, right? Because remove at,

1054
00:55:14,544 --> 00:55:17,979
oh no, still doesn't work. What's this error?

1055
00:55:18,048 --> 00:55:23,451
Cannot assign value of type character to string.

1056
00:55:23,520 --> 00:55:25,054
Okay, this is a dictionary, this is looking for

1057
00:55:25,122 --> 00:55:29,124
strings. Okay? Why is this a character? Well,

1058
00:55:29,192 --> 00:55:32,894
because a string is a collection of character. So

1059
00:55:32,963 --> 00:55:37,565
if remove at, I'm removing a character. So no problem here,

1060
00:55:37,634 --> 00:55:40,168
we know that we can probably convert types. And

1061
00:55:40,237 --> 00:55:42,704
we're gonna do that by using a string initializer that

1062
00:55:42,773 --> 00:55:44,606
takes a character as an argument and

1063
00:55:44,675 --> 00:55:47,409
returns a string with just that character in it. So now

1064
00:55:47,478 --> 00:55:51,313
we converted it. So, that's it. That's all we need to do.

1065
00:55:51,381 --> 00:55:55,684
And I did this just so you can see all that offsetBy, and

1066
00:55:55,752 --> 00:55:57,653
all that stuff so you could see how we would index this

1067
00:55:57,721 --> 00:56:00,121
into a string instead of doing here. So, hopefully

1068
00:56:00,190 --> 00:56:02,991
this is still working. Yes, it is. It's still working.

1069
00:56:04,261 --> 00:56:09,397
Okay? Got it everybody? Questions about this? So

1070
00:56:09,466 --> 00:56:11,767
this is the important line of coding in here. And

1071
00:56:11,835 --> 00:56:14,102
also a little bit of understanding that even though

1072
00:56:14,170 --> 00:56:17,973
remove at is in collection range, replaceable collection,

1073
00:56:18,042 --> 00:56:21,075
the types matter, because it's a generic type.

1074
00:56:21,144 --> 00:56:25,347
Collection is a generically typed protocol. All right,

1075
00:56:25,416 --> 00:56:29,251
let's go back. Oops, not there. Here, no. Here.

1076
00:56:29,319 --> 00:56:33,755
All right, let's talk about another class that has

1077
00:56:33,823 --> 00:56:37,425
to do with Strings which is NSAttributedString. For

1078
00:56:37,494 --> 00:56:41,429
NSAttributedString is a String that every character

1079
00:56:41,498 --> 00:56:43,765
has a little dictionary associated with it. And

1080
00:56:43,834 --> 00:56:46,067
that Dictionary can have lots of little keys and

1081
00:56:46,136 --> 00:56:50,471
values that say how to draw that character on screen.

1082
00:56:50,540 --> 00:56:53,741
Okay so those Dictionaries can have things like font, color,

1083
00:56:53,810 --> 00:56:57,179
all these things. Okay that's what an attributed string is,

1084
00:56:57,247 --> 00:57:00,249
right? A String with attributes of each character,

1085
00:57:00,317 --> 00:57:04,652
right? The Dictionary that each character can have.

1086
00:57:04,721 --> 00:57:06,354
The keys are well known,

1087
00:57:06,423 --> 00:57:08,256
you can look them up in the documentation.

1088
00:57:08,325 --> 00:57:12,260
The values depend on the type of thing, so

1089
00:57:12,328 --> 00:57:14,796
sometimes the values are UI font, which is a font thing,

1090
00:57:14,865 --> 00:57:15,998
sometimes the values are colors,

1091
00:57:16,066 --> 00:57:19,267
sometimes they're floating point numbers, etcetera.

1092
00:57:19,336 --> 00:57:23,471
Now a lot of times, we use the same Dictionary for big long

1093
00:57:23,540 --> 00:57:27,342
ranges of characters, right? You know like if users select

1094
00:57:27,411 --> 00:57:30,478
some text on screen and they say make it orange, then we're

1095
00:57:30,547 --> 00:57:33,215
gonna have one Dictionary for all those characters so not

1096
00:57:33,283 --> 00:57:36,618
like every character has to have a different Dictionary.

1097
00:57:36,686 --> 00:57:37,919
And in your homework,

1098
00:57:37,988 --> 00:57:40,856
the entire String is going to have one Dictionary. So

1099
00:57:40,924 --> 00:57:43,758
I've given you a really easy use of attributed String and

1100
00:57:43,827 --> 00:57:47,629
you're gonna see why I did that in a moment here.

1101
00:57:47,698 --> 00:57:50,398
Once you have an Attributed String with all those font and

1102
00:57:50,467 --> 00:57:51,700
color for each character,

1103
00:57:51,769 --> 00:57:55,604
now you can use to it to set the text in UI label, or

1104
00:57:55,672 --> 00:57:58,539
to set the title of a UIButton. Or next week we're

1105
00:57:58,608 --> 00:58:01,209
going to learn how to draw it directly on-screen, in our own

1106
00:58:01,278 --> 00:58:06,214
drawing classes. Okay? Here's how you create and

1107
00:58:06,283 --> 00:58:08,383
use an AttributedString, and it's got red.

1108
00:58:08,451 --> 00:58:10,919
Any time you see red on my slides, it's kind of like oh,

1109
00:58:10,988 --> 00:58:15,123
look out. And this is red because it's really weird.

1110
00:58:15,192 --> 00:58:18,426
Okay? And why is this really weird? Well, it's really weird

1111
00:58:18,495 --> 00:58:22,263
cuz this is an Objective-C API that's trying to live

1112
00:58:22,332 --> 00:58:25,166
in the Swift world, and that requires a little bit of

1113
00:58:25,235 --> 00:58:27,602
compromise. There's not a lot of APIs like this.

1114
00:58:27,671 --> 00:58:30,372
Every time iOS comes out, the next one I always hope there

1115
00:58:30,441 --> 00:58:33,174
can have Non NSAttributedString, just

1116
00:58:33,243 --> 00:58:36,445
regular AttributedString would now fix this, but they haven't

1117
00:58:36,513 --> 00:58:39,214
done it yet. So, when you're declaring those attributes,

1118
00:58:39,282 --> 00:58:41,482
the little Dictionary that goes on each character,

1119
00:58:41,551 --> 00:58:43,919
you have to give it an explicit type.

1120
00:58:43,988 --> 00:58:45,920
You cannot let the type be inferred and

1121
00:58:45,989 --> 00:58:48,289
that's because those values could be font,

1122
00:58:48,358 --> 00:58:50,959
colors, whatever. So, a source can't infer what the value of

1123
00:58:51,028 --> 00:58:53,795
the Dictionary is. So they type that you're gonna use

1124
00:58:53,864 --> 00:58:56,965
here is Keys are NSAttributedString key.

1125
00:58:57,033 --> 00:58:59,134
And you can just look that up in the documentation,

1126
00:58:59,203 --> 00:59:02,470
see what the choices are. It's things like font, underline,

1127
00:59:02,539 --> 00:59:04,840
strike through, all the things you would think to be.

1128
00:59:04,908 --> 00:59:08,876
And then the value is Any. Okay, so

1129
00:59:08,945 --> 00:59:12,413
Any is a special Swift thing that means

1130
00:59:12,482 --> 00:59:15,083
anything can go here, any struct, any class, any type.

1131
00:59:15,152 --> 00:59:17,652
So this is very non Swift cuz Swift is strongly

1132
00:59:17,721 --> 00:59:20,621
typed, and here's there's no type. So

1133
00:59:20,690 --> 00:59:24,792
you would never have an API like this in Swift. Okay,

1134
00:59:24,861 --> 00:59:27,295
if this weren't an Objective-C API brought forward, so

1135
00:59:27,364 --> 00:59:28,396
you would never have it.

1136
00:59:28,465 --> 00:59:30,232
Can anyone think of what we would have instead of

1137
00:59:30,300 --> 00:59:33,268
any right there? Why type of thing instead of any?

1138
00:59:35,472 --> 00:59:39,808
How about an enum with associated values? Right?

1139
00:59:39,877 --> 00:59:43,077
If you had an enum, and one of the enum things is the font,

1140
00:59:43,146 --> 00:59:45,113
then the associated value could be a font.

1141
00:59:45,182 --> 00:59:47,815
Or what if the thing was the color of the text?

1142
00:59:47,884 --> 00:59:49,050
Then the associated value could

1143
00:59:49,119 --> 00:59:51,553
be a UI color, you see? How we would do that in Swift? Well,

1144
00:59:51,621 --> 00:59:54,723
we didn't have those enums when Objective-C did this so,

1145
00:59:54,792 --> 00:59:56,657
we're stuck with Any. Okay?

1146
00:59:56,726 --> 01:00:00,895
Never use any in your data structures. Any is purely so

1147
01:00:00,964 --> 01:00:05,567
we can deal with these old Objective-C things. Alright,

1148
01:00:05,635 --> 01:00:08,870
so, now that I have declared the type to be a dictionary

1149
01:00:08,939 --> 01:00:12,874
with NSAttributeString keys with Any as the value, then I

1150
01:00:12,943 --> 01:00:16,511
can make my dictionary and so StrokeColor is obviously

1151
01:00:16,579 --> 01:00:19,648
the color that it strokes the outside of the text.

1152
01:00:19,716 --> 01:00:22,050
There's also foreground color which is the color it puts

1153
01:00:22,119 --> 01:00:25,921
the inside of the text, the fill color. There's also

1154
01:00:25,989 --> 01:00:28,756
background color which is like if you had a highlighter,

1155
01:00:28,825 --> 01:00:32,059
that's the background of it. There's also StrokeWidth.

1156
01:00:32,128 --> 01:00:33,961
StrokeWidth, if it's a positive number,

1157
01:00:34,030 --> 01:00:38,867
it outlines. Okay? If it's a negative number its solid.

1158
01:00:38,936 --> 01:00:41,870
The character is solid. Okay? You'll see that. We're going

1159
01:00:41,939 --> 01:00:44,505
to do a demo of that. Okay? So you can do this. You can put

1160
01:00:44,574 --> 01:00:47,142
these things in here for your homework. You'll use stroke,

1161
01:00:47,210 --> 01:00:50,479
color stroke with maybe a couple others. In the hints I

1162
01:00:50,547 --> 01:00:52,047
kind of tell you the things you need to use.

1163
01:00:52,115 --> 01:00:54,515
So, I don't want you wasting too much time looking up all

1164
01:00:54,584 --> 01:00:57,652
these things. Then you can created an attributed string

1165
01:00:57,721 --> 01:01:00,822
with that Dictionary for all the cards in the string by

1166
01:01:00,891 --> 01:01:03,491
just saying NSAttributedString using the initialize of

1167
01:01:03,560 --> 01:01:07,028
the text of string and the attributes. So that creates

1168
01:01:07,097 --> 01:01:09,430
an attributed string then I can take that attributed

1169
01:01:09,499 --> 01:01:12,901
string and like put it on my flipCountLabel, right?

1170
01:01:12,969 --> 01:01:15,470
Now my flipCountLabel, so this particular ones since I'm

1171
01:01:15,539 --> 01:01:19,107
using a positive stroke width this would be outlined text.

1172
01:01:19,175 --> 01:01:20,708
On my flip count. So I'm gonna do a demo and

1173
01:01:20,777 --> 01:01:23,277
see what that looks like in a second here.

1174
01:01:23,346 --> 01:01:25,380
I just briefly want to talk about the peculiarities of

1175
01:01:25,449 --> 01:01:27,716
NSAttributed strings since there's an NS.

1176
01:01:27,784 --> 01:01:29,551
You know, you see that NS at the beginning and you know,

1177
01:01:29,619 --> 01:01:32,654
hmm, this is kinda of an older API.

1178
01:01:32,722 --> 01:01:36,124
It's not a String. It's a totally different thing, okay.

1179
01:01:36,192 --> 01:01:37,992
An NSAttributedString is a class that's completely

1180
01:01:38,061 --> 01:01:41,796
different. Then String worked completely differently.

1181
01:01:41,864 --> 01:01:44,332
Because it's a class not a struct,

1182
01:01:44,401 --> 01:01:47,468
you can't make a mutable one by just using var.

1183
01:01:47,537 --> 01:01:49,670
You actually have to use a different class.

1184
01:01:49,739 --> 01:01:52,074
And it's mutable Attributable String. If you actually

1185
01:01:52,142 --> 01:01:54,342
wanted to go set the dictionaries on certain

1186
01:01:54,410 --> 01:01:57,345
characters individually, you would need to use a mutable

1187
01:01:57,414 --> 01:02:00,048
Attributable String, a completely different class

1188
01:02:00,116 --> 01:02:03,151
there. Also NSAttributedString was built and

1189
01:02:03,220 --> 01:02:07,088
constructed internally with NSString in mind. NSString is

1190
01:02:07,157 --> 01:02:10,892
the old Objective-C String. NSString and String have

1191
01:02:10,961 --> 01:02:14,262
a little different Unicode and coding underneath. So,

1192
01:02:14,331 --> 01:02:18,032
when you have wacky characters like emoji or cafe in there,

1193
01:02:18,101 --> 01:02:21,703
the indexes into them might not quite match up. And

1194
01:02:21,771 --> 01:02:24,873
there's automatic bridging between string and NSString so

1195
01:02:24,942 --> 01:02:27,175
if you have any iOS API that takes an NSString

1196
01:02:27,243 --> 01:02:29,477
as an argument, you can just pass a string.

1197
01:02:29,546 --> 01:02:32,114
It just automatically works except,

1198
01:02:32,182 --> 01:02:34,415
that this little encoding doesn't always get

1199
01:02:34,484 --> 01:02:39,020
fixed up quite right so the bottom line here is if you're

1200
01:02:39,089 --> 01:02:42,057
going to be trying to be index into an NSAttibutedString and

1201
01:02:42,125 --> 01:02:46,194
you have wacky characters like emoji or cafe, the indexes

1202
01:02:46,263 --> 01:02:49,330
might not line up very well. Now in your homework you don't

1203
01:02:49,399 --> 01:02:50,932
have to worry about any of that cuz I'm only gonna ask

1204
01:02:51,001 --> 01:02:53,868
you to make the entire String have the attributes. So

1205
01:02:53,937 --> 01:02:56,538
you're not even doing any indexing into there.

1206
01:02:56,606 --> 01:02:58,873
But in the future, if you're ever using AttributedString,

1207
01:02:58,941 --> 01:02:59,674
just be careful about

1208
01:02:59,743 --> 01:03:02,043
the indexing in there if you've got wacky characters.

1209
01:03:02,112 --> 01:03:07,282
All right, the demo. So, I'm gonna do this flip count

1210
01:03:07,350 --> 01:03:11,353
thing and show you what this looks like real quick here.

1211
01:03:13,023 --> 01:03:14,555
Where do we do that? That's right up here,

1212
01:03:14,624 --> 01:03:17,091
right? Here's where we set our flipCountLabel to Flips:

1213
01:03:17,160 --> 01:03:19,794
\(flipCount). So I'm going to put attributed text there. So

1214
01:03:19,863 --> 01:03:22,430
I'm going to let my attributes, which I have to

1215
01:03:22,498 --> 01:03:29,671
type to be [NSAttributedStringKey:

1216
01:03:29,740 --> 01:03:34,642
Any] =. And now I can just put the things I want, so

1217
01:03:34,711 --> 01:03:40,415
I want the StrokeWidth to be 5.0.

1218
01:03:40,483 --> 01:03:44,552
Okay, that's a fairly thick stroking width.

1219
01:03:44,621 --> 01:03:47,055
And then what was the other thing I said I wanted to, oh,

1220
01:03:47,124 --> 01:03:50,692
the color. So the strokeColor and I'll go ahead and

1221
01:03:50,761 --> 01:03:54,195
use the color literal here. Use our favorite color,

1222
01:03:54,264 --> 01:03:59,000
which is orange. Halloween color. Okay,

1223
01:03:59,069 --> 01:04:02,403
so now if I wanna use these attributes to draw the text on

1224
01:04:02,472 --> 01:04:05,039
my label, I'm just gonna create an attributedString.

1225
01:04:05,108 --> 01:04:08,710
So I'm gonna say, let attributedString equal. By

1226
01:04:08,778 --> 01:04:11,412
creating an attributedString with its constructor,

1227
01:04:11,481 --> 01:04:13,414
I want the one down here at the bottom.

1228
01:04:13,483 --> 01:04:15,816
It takes attributes and string. Okay, so

1229
01:04:15,885 --> 01:04:18,352
what you're gonna do for your Homework-2. I put the string,

1230
01:04:18,421 --> 01:04:22,356
it's just this string right here. And

1231
01:04:22,425 --> 01:04:26,627
attributes is these attributes I just created up there. And

1232
01:04:26,696 --> 01:04:29,564
then instead of saying flipCountLabel.text,

1233
01:04:29,633 --> 01:04:33,335
I say attributedText. And for a button, you would say set

1234
01:04:33,403 --> 01:04:36,838
attributedTitle for state instead of setTitle for

1235
01:04:36,906 --> 01:04:40,141
state and that equals this attributedString.

1236
01:04:40,209 --> 01:04:43,945
Okay, so that's all you need to do. So let's run this and

1237
01:04:44,013 --> 01:04:46,581
we're gonna see something a little bit kind of odd about

1238
01:04:46,650 --> 01:04:51,052
this, though. A little bit unexpected, I think.

1239
01:04:51,121 --> 01:04:54,522
So here we go. Hey, it didn't draw anything different.

1240
01:04:54,591 --> 01:04:55,823
Look at that, Flips: 0.

1241
01:04:55,892 --> 01:04:58,893
That looks exactly like before we made this change.

1242
01:04:58,962 --> 01:05:03,497
But, oh, look, if I click, now I'm getting the outlined font.

1243
01:05:03,566 --> 01:05:05,833
See how it's outlining my Flips?

1244
01:05:05,902 --> 01:05:10,338
So why when it first came up didn't this work, right here?

1245
01:05:12,709 --> 01:05:15,843
Yeah because this right here, this little =0,

1246
01:05:15,912 --> 01:05:19,414
this initialization, that does not cause the didSet to

1247
01:05:19,483 --> 01:05:22,650
happen. Okay, so that's an important thing to know.

1248
01:05:22,718 --> 01:05:26,554
When you initialize a var, it does not invoke the didSet,

1249
01:05:26,623 --> 01:05:30,525
only later settings of flipCount. So

1250
01:05:30,593 --> 01:05:32,693
how can we fix this? Well, I'm gonna take this and

1251
01:05:32,762 --> 01:05:37,265
put it in it's own little func. Okay, private func,

1252
01:05:37,334 --> 01:05:43,471
I'm gonna call it updateFlipCountLabel.

1253
01:05:43,540 --> 01:05:45,006
I'm gonna put that in there, and

1254
01:05:45,074 --> 01:05:47,441
I'm gonna call this updateFlipCountLabel in here.

1255
01:05:47,510 --> 01:05:49,176
updateFlipCountLabel, and

1256
01:05:49,245 --> 01:05:52,814
where's the other place I need to update the FlipCountLabel?

1257
01:05:52,882 --> 01:05:56,217
Well, here's another thing to learn that's kind of cool.

1258
01:05:56,286 --> 01:05:58,653
This, right here, is the label, right?

1259
01:05:58,721 --> 01:06:03,991
If you remember in our UI over here, that this right here

1260
01:06:04,060 --> 01:06:09,330
is connected up to that, right, it's connected. Now,

1261
01:06:09,399 --> 01:06:12,767
this connection gets made by iOS when you start up your UI,

1262
01:06:12,836 --> 01:06:14,869
right, it makes that connection.

1263
01:06:14,938 --> 01:06:19,473
Well, when it makes that connection, it's setting this.

1264
01:06:19,542 --> 01:06:24,745
So guess what, we can use didSet here.

1265
01:06:24,814 --> 01:06:26,648
When you have an outlet,

1266
01:06:26,716 --> 01:06:30,885
didSet does get called when that outlet gets set by iOS,

1267
01:06:30,954 --> 01:06:34,955
when this connection right here gets made, that gets

1268
01:06:35,024 --> 01:06:39,693
called. So here we can update our flipCountLabel here. Okay,

1269
01:06:39,762 --> 01:06:43,697
so now that flipCountLabel is gonna be updated when we first

1270
01:06:43,766 --> 01:06:47,268
connect that flip zero and also every time we change it

1271
01:06:47,337 --> 01:06:52,974
after that. Got it? All right, back to our slides. So,

1272
01:06:53,043 --> 01:06:55,843
you learned two things there, right? You learned that that

1273
01:06:55,912 --> 01:06:59,280
equal zero didn't cause didSet to happen and you learned that

1274
01:06:59,348 --> 01:07:02,449
on an outlet, you can didSet. You can set things because

1275
01:07:02,518 --> 01:07:04,652
that outlet just got hooked up for you.

1276
01:07:04,721 --> 01:07:08,022
All right, last really, really important thing here. We need

1277
01:07:08,090 --> 01:07:09,724
to really rush, because we're running out of time.

1278
01:07:09,792 --> 01:07:12,994
This is very important, this is about functions as types.

1279
01:07:13,062 --> 01:07:16,097
So I believe the supreme court a couple of years ago that

1280
01:07:16,165 --> 01:07:19,667
functions are people too. And so functions get the full

1281
01:07:19,735 --> 01:07:22,236
treatment of a type that any other type gets.

1282
01:07:22,305 --> 01:07:25,039
You can use a function as a type anywhere, all right? And

1283
01:07:25,107 --> 01:07:28,009
you do it just by declaring an argument to a function or

1284
01:07:28,078 --> 01:07:30,378
a var, whatever, to be of type function.

1285
01:07:30,446 --> 01:07:31,645
And you specify the arguments and

1286
01:07:31,714 --> 01:07:33,147
the return value of that function. So

1287
01:07:33,215 --> 01:07:35,883
it'll be a variable of that. So you can do this anywhere

1288
01:07:35,952 --> 01:07:38,853
a type is allowed. Let's look at an example. I have a var

1289
01:07:38,921 --> 01:07:43,390
here called operation. It is of type function that takes

1290
01:07:43,459 --> 01:07:47,862
a double and returns a double. So the syntax here is awesome.

1291
01:07:47,931 --> 01:07:50,999
It looks just like declaring a function that takes a double

1292
01:07:51,067 --> 01:07:54,302
and return it, just no names of arguments, but the types

1293
01:07:54,370 --> 01:07:58,572
are all in there. So this is how you declare a function.

1294
01:07:58,641 --> 01:08:00,375
You declare a var that is a function.

1295
01:08:00,443 --> 01:08:02,911
You can do it for variables, passing to functions,

1296
01:08:02,979 --> 01:08:06,113
parameters, everything. You can always do this. So

1297
01:08:06,182 --> 01:08:09,917
you can assign this var, it's exactly like you would think.

1298
01:08:09,986 --> 01:08:12,853
I'm gonna assign operation = sqrt. Okay,

1299
01:08:12,922 --> 01:08:16,724
sqrt is a function that takes a double and returns a double.
sqrt 是个函数，接受一个 Double，返回一个 Double

1300
01:08:16,792 --> 01:08:20,161
So it's perfectly legal for me to say operation = sqrt,
因此我写 operation = sqrt 是完全合法的

1301
01:08:20,230 --> 01:08:24,198
all right? And how do I call it? Well, I call it just like
那么我要如何调用它呢？我可以就像

1302
01:08:24,266 --> 01:08:27,969
a function. Operation of 4.0 is gonna call, in this case,
调用一个函数一样调用它，在这个例子中 operation(4.0)

1303
01:08:28,037 --> 01:08:31,872
square root of 4.0, because operation is a function var,
会调用 sqrt(4.0)，因为 operation 是一个函数类型变量

1304
01:08:31,941 --> 01:08:33,974
that's holding a functioning.
它储存着一个函数

1305
01:08:34,043 --> 01:08:37,144
That function is square root, okay. Could not be simpler.
那个函数就是平方根。这很简单，对吧

1306
01:08:37,213 --> 01:08:40,114
Everybody cool with this? Now, other languages have function
所有人都懂了吧。其他语言中有

1307
01:08:40,182 --> 01:08:43,017
pointers and all this stuff, but it's all pretty tortuous
函数指针啥的，那些用起来都有些拐弯抹角的

1308
01:08:43,086 --> 01:08:46,020
to use. But in Swift, it's a first class citizen, okay.
但在 Swift 中，它就是“一等公民”

1309
01:08:46,089 --> 01:08:47,355
Functions are a first class citizen.
函数是“一等公民”

1310
01:08:47,424 --> 01:08:50,358
They will be the argument to many iOS methods,
它们会作为许多 iOS 函数的参数

1311
01:08:50,426 --> 01:08:53,628
functions will be. Okay, now a lot of times,
好的，那么大多数时候

1312
01:08:53,696 --> 01:08:57,665
the function you wanna past doesn't already exist.
你想作为参数传递的那个函数还不存在

1313
01:08:57,734 --> 01:09:00,701
So forces you to go write a function to pass in. For
那么它就要求你自己写一个函数来传递

1314
01:09:00,770 --> 01:09:04,639
example, let's say I had the function changeSign, okay. So
举个例子，比如说我需要函数 changeSign

1315
01:09:04,707 --> 01:09:07,942
there's no thing like square root that does change signs.
而我们并没有一个函数来实现改变符号，sqrt 也不会改变符号

1316
01:09:08,010 --> 01:09:10,878
So I have to write a really simple little function here,
所以我就需要在这里写一个非常简单的小函数

1317
01:09:10,946 --> 01:09:11,896
And all it does, it takes a double and returns a double,
它做的就是接受一个 Double 型并返回一个 Double 型

#TODO: 1318这里多了
1318
01:09:11,897 --> 01:09:12,847
changeSign.

1319
01:09:12,915 --> 01:09:15,983
just like square root. And it returns minus the operand.
就像 sqrt 一样。而它返回的是 -operand

1320
01:09:16,051 --> 01:09:19,020
So I'm changing the sign of the operand here. So I could
这样我就可以改变这个 operand 的符号了

1321
01:09:19,088 --> 01:09:21,588
use it in the same way. I've got an operation. I'll just
那么我就可以以同样的方式来使用它了，我这有 operation

1322
01:09:21,657 --> 01:09:24,358
say operation = changeSign instead of operation = sqrt.
我只用写 operation = changeSign，而不是 operation = sqrt

1323
01:09:24,427 --> 01:09:26,527
But this is kind of a lot of typing and
但只为了实现改变符号就来写一个函数

1324
01:09:26,596 --> 01:09:29,630
annoying to have to go create a whole function to do
的话要敲不少代码，而且有点令人厌烦

1325
01:09:29,699 --> 01:09:33,300
changeSign when all I want is for that thing to change sign.
因为我想做的就只是改变符号而已

1326
01:09:33,369 --> 01:09:35,703
So we can do, use what's called a closure.
那么我们可以使用闭包(closure)

1327
01:09:35,772 --> 01:09:37,738
How many people have heard the phrase closure,
有多少人听说过闭包

1328
01:09:37,807 --> 01:09:39,307
know what a closure is?
知道闭包是什么

1329
01:09:39,375 --> 01:09:43,577
Okay, about half of you again. Okay, so closure is really
好的，差不多你们当中的一半。那么闭包实际上

1330
01:09:43,646 --> 01:09:46,580
like an inlined function. It's a little special in that it
就像一个内联函数，它有点特别的就是它会

1331
01:09:46,649 --> 01:09:49,784
captures the state around it but it's essentially an inline
捕捉它周围的状态。但它本质上就是一个内联函数

1332
01:09:49,852 --> 01:09:52,620
function. So what does the syntax look like if we wanted
那么我们要用怎样的语法才能

1333
01:09:52,689 --> 01:09:55,522
to take changeSign and just drop it right into the middle
直接获取 changeSign 并将直接放在这段代码中呢

1334
01:09:55,591 --> 01:09:58,192
here instead of having a separate function? Okay,
而不是在另写一个函数

1335
01:09:58,261 --> 01:10:00,061
how would we do that? All right,
我们如何才能做到这一点呢

1336
01:10:00,130 --> 01:10:02,830
we're just gonna pick up all of changeSign except for
我们只需要选中除了名字的 changeSign 函数的全部

1337
01:10:02,899 --> 01:10:04,365
its name and move it down.
部分，并将它移下来

1338
01:10:04,433 --> 01:10:07,635
Watch, okay, so I just put it right in there. Now I
看，我就只用将它放在这里

1339
01:10:07,704 --> 01:10:11,072
do have to make one syntactic change here, very important.
那么我现在还要在改变一处语法，这很重要

1340
01:10:11,141 --> 01:10:14,275
I have to move that first curly brace, the one right
我必须要将这个第一个大括号

1341
01:10:14,344 --> 01:10:17,345
before the word return. I had to move it to beginning and
在 return 前面的那个，我要将它移到开始部分

1342
01:10:17,413 --> 01:10:20,948
replace it with the word in, so watch this happen.
并在它原来的位置用 in 代替，看好了

1343
01:10:21,017 --> 01:10:24,318
This moves to the front, put the word in. That's it though.
这个移到前面去，将 in 放进去，就是这样

1344
01:10:24,387 --> 01:10:27,654
Once you make that small syntactic change, you can drop
一旦你完成了这个小的语法改变，你就可以

1345
01:10:27,723 --> 01:10:31,359
any function right in there. But it gets much better on
将任何函数放在这里。我们这样做会更加的好

1346
01:10:31,427 --> 01:10:35,629
this because we have type inference in Swift. And Swift
因为在 Swift 中有类型推断

1347
01:10:35,698 --> 01:10:39,734
can absolutely go to town here because it knows a lot about
并且 Swift 在这里当然也会这么做，因为它非常了解

1348
01:10:39,802 --> 01:10:44,138
what's going on here. For example, Swift knows that this
这里正在发生着什么。比如说，Swift 知道这个

1349
01:10:44,207 --> 01:10:47,775
operation thing returns a double. It knows that, so
operation 返回一个 Double 型，它知道的

1350
01:10:47,843 --> 01:10:50,645
you don't need to say returns double there, so just take
所以你不需要在这里写 return double，把它拿去

1351
01:10:50,713 --> 01:10:54,849
that out. it also knows that the operand is a double, so
就好了。Swift 也知道 operand 是 Double 型的

1352
01:10:54,918 --> 01:10:58,052
you don't need to say that that operand is a double,
所以你这里不需要写 operand 是 Double

1353
01:10:58,121 --> 01:11:00,454
you can take that out, right?
你可以把它也拿去

1354
01:11:00,523 --> 01:11:03,224
It also knows that this function returns something, so
Swift 也知道这个函数会返回某个东西

1355
01:11:03,292 --> 01:11:07,595
you don't need the keyword return minus operand there. So
所以你这里也不需要关键字 return -operand

1356
01:11:07,663 --> 01:11:10,698
we can take that out as well. Okay, and even more,
因此我们也可以将它拿去。还有

1357
01:11:10,766 --> 01:11:13,835
Swift knows you want to have these embedded functions all
Swift 知道你希望这有个内嵌函数

1358
01:11:13,903 --> 01:11:16,938
the time, and it's a little annoying to have to think up
而每次都要为那个参数取个名字

1359
01:11:17,006 --> 01:11:19,740
a name for the argument to this thing. Okay, that
也是有点令人厌烦的

1360
01:11:19,808 --> 01:11:23,210
operand word that I had to think up there. So it lets you
就是那个单词 operand，我还要去想它，因此 Swift允许你用

1361
01:11:23,279 --> 01:11:27,681
substitute $0 for the first one, $1 for the second, $3 for
$0 代替第一个参数，$1 代替第二个参数，$3（误：应为 $2） 代替

1362
01:11:27,750 --> 01:11:32,920
the third one. So I'm gonna replace operand there with $0.
第三个参数。那么我在这里可以用 $0 来代替 operand

1363
01:11:32,988 --> 01:11:35,556
And when I do that, I don't need the in anymore either.
那么如果我这样做了，我也不需要这个 in 了

1364
01:11:38,461 --> 01:11:42,096
Now you see the power of the closure. Okay,
现在你们见识到闭包的强大了

1365
01:11:42,165 --> 01:11:45,265
I wanted to have an operation that changes the sign.
当我想要一个操作来改变符号

1366
01:11:45,334 --> 01:11:47,868
And I barely had to type any more characters than
我基本上不用打比 changeSign 这个名字

1367
01:11:47,937 --> 01:11:52,973
the changeSign, just the curly braces around it. And that's
更多的代码，就只用大括号那些就可以了

1368
01:11:53,042 --> 01:11:56,911
still gonna do, operation 4.0 is still gonna do -4.0. Okay,
并且这样仍然可以改变符号，operation(4.0) 仍然会返回 -4.0

1369
01:11:56,979 --> 01:11:59,380
so you're gonna be using closures all the time, and
所以你会经常使用到闭包

1370
01:11:59,449 --> 01:12:01,949
you're gonna be using these $0, 1, $1, $2,
并且你也经常会用 $0, 1, $1, $2

1371
01:12:02,017 --> 01:12:04,552
as the argument names. And it's gonna make it so that you
来当做参数的名字。这样做的话

1372
01:12:04,620 --> 01:12:07,187
have to type very little code to put the things in.
你只用写很少的代码就能将想要的功能放进来

1373
01:12:07,256 --> 01:12:09,990
Now why do I want closures, why do I want functions as
那么为什么我想要闭包呢

1374
01:12:10,059 --> 01:12:12,626
arguments? Well, it's usually because you,
为什么我想要函数能当做参数？那是因为

1375
01:12:12,695 --> 01:12:15,196
you're passing something to a function that wants to know
你时常要向一个函数传递一个参数，它才知道要

1376
01:12:15,264 --> 01:12:18,365
what to do. A function is a great way to tell it what to
做什么。那么用一个作为参数的函数是告诉它要做什么的很好的方式

1377
01:12:18,434 --> 01:12:21,335
do. Now why might it want to know what to do? Well,
那么那个函数想要知道自己该做什么呢

1378
01:12:21,404 --> 01:12:24,638
maybe it wants to know what to do if there's an error.
也许它想知道当出现了一个错误的时候自己该做什么

1379
01:12:24,707 --> 01:12:27,541
I'm gonna do something, it might generate an error, and
我会做某些事情，它可能会产生一个错误

1380
01:12:27,610 --> 01:12:30,110
I want to call a function in case there's an error so
那么当产生错误的时候，我希望调用一个函数

1381
01:12:30,179 --> 01:12:33,080
you can handle this function. Maybe it wants to know what to
来处理这个错误。那个函数也许想知道如果

1382
01:12:33,149 --> 01:12:35,382
do if it's gonna do something that takes a long time.
它要做一个很消耗时间的事情时该做什么

1383
01:12:35,451 --> 01:12:37,184
It's gonna go on the network and
比如说上网

1384
01:12:37,253 --> 01:12:40,754
download something off in the background and when it's done,
并在后台下载某些东西的时候，当下载完成后

1385
01:12:40,823 --> 01:12:44,525
it wants to tell you. Okay, we call a function to do that.
它想要提醒你。那么我们可以调用一个函数来做到这一点

1386
01:12:44,594 --> 01:12:47,060
Another thing is, it might be doing something repeatedly,
另外一件事是，它可能将会重复做某件事

1387
01:12:47,129 --> 01:12:49,997
it wants to do the same thing over and over. So it's asking
它想重复地做同样一件事，那么它就会

1388
01:12:50,066 --> 01:12:53,100
you to tell it what to do over and over. So let's take a look
问你要重复做什么事情。让我来看

1389
01:12:53,169 --> 01:12:55,937
at an example of that last one there, doing something over
最后的一个例子，我们要重复地做

1390
01:12:56,005 --> 01:13:00,074
and over. So array, naturally, it's a collection.
某些事情。那么，数组在本质上是一个集合

1391
01:13:00,143 --> 01:13:04,378
Well anyway, array has a method called map. And
数组有一个叫做 map 的函数

1392
01:13:04,447 --> 01:13:08,816
what map does, it takes only one argument, a function. And
而 map 做的就是，它接收一个参数，一个函数

1393
01:13:08,885 --> 01:13:12,586
it applies that function to every element in the array and
并且它对数组内的每个元素为参数调用那个函数

1394
01:13:12,655 --> 01:13:15,088
creates a new array. So
并创建一个新的数组

1395
01:13:15,157 --> 01:13:19,160
map returns a new array where every element in the array you
所以 map 会返回一个新的数组，它其中的每个元素

1396
01:13:19,228 --> 01:13:21,995
send it to gets operated on by some function.
就是以传入的那个函数对原数组每个元素运算后的返回值

1397
01:13:22,064 --> 01:13:24,131
In other words, it's a way to pass a function into array and
换句话说，这就是一种向数组中传入一个函数

1398
01:13:24,200 --> 01:13:26,534
tell it to do it on every element. Okay,
并用它运算在数组中每个元素的方法

1399
01:13:26,602 --> 01:13:29,370
that's what map does, so how does that work? Here I have
那就是 map 的功能，那么这是如何实现的呢

1400
01:13:29,439 --> 01:13:32,673
an array of floating point numbers. They happen to be
这里我有一个由浮点数组成的数组，它碰巧是

1401
01:13:32,742 --> 01:13:35,910
the first 5 prime numbers, right, 2, 3, 5, 7, 11 here.
前五个素数，对吧，2，3，5，7，11

1402
01:13:35,978 --> 01:13:39,714
And what if I wanted to have an array of all negative 2,
那么如果我想要一个由 -2，-3 那些

1403
01:13:39,782 --> 01:13:43,317
negative 3? Well I would just say negativePrimes =
组成的数组，我只用写 negativePrimes = prime.map({ -$0})

1404
01:13:43,386 --> 01:13:47,354
prime.map, the only argument is a function that does change
map 函数的唯一一个参数

1405
01:13:47,423 --> 01:13:48,989
sign, right? Just like we had on the previous slide,
就是用来改变符号的，对吧，它就像我们上一张幻灯片中的一样

1406
01:13:49,058 --> 01:13:51,692
change sign. And now we're getting a new array,
改变了符号。这样我们就得到了一个新的数组

1407
01:13:51,761 --> 01:13:56,163
negativePrimes is gonna be a new array with -2, -3, -5.
negativePrimes 就是一个包含 -2,-3,-5 的新数组

1408
01:13:56,231 --> 01:13:59,934
You see how I used map there? Now, list another example,
你看到我在这里是如何使用 map 了吧，另一个例子

1409
01:14:00,002 --> 01:14:02,770
maybe inverting the primes. So I'm gonna propriate
我想要得到这些数组的倒数

1410
01:14:02,839 --> 01:14:06,507
the closure, 1.0 divided by $0. Now I get 0.5, 0.33,
那么我就要改变这个闭包为 1.0 / $0，那我就会得到 0.5, 0.33

1411
01:14:06,575 --> 01:14:09,810
maybe I even want to convert it to a string.
也许我甚至想要将它转换为一个字符串

1412
01:14:09,878 --> 01:14:11,946
Perfectly legal, doesn't have to be the same type.
这是完全合法的，新的数组不一定要和原来的数组为同一个类型

1413
01:14:12,015 --> 01:14:15,516
I can return array of string. Now notice the yellow
我可以返回一个字符串的数组，现在注意到上面这些黄色的代码

1414
01:14:15,584 --> 01:14:18,519
things up there, changed a little with each line. You see
它们在各行是有些不同的

1415
01:14:18,587 --> 01:14:22,256
the first one map parentheses the closure. The next one
第一行闭包在小括号内

1416
01:14:22,325 --> 01:14:25,025
map open parentheses, closed parentheses then the closure.
第二行是 map() 后接着闭包

1417
01:14:25,094 --> 01:14:28,129
And the third one map, no parentheses and the closure.
在第三行中，map 后面没有小括号，紧接的就是闭包

1418
01:14:28,197 --> 01:14:31,632
Okay, this is using what's called trailing closure
这里是用的一个叫做 尾随闭包（trailing closure）

1419
01:14:31,701 --> 01:14:35,670
syntax, okay, we almost always use this. The rule here is,
的语法，我们基本上总是会这么用

1420
01:14:35,738 --> 01:14:39,907
if the last argument to any function is a closure,
它的规则是，如果一个函数的最后一个参数是闭包

1421
01:14:39,975 --> 01:14:43,343
you can move the closure outside the parenthesis of
你就可以将那个闭包移动到那些参数所在

1422
01:14:43,412 --> 01:14:46,981
the arguments. So see in the second line, inverted primes?
的小括号外面。看这里的第二行，当我们要去素数的倒数时

1423
01:14:47,049 --> 01:14:50,217
How I moved the closure outside? And furthermore,
我就把闭包移到括号外面去了

1424
01:14:50,286 --> 01:14:52,519
if it's the only argument,
还有，如果闭包是唯一一个参数

1425
01:14:52,588 --> 01:14:54,955
then you can just get rid of the parentheses entirely.
那么你就完全可以直接不写小括号

1426
01:14:55,023 --> 01:14:57,991
That's the third line, okay. And this is just to make our
就像第三行所展示的那样

1427
01:14:58,060 --> 01:15:00,627
code look nice. So we don't have extraneous parenthesis in
这样做就可以让我们的代码更好看。这样我们就可以将

1428
01:15:00,696 --> 01:15:03,364
there that we don't, beccause we've got the curly braces,
我们不需要的小括号去掉了。因为我们这里已经有大括号了

1429
01:15:03,433 --> 01:15:05,900
we kind of don't need those parentheses. Okay,
我们就不是很需要那些小括号了

1430
01:15:05,968 --> 01:15:10,204
so you'll see that in iOS when an argument to a function
那么你就会在 iOS 开发中看到，当一个函数的

1431
01:15:10,273 --> 01:15:13,274
is a function, it'll usually be the last argument. So
参数是一个函数时，它通常会是最后一个参数

1432
01:15:13,343 --> 01:15:15,242
that you can move it outside if you want.
这样如果你想的话，你就可以将它拿到外面

1433
01:15:15,311 --> 01:15:16,844
It's optional, you don't have to.
这是可选的，你不一定要这样做

1434
01:15:16,912 --> 01:15:19,079
All three of those are perfectly valid syntax right
这里的三种语法都是完全合法的

1435
01:15:19,148 --> 01:15:23,417
there. Okay, another cool use of closures,
好的，闭包的另一个很酷的用处

1436
01:15:23,485 --> 01:15:27,354
property initialization. What if you have a property and
在与属性初始化（property initialization），如果你有一个属性

1437
01:15:27,423 --> 01:15:29,356
you wanna initialize it to something but
并且你想将它初始化为某个东西

1438
01:15:29,425 --> 01:15:32,159
it's not like you just can't do one line thing, right.
但你不能以一行就搞定它

1439
01:15:32,227 --> 01:15:35,862
You can't say equals five or equals something simple. You
你不能就像写 =22 或等于其他什么这样简单

1440
01:15:35,931 --> 01:15:38,432
need to do two or three lines of code to get it initialized.
你需要两三行代码才能将它初始化

1441
01:15:38,501 --> 01:15:42,002
No problem, you're allowed to set the property equal to
没问题，你可以将这个属性赋值为一个

1442
01:15:42,071 --> 01:15:45,205
executing a closure. Now that closure is automatically
要执行的闭包，那么这个闭包自动地就会是

1443
01:15:45,274 --> 01:15:47,675
going to be a closure that takes no arguments and
一个不接受任何参数

1444
01:15:47,744 --> 01:15:51,412
returns the right type to initialize that property.
并且返回一个恰当类型，能初始化这个属性的闭包

1445
01:15:51,480 --> 01:15:53,347
So you can do anything you want in that closure and
所以你在这个闭包中可以做任何你想做的事情

1446
01:15:53,415 --> 01:15:55,182
just return something of the right type. And
只需要在最后返回一个正确的类型的值

1447
01:15:55,251 --> 01:15:58,652
then you execute it right away with open parenthesis, closed
接着你用 () 来立即执行它

1448
01:15:58,720 --> 01:16:01,522
parenthesis. See how there's the little open parenthesis,
看到这里的小括号了吗

1449
01:16:01,590 --> 01:16:04,625
closed parenthesis there right at the end of the closure?
它们就在这个闭包的后面

1450
01:16:04,694 --> 01:16:06,761
That's just gonna execute that closure right there.
它们就会在那里立即执行这个闭包

1451
01:16:06,829 --> 01:16:09,830
This is especially cool with lazy properties. Because it
这用在 lazy 属性中就很棒

1452
01:16:09,898 --> 01:16:12,433
means, this closure won't be executed until someone asks
因为这表示着，在这个属性被访问之前

1453
01:16:12,502 --> 01:16:16,036
for this property. Okay, so
这个闭包就不会执行

1454
01:16:16,105 --> 01:16:18,638
you're combining lazy in the closures. So
那么你就将 lazy 和闭包联系了起来

1455
01:16:18,707 --> 01:16:22,342
closures really cool for initializing properties. Now,
所以说闭包在初始化属性的时候非常有用

1456
01:16:22,411 --> 01:16:25,079
one thing about closures to be careful of.
而关于闭包值得警惕的一点是

1457
01:16:25,147 --> 01:16:29,483
They do capture their surrounding variables.
它们会捕捉它们周围的变量

1458
01:16:29,552 --> 01:16:32,386
So if I have a closure, it's just a function embedded right
所以如果我有一个闭包，它就是一个嵌在我的代码中的

1459
01:16:32,454 --> 01:16:35,156
in my code. If there are local variables, or
函数，如果在闭包所在的这个类中有局部变量

1460
01:16:35,224 --> 01:16:37,958
instance variables in the class I'm in, or whatever, and
或者实例变量，或者其他什么

1461
01:16:38,027 --> 01:16:42,296
I use them in the closure it works. And even if that
我就可以在闭包中使用它们。并且甚至当

1462
01:16:42,365 --> 01:16:45,966
closure sticks around, those things still continue to work
那个闭包被到处传递时，那些变量也仍然是有效的

1463
01:16:46,035 --> 01:16:49,936
until the closure goes away. What this means, though,
直到我的闭包消失。这就意味着

1464
01:16:50,005 --> 01:16:52,306
since closures are types and they can put in arrays and
闭包是类型，并且它们可以被装进数组和字典中

1465
01:16:52,375 --> 01:16:56,810
dictionaries, closures are reference types.
闭包是引用类型

1466
01:16:56,879 --> 01:17:01,014
There's only two reference types in Swift, classes and
Swift 中只有两种引用类型，类和闭包

1467
01:17:01,083 --> 01:17:02,683
closures. So what does that mean?
这意味着什么

1468
01:17:02,752 --> 01:17:05,285
It means this closure gets put in the heap if you put it in
这意味着当你将闭包装入数组时，它就被压入了堆中

1469
01:17:05,354 --> 01:17:08,856
an array. So that array actually has pointers to this
那么这个数组实际上是有指向这个闭包的指针

1470
01:17:08,925 --> 01:17:13,327
closure. Now this is a little mind bending. I don't expect
这里有一点绕弯子

1471
01:17:13,395 --> 01:17:16,330
you to get this right at the top. But it also means that,
我不要求你们现在马上就理解。但这也意味着

1472
01:17:16,398 --> 01:17:19,934
if you capture variables in your closure from your
如果闭包捕获了它周围代码

1473
01:17:20,002 --> 01:17:22,803
surrounding code, they have to go live in the heap too.
中的变量，它们也要被存入堆中

1474
01:17:22,872 --> 01:17:25,505
Because we can't have this closure not function, right?
因为我们不能让这个闭包错误地工作

1475
01:17:25,574 --> 01:17:28,842
Can't if this function has to be a function that executes.
这个闭包必须要是一个可以执行的函数

1476
01:17:28,911 --> 01:17:30,644
So here's an example of that.
这里有一个例子

1477
01:17:30,713 --> 01:17:33,848
Here I have a local variable called ltaue,
我这里有一个叫做 ltuae 的变量

1478
01:17:33,916 --> 01:17:35,382
life the universe and everything,
生命，宇宙，和其他一切

1479
01:17:35,451 --> 01:17:38,585
I think that stands for. It's set to 42. Okay,
大概是这个意思，它被赋值为42

1480
01:17:38,654 --> 01:17:41,822
and my operation, the closure there, says ltuae times $0. So
并且我的函数也就是这个闭包中写着 ltuae * $0

1481
01:17:41,891 --> 01:17:47,594
that closure is actually using a local variable inside it.
这个闭包实际上在它其中使用着一个局部变量

1482
01:17:47,663 --> 01:17:51,264
Now what happens if I put that operation in an array? Okay,
那么当我将这个 operation 放入数组中会发生什么

1483
01:17:51,333 --> 01:17:53,700
and then later go back and get it out of the array, and
我之后还会从数组中将它取出并

1484
01:17:53,769 --> 01:17:56,837
execute it. Well, when it does that, ltuae still needs to be
执行它。那么为了能做到这一点，ltuae 仍然需要

1485
01:17:56,905 --> 01:18:00,741
there. Because otherwise, the closure won't execute. So
在我们的堆中，否在的话闭包无法执行

1486
01:18:00,810 --> 01:18:05,079
ltuau, the ltuae gets captured into the heap and
那么 ltuae 就会被捕获到堆中

1487
01:18:05,148 --> 01:18:07,681
stays there until the closure goes away.
并且待在堆中，直到闭包离开堆

1488
01:18:07,749 --> 01:18:10,217
Now, this is awesome, it all just works magically.
这很棒，它奇迹般地就可以工作了

1489
01:18:10,286 --> 01:18:13,487
You don't have to think about it, except in one case, and
你不用去考虑它，除了在一种情况下

1490
01:18:13,555 --> 01:18:15,522
that's a memory cycle.
就是引用循环（memory cycle）

1491
01:18:15,590 --> 01:18:18,391
This can create a memory cycle because you might capture
这可能会生成一个引用循环，因为你有可能会捕获

1492
01:18:18,460 --> 01:18:22,696
the class that array of operations is in. Okay,
装有 operation 的数组所在的类

1493
01:18:22,764 --> 01:18:26,766
if you capture the class that array is of operations in,
如果你捕获了装有 operation 的数组所在的类

1494
01:18:26,835 --> 01:18:31,605
then this closure has captured that class into the heap. And
闭包接着将那个类捕获进堆

1495
01:18:31,674 --> 01:18:35,275
that class through its array is captured
并且那个类通过它其中的数组

1496
01:18:35,344 --> 01:18:36,877
the closure in the heap. So
也将闭包捕获进了堆

1497
01:18:36,946 --> 01:18:38,912
they're pointing to each other through the array,
以数组为中介，它们在指向对方

1498
01:18:38,981 --> 01:18:41,448
you see? They're creating a memory cycle, that closure is
你能理解吗，它们这样就产生了引用循环

1499
01:18:41,517 --> 01:18:43,717
keeping the class, the class is keeping the closure.
闭包将类留在堆中，类将闭包留在堆中

1500
01:18:43,786 --> 01:18:44,584
They're staying in the heap,
这样它们都会被留在堆中

1501
01:18:44,653 --> 01:18:47,153
they can never leave until someone removes that closure
直到有人从数组中移除那个闭包之前

1502
01:18:47,222 --> 01:18:49,156
from this array, for example. So,
它们都不会离开

1503
01:18:49,225 --> 01:18:52,592
we can break closure cycles like these. We use that thing,
我们可以这样打破这个循环：我们用

1504
01:18:52,661 --> 01:18:54,995
I talked about last time, unowned. Remember, unowned?
我之前讲过的那个 unowned，还记得吗

1505
01:18:55,063 --> 01:18:57,164
When we talked about weak and strong and unowned.
当我们讲到 weak 和 strong 和 unowned

1506
01:18:57,233 --> 01:18:59,266
And I said, I'll tell you what unowned is. So
我说下次再告诉你们 unowned 是什么

1507
01:18:59,335 --> 01:19:01,701
I'm gonna put these two things together. Unowned and
我们将会把 unowned

1508
01:19:01,770 --> 01:19:04,238
the fact that we can have these cycles. In a couple of
和这个引用循环放在一起讲

1509
01:19:04,306 --> 01:19:07,007
weeks, I'll talk to you, how we break these cycles. Okay,
几周后我就会教你们如何打破这个引用循环

1510
01:19:07,076 --> 01:19:09,977
how we can create a closure that will not keep
教你们如何写一个不会将别的东西

1511
01:19:10,046 --> 01:19:14,514
something else in. Okay so, let's see a demo of closures.
装进来的闭包。好的，让我们来看闭包的一个示例

1512
01:19:14,583 --> 01:19:17,851
I'm gonna improve the method indexOfOneAndOnlyFaceUpCard
我会将 indexOfOneAndOnlyFaceUpCard 改进得

1513
01:19:17,920 --> 01:19:21,021
card to be way better. And not only am I gonna use closures,
更好，并且我不仅会用闭包

1514
01:19:21,090 --> 01:19:23,824
I'm gonna go back and use extensions to protocols, and
还会用协议的扩展

1515
01:19:23,893 --> 01:19:26,493
I'm gonna tie this all together. Okay, so
并且我会将它们联系在一起

1516
01:19:26,562 --> 01:19:30,931
lets do that. Over here, if we remember,
让我们开始吧，这儿，如果我们

1517
01:19:31,000 --> 01:19:35,102
our, we'll make it one big window here. If we go
还记得的的话...把这个屏幕放大点

1518
01:19:35,171 --> 01:19:37,838
back to our concentration, all right, here's concentration.
我们来到我们的 concentration 好的，这是 concentration

1519
01:19:37,907 --> 01:19:39,973
Remember we had indexOfOneAndOnlyFaceUpCard,
还记得我们有 indexOfOneAndOnlyFaceUpCard

1520
01:19:40,042 --> 01:19:43,343
which, supposedly made our code simpler,
它本应让我们的代码更加简洁的

1521
01:19:43,412 --> 01:19:46,213
which it did down here. It made this code really
它在这里做到了，它让这里的代码

1522
01:19:46,281 --> 01:19:49,716
beautiful and readable down here. But, it actually added
变得非常优美也非常具有可读性，但是，它实际上

1523
01:19:49,785 --> 01:19:53,754
quite a bit of code here. But this is way more code than you
在这里加了不少的代码，这超出了你实际需要的代码

1524
01:19:53,822 --> 01:19:56,657
actually need To find the index of the oneAndOnly
如果你用一个接受闭包的函数

1525
01:19:56,725 --> 01:20:00,594
face card, if you use a method that takes a closure. Now,
来找到唯一一张朝上的牌

1526
01:20:00,663 --> 01:20:03,196
the method we're gonna use, it's kinda like map,
那么我们要用的函数，有点像 map

1527
01:20:03,265 --> 01:20:07,701
its on collection, it's called filter. So what filter
它是在 collection 中的函数，它叫做 filter

1528
01:20:07,769 --> 01:20:10,437
does is it goes through every item in the collection and
它做得就是遍历集合中的每个元素

1529
01:20:10,505 --> 01:20:13,040
executes a function that you provide. Filter only has one
并且对它们执行你提供的那个函数

1530
01:20:13,108 --> 01:20:16,810
argument. It's a function. That function returns a bool.
filter 只接受一个参数，那是一个返回布尔类型的函数

1531
01:20:16,878 --> 01:20:20,246
So it executes that function with the argument being each
那么它以集合中的每个元素为参数来

1532
01:20:20,315 --> 01:20:23,751
item in the collection. If that function returns true,
执行这个函数，如果这个函数的返回值为真

1533
01:20:23,820 --> 01:20:26,253
then it puts it in a new array, okay, and
那么它就将这个元素装进一个新的数组中

1534
01:20:26,321 --> 01:20:29,089
if it turns false, it doesn't. So essentially
而如果返回假，就不装进去

1535
01:20:29,158 --> 01:20:32,759
filters the collection into an array, but only the ones that
那么它本质上就是将这个集合过滤进一个数组中

1536
01:20:32,828 --> 01:20:35,195
return true from the function. See what I'm saying? So
而且只保留了让这个函数返回真的那些元素，能理解吗

1537
01:20:35,264 --> 01:20:37,564
that's why it's called filter. Filters the collection,
这就是它叫作 filter 的原因，过滤这个集合

1538
01:20:37,633 --> 01:20:40,100
makes an array out of the ones that return true. Well,
以返回真的那些元素创建一个数组

1539
01:20:40,169 --> 01:20:43,069
that's great for this, because index of oneAndOnly face card.
我们这里用它非常合适，因为如果我们要唯一朝上的牌的下标

1540
01:20:43,138 --> 01:20:45,639
How about I go look at all the indexes of the cards and
我可以遍历这些牌的下标

1541
01:20:45,707 --> 01:20:49,876
just find the indexes that have face up cards? So I just
然后找到朝上的牌的下标

1542
01:20:49,945 --> 01:20:52,045
need a function that says whether a card's face up and
那么我需要一个函数来判断那张牌是否朝上

1543
01:20:52,114 --> 01:20:56,083
I can do it. So let's do that. I'm gonna let index, we'll say
让我们开始吧，我要 let index

1544
01:20:56,152 --> 01:21:01,154
the let the face up card indices I'll call it, okay,
呃 let faceUpCardIndices 我要这么命名

1545
01:21:01,223 --> 01:21:05,325
this is gonna be an array. I'm gonna let it equal to my card
这会是一个数组，我要让它等于

1546
01:21:05,394 --> 01:21:09,430
indices. Card indices, what type is card indices,
我的 card.indices 它的类型是什么

1547
01:21:09,498 --> 01:21:14,033
anyone remember? Oh I just showed you what it was.
还有人记得吗，哦我让你们看到了

1548
01:21:14,102 --> 01:21:19,039
Right, right? It's accountable range of int. It indexes into
对吧，它是由整型组成的可数区间

1549
01:21:19,108 --> 01:21:24,144
the cards array. So I'm gonna filter those indices by
它可以遍历这个 cards 数组，那么我就要过滤这个 indices

1550
01:21:24,213 --> 01:21:26,913
providing a function. And it's the only argument, so
提供一个函数为参数，并且这个函数是唯一参数

1551
01:21:26,982 --> 01:21:28,449
I don't need any parentheses or
所以我不需要小括号

1552
01:21:28,517 --> 01:21:31,885
anything, I'm just gonna put it after. This function just
或其他什么，我只用将它放在这后面就好了

1553
01:21:31,954 --> 01:21:35,622
needs to look at the index and see if that's a face up card.
这个函数只需要查看这个下标，并看看它是不是一张朝上的牌

1554
01:21:35,691 --> 01:21:39,726
So that's cards sub the index, we'll just use $0,
所以这是 cards[$0] 就可以了

1555
01:21:39,794 --> 01:21:44,664
which is the one argumentative function, isFaceup. Okay,
$0 是这个函数的第一个参数，并加上 isFaceUp

1556
01:21:44,733 --> 01:21:46,800
so that's a Boolean function, right here.
那么这是一个布尔类型的函数

1557
01:21:46,868 --> 01:21:50,103
This is a Boolean function, executed by a closure, right
这是一个布尔类型的函数，它由闭包来执行

1558
01:21:50,172 --> 01:21:53,506
in there that returns true, if the card of that index is face
当那个下标的牌是朝上的牌的时候

1559
01:21:53,575 --> 01:21:56,676
up. So, now I've created this which is an array,
返回真。那么我现在创建了这个，它是一个数组

1560
01:21:56,745 --> 01:21:59,179
it's an array of array indexes by the way.
它是一个由数组下标（Array.Index）组成的数组

1561
01:21:59,248 --> 01:22:01,948
Let's take a look, see. Array of array indexes.
让我们看看，由数组下标组成的数组

1562
01:22:02,017 --> 01:22:05,819
This type Array.Index, remember, we had String.Index,
这个类型，Array.Index 还记得我们有 String.Index

1563
01:22:05,887 --> 01:22:09,690
Array.Index, is type aliased or just set equal to be int.
Array.Index 是 Int 的别名，它被设置为等于 Int

1564
01:22:09,759 --> 01:22:12,225
That's why arrays can be indexed by int,
这是数组可以被整型索引的原因

1565
01:22:12,294 --> 01:22:15,595
cuz their Array.Index is int. That's not true for strings.
因为它们的 Array.Index 就是 Int，对于字符串来说不是这样的

1566
01:22:15,664 --> 01:22:19,699
String.Index, unfortunately, is not int. Okay, so
String.Index 并不是整型

1567
01:22:19,768 --> 01:22:23,437
this is an array of all the indices. Now, if this only has
那么这是一个装着所有（牌朝上的）下标的数组

1568
01:22:23,506 --> 01:22:26,639
one thing in it then we have one face up card.
那么如果它里面有一个元素，我们就有一个朝上的牌

1569
01:22:26,708 --> 01:22:30,377
We all agree with that? So I'm just gonna return here,
你们能理解吧，那么我在这里只需要返回

1570
01:22:30,446 --> 01:22:34,914
that if faceUpCardIndices.count ==1,
if faceUpCardIndices.count == 1

1571
01:22:34,983 --> 01:22:41,555
I am going to return the faceUpCardIndices.first,
我们就返回 faceUpCardIndices.first

1572
01:22:41,623 --> 01:22:44,024
first is just a collection method that returns the first
first 是一个集合中的函数，它返回

1573
01:22:44,093 --> 01:22:46,960
thing in the collection. Otherwise, I'm gonna return
集合中的第一个元素，否则我就会

1574
01:22:47,029 --> 01:22:49,696
nil, because we either have zero face up cards or
返回 nil，因为我们不是没有朝上的牌

1575
01:22:49,765 --> 01:22:52,966
we have more than one, in either case, we'll return 0.
就是有超过一张朝上的牌。这两种情况下，我们都返回 0（误：返回 nil）

1576
01:22:53,035 --> 01:22:56,770
So I don't need any of this stuff right here. Okay,
那么我就不需要这里的这些代码了

1577
01:22:56,839 --> 01:23:00,473
so this is a lot cleaner than this whole thing.
这样就比这看起来就简洁多了

1578
01:23:00,542 --> 01:23:03,310
Everybody agree with that? And a little more readable too.
大家都同意吧，这也更加易读了

1579
01:23:03,379 --> 01:23:05,979
Give me all the face card indices by filtering
给我所有朝上的牌的下标

1580
01:23:06,048 --> 01:23:09,216
the indices to show me the ones that are face up. Okay,
通过过滤所有下标来找到所有朝上的牌

1581
01:23:09,285 --> 01:23:11,618
it kind of reads a little better as well, but
这样读起来就更好一些

1582
01:23:11,687 --> 01:23:13,586
we can do better than this even.
但我们可以做得更好

1583
01:23:13,655 --> 01:23:16,156
And we're gonna do better by creating an extension to
我们可以在这里创建一个协议的扩展

1584
01:23:16,224 --> 01:23:20,827
a protocol down here. The protocol we're gonna extend is
我们要扩展到的协议是

1585
01:23:20,896 --> 01:23:25,832
collection. So we're gonna add a var. Could be a function,
collection 那么我们将添加一个变量，可以是函数

1586
01:23:25,901 --> 01:23:27,734
but it's gonna be a var to collection.
这里是变量

1587
01:23:27,802 --> 01:23:30,437
So, I'm gonna be adding it to string, dictionary,
所以我也会将它添加到字符串，字典和

1588
01:23:30,506 --> 01:23:33,240
array, all these things. And what it's gonna do,
数组，这些实现了集合的类型中。而它会做什么呢

1589
01:23:33,309 --> 01:23:39,045
it's gonna be the oneAndOnly. And it's gonna return
它叫做 oneAndOnly 并且

1590
01:23:39,114 --> 01:23:43,216
the one and only thing in that collection, if there's only
如果集合中只有一个元素它会返回那个集合中

1591
01:23:43,285 --> 01:23:45,953
one thing in the collection or it's gonna return nil.
唯一一个元素，否则它会返回 nil

1592
01:23:46,021 --> 01:23:47,553
Now, what is the type,
那么它的类型

1593
01:23:47,622 --> 01:23:52,325
of oneAndOnly gonna be? Well, collection is a generic type.
应该是什么呢，集合是泛型

1594
01:23:52,394 --> 01:23:55,695
And it has one of its generic things as element,
而它就有它泛型的的那个东西 Element

1595
01:23:55,764 --> 01:23:59,633
which is the type of the thing in there. So element is just
就是集合中所存储的数据的类型，那么 Element

1596
01:23:59,701 --> 01:24:03,303
like a placeholder, right, in the array of element.
就像一个占位符，就比如说由 Element 组成的数组

1597
01:24:03,371 --> 01:24:06,506
You recognize that? For in a generic type, it's the type.
你们能理解吧，对于一个泛型来说，这就是它的类型

1598
01:24:06,575 --> 01:24:08,208
And of course I want it to be optional.
当然我希望它是可选类型

1599
01:24:08,277 --> 01:24:10,844
Because I'm only gonna return non nil, if there's one and
因为我只会在当这个集合中有且只有

1600
01:24:10,912 --> 01:24:14,181
only one thing in this collection, this string, or
一个元素的时候才会返回非 nil，这个字符串

1601
01:24:14,249 --> 01:24:15,682
this array, or this dictionary, or
或数组，或字典

1602
01:24:15,750 --> 01:24:17,484
this countable range.
或这可数区间

1603
01:24:17,553 --> 01:24:22,088
And here's how I can implement it, watch this. Return count
而这时我实现它的方法，看好了

1604
01:24:22,157 --> 01:24:27,961
== 1? first : nil. Now how am I able to do this?
return count == 1 ? first : nil 为什么我能这么做呢

1605
01:24:28,029 --> 01:24:32,132
Well count is a collection method, tells how many things
因为 count 是一个集合中的函数，它表示集合中有多少个元素

1606
01:24:32,200 --> 01:24:37,504
in there. first is a collection method, it returns
first 也是一个集合中的函数，它返回

1607
01:24:37,572 --> 01:24:41,341
the first thing in there. So since these are collection
集合中的第一个元素，那么因为它们都是

1608
01:24:41,410 --> 01:24:44,844
methods, I can use them in the implementation of a collection
集合中的函数，我可以在集合中的变量的实现

1609
01:24:44,913 --> 01:24:50,951
var. Seeing the power here of these extensions on protocols.
中使用它们。看到这协议的扩展的能力了吧

1610
01:24:51,019 --> 01:24:54,120
And now, strings, arrays, countable ranges,
那么现在，字符串，数组，可数区间

1611
01:24:54,189 --> 01:24:58,525
they all implement oneAndOnly. So I can go back up here and
它们都实现了 oneAndOnly，所以我可以回到这里

1612
01:24:58,593 --> 01:25:05,165
just return, Return this, remember, it's an array
只用写return... 返回这个，记住，这是一个

1613
01:25:05,234 --> 01:25:09,503
of the indices of face up cards, dot oneAndOnly.
由朝上的牌的下标组成的数组， 后面接上.oneAndOnly

1614
01:25:11,239 --> 01:25:16,743
Okay, and I don't even need this. Okay, even simpler.
那么我这行代码也不需要了，更加简洁了

1615
01:25:16,812 --> 01:25:21,614
By the way, I could absolutely do, let ch
对了，我当然也可以写 let ch

1616
01:25:21,683 --> 01:25:26,286
= hello.oneAndOnly. Okay, now that would return what?
= hello.oneAndOnly 那么它会返回什么

1617
01:25:26,355 --> 01:25:30,924
What would ch be equal to there? Anybody?
ch 在这里会等于什么

1618
01:25:32,427 --> 01:25:33,493
It would be nil,
它会是 nil

1619
01:25:33,562 --> 01:25:37,330
because oneAndOnly returns if there's one and only one
因为 oneAndOnly 如果有唯一一个元素

1620
01:25:37,399 --> 01:25:42,769
element and this string has five elements. If I did this,
就返回那个元素，而 string 中有五个元素，如果我这样写

1621
01:25:42,838 --> 01:25:47,874
what would this return? This will return h, the one and
这会返回什么，这回返回 h

1622
01:25:47,943 --> 01:25:52,946
only thing in that string. So I got that by
这个字符串中的唯一一个元素，我通过

1623
01:25:53,015 --> 01:25:56,917
extending collection, which string and array happen to be.
扩展集合得到了这个函数，而字符串和数组都是集合

1624
01:25:56,986 --> 01:25:58,451
What's the type of this, by the way? ch,
它的类型是什么

1625
01:25:58,520 --> 01:26:03,557
what do you think its type is? It's an optional character.
你们认为 ch 的类型会是什么，它是一个可选的字符类型

1626
01:26:05,427 --> 01:26:09,429
Optional character because the elements of a string are
它是可选的字符类型，因为字符串的元素

1627
01:26:09,498 --> 01:26:13,300
characters. And a string is a collection of characters. But
是字符，字符串是字符的一个集合

1628
01:26:13,368 --> 01:26:17,537
if I click on it, it's gonna say, it's a String.Element.
但如果我点一下它，它会说它是 String.Element

1629
01:26:17,606 --> 01:26:21,408
So just like Array.Index is type alias to be int,
就像 Array.Index 是 Int 的类型别名

1630
01:26:21,476 --> 01:26:25,212
String.Element is type alias to be character.
String.Element 是 Character 的类型别名

1631
01:26:25,280 --> 01:26:27,814
So, you have to look in the documentation to see that or
所以你要去看看官方文档

1632
01:26:27,883 --> 01:26:28,981
you just have to know it.
才能知道这些

1633
01:26:29,050 --> 01:26:30,984
But if you're doing your Alt clicking, I don't want you
但当你 alt + 点击它的时候

1634
01:26:31,053 --> 01:26:32,986
to be surprised when you see that's not a character.
我希望你不要因为它不是一个字符型感到惊讶

1635
01:26:34,756 --> 01:26:39,326
Okay, all right, so a lot of things went on in just this
好的，在这个小的示例中我们展示了非常多的东西

1636
01:26:39,395 --> 01:26:42,562
short demo here. We used the closure right here. And
我们在这里用了闭包

1637
01:26:42,631 --> 01:26:46,767
we also extended a protocol right here to create this
并且我们也在这里扩展了一个协议，来创建

1638
01:26:46,835 --> 01:26:49,202
method here. So hopefully you understand both of those.
了这个方法。那么希望这两个你们都理解了

1639
01:26:49,271 --> 01:26:53,039
If you don't, use Piazza, come up and ask me afterwards or
如果还没有理解，用 Piazza，下课后上来问我问题或者

1640
01:26:53,108 --> 01:26:57,811
whatever. All right, see you next time. Oh,
其他方式，好吧，我们下次见

1641
01:26:57,880 --> 01:26:59,212
wait, sorry one thing, let me go back and
哦等一下，我要回到这

1642
01:26:59,281 --> 01:27:02,182
just show you the coming up. Because there is one thing to
向你们展示一下接下来的安排，因为有一点值得注意

1643
01:27:02,251 --> 01:27:05,852
note here about the coming up. Which is that Friday,
那就是，周五的时候

1644
01:27:05,921 --> 01:27:08,088
we were gonna have the optional section
我们会有可选的课程

1645
01:27:08,156 --> 01:27:10,991
object persistence, we're not gonna do that this Friday.
对象持久性，我们不会在这周五讲它

1646
01:27:11,060 --> 01:27:12,125
We'll do it in a future Friday,
我们会在下周五讲它

1647
01:27:12,194 --> 01:27:14,060
we will do object persistence but in a future Friday.
我们在下周五再讲对象持久性

1648
01:27:14,129 --> 01:27:17,197
So, there's no Friday section at all this week. Next week,
所以这周没有周五的课

1649
01:27:17,265 --> 01:27:19,666
I will be doing views, gestures, multi-touch,
下周我会讲视图，手势，多点触控

1650
01:27:19,735 --> 01:27:24,270
multiple MVCs, all that. >> For more,
多 MVC 那些

1651
01:27:24,339 --> 01:27:26,907
please visit us at Stanford.edu.
>> 更多课程详见 stanford.edu
